.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OS2::DLL 3"
.TH OS2::DLL 3 "2003-09-30" "perl v5.8.2" "Perl Programmers Reference Guide"
.SH "NAME"
OS2::DLL \- access to DLLs with REXX calling convention.
.Sh "NOTE"
.IX Subsection "NOTE"
When you use this module, the REXX variable pool is not available.
.PP
See documentation of OS2::REXX module if you need the variable pool.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        use OS2::DLL;
\&        $emx_dll = OS2::DLL->module('emx');
\&        $emx_version = $emx_dll->emx_revision();
\&        $func_emx_version = $emx_dll->wrapper_REXX('#128'); # emx_revision
\&        $emx_version = $func_emx_version->();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Create a \s-1DLL\s0 handle"
.IX Subsection "Create a DLL handle"
.Vb 1
\&        $dll = OS2::DLL->module( NAME [, WHERE] );
.Ve
.PP
Loads an \s-1OS/2\s0 module \s-1NAME\s0, looking in directories \s-1WHERE\s0 (adding the
extension \fI.dll\fR), if the \s-1DLL\s0 is not found there, loads in the usual \s-1OS/2\s0 way
(via \s-1LIBPATH\s0 and other settings).  Croaks with a verbose report on failure.
.PP
The \s-1DLL\s0 is not unloaded when the return value is destroyed.
.Sh "Create a \s-1DLL\s0 handle (looking in some strange locations)"
.IX Subsection "Create a DLL handle (looking in some strange locations)"
.Vb 1
\&        $dll = OS2::DLL->new( NAME [, WHERE] );
.Ve
.PP
Same as \f(CW\*(C`module\*(C'\fR, but in addition to \s-1WHERE\s0, looks
in environment paths \s-1PERL5REXX\s0, \s-1PERLREXX\s0, \s-1PATH\s0 (provided for backward
compatibility).
.Sh "Loads \s-1DLL\s0 by name"
.IX Subsection "Loads DLL by name"
.Vb 1
\&        $dll = load OS2::DLL NAME [, WHERE];
.Ve
.PP
Same as \f(CW\*(C`new\*(C'\fR,
but returns \s-1DLL\s0 object reference, or undef on failure (in this case one can
get the reason via \f(CW\*(C`DynaLoader::dl_error()\*(C'\fR) (provided for backward
compatibility).
.Sh "Check for functions (optional):"
.IX Subsection "Check for functions (optional):"
.Vb 1
\&        BOOL = $dll->find(NAME [, NAME [, ...]]);
.Ve
.PP
Returns true if all functions are available.  As a side effect, creates
a \s-1REXX\s0 wrapper with the specified name in the package constructed by the name
of the \s-1DLL\s0 so that the next call to \f(CW\*(C`$dll\-\*(C'\fR\s-1\fINAME\s0()\fR> will pick up the cached
method.
.Sh "Create a Perl wrapper (optional):"
.IX Subsection "Create a Perl wrapper (optional):"
.Vb 1
\&        $func = $dll->wrapper_REXX(NAME);
.Ve
.PP
Returns a reference to a Perl function wrapper for the entry point \s-1NAME\s0
in the \s-1DLL\s0.  Similar to the \s-1OS/2\s0 \s-1API\s0, the \s-1NAME\s0 may be \f(CW"#123"\fR \- in this case
the ordinal is loaded.   Croaks with a meaningful error message if \s-1NAME\s0 does
not exists (although the message for the case when the name is an ordinal may
be confusing).
.Sh "Call external function with \s-1REXX\s0 calling convention:"
.IX Subsection "Call external function with REXX calling convention:"
.Vb 1
\&        $ret_string = $dll->function_name(arguments);
.Ve
.PP
Returns the return string if the \s-1REXX\s0 return code is 0, else undef.
Dies with error message if the function is not available.  On the first call
resolves the name in the \s-1DLL\s0 and caches the Perl wrapper; future calls go
through the wrapper.
.PP
Unless used inside \s-1REXX\s0 environment (see \s-1OS2::REXX\s0), the \s-1REXX\s0 runtime
environment (variable pool, queue etc.) is not available to the called
function.
.SH "Low-level API"
.IX Header "Low-level API"
.IP "Call a _System linkage function via a pointer" 4
.IX Item "Call a _System linkage function via a pointer"
If a function takes up to 20 ULONGs and returns \s-1ULONG:\s0
.Sp
.Vb 1
\& $res = call20( $pointer, $arg0, $arg1, ...);
.Ve
.IP "Same for packed arguments:" 4
.IX Item "Same for packed arguments:"
.Vb 1
\& $res = call20_p( $pointer, pack 'L20', $arg0, $arg1, ...);
.Ve
.ie n .IP "Same for regparm(3) function:" 4
.el .IP "Same for \f(CWregparm(3)\fR function:" 4
.IX Item "Same for regparm(3) function:"
.Vb 1
\& $res = call20_rp3( $pointer, $arg0, $arg1, ...);
.Ve
.ie n .IP "Same for packed arguments and regparm(3) function" 4
.el .IP "Same for packed arguments and \f(CWregparm(3)\fR function" 4
.IX Item "Same for packed arguments and regparm(3) function"
.Vb 1
\& $res = call20_rp3_p( $pointer, pack 'L20', $arg0, $arg1, ...);
.Ve
.IP "Same for a function which returns non\-0 and sets system-error on error" 4
.IX Item "Same for a function which returns non-0 and sets system-error on error"
.Vb 1
\& call20_Dos( $msg, $pointer, $arg0, $arg1, ...); # die("$msg: $^E") if error
.Ve
.Sp
[Good for \f(CW\*(C`Dos*\*(C'\fR \s-1API\s0 \- and rare \f(CW\*(C`Win*\*(C'\fR calls.]
.IP "Same for a function which returns 0 and sets \fIWinLastError()\fR on error" 4
.IX Item "Same for a function which returns 0 and sets WinLastError() on error"
.Vb 2
\& $res = call20_Win( $msg, $pointer, $arg0, $arg1, ...);
\& # would die("$msg: $^E") if error
.Ve
.Sp
[Good for most of \f(CW\*(C`Win*\*(C'\fR \s-1API\s0.]
.IP "Same for a function which returns 0 and sets \fIWinLastError()\fR on error but 0 is also a valid return" 4
.IX Item "Same for a function which returns 0 and sets WinLastError() on error but 0 is also a valid return"
.Vb 2
\& $res = call20_Win_0OK( $msg, $pointer, $arg0, $arg1, ...);
\& # would die("$msg: $^E") if error
.Ve
.Sp
[Good for some of \f(CW\*(C`Win*\*(C'\fR \s-1API\s0.]
.IP "As previous, but without \fIdie()\fR" 4
.IX Item "As previous, but without die()"
.Vb 3
\& $res = call20_Win_0OK_survive( $pointer, $arg0, $arg1, ...);
\& if ($res == 0 and $^E) {       # Do error processing here
\& }
.Ve
.Sp
[Good for some of \f(CW\*(C`Win*\*(C'\fR \s-1API\s0.]
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
If \f(CW\*(C`PERL_REXX_DEBUG\*(C'\fR is set, emits debugging output.  Looks for DLLs
in \f(CW\*(C`PERL5REXX\*(C'\fR, \f(CW\*(C`PERLREXX\*(C'\fR, \f(CW\*(C`PATH\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Extracted by Ilya Zakharevich perl\-module\-OS2\-DLL@ilyaz.org from \s-1OS2::REXX\s0
written by Andreas Kaiser ak@ananke.s.bawue.de.
