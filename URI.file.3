.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH URI::file 3 "perl 5.007, patch 00" "7/Apr/100" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
URI::file \- URI that map to local file names
.SH "SYNOPSIS"
.PP
.Vb 1
\& use URI::file;
.Ve
.Vb 2
\& $u1 = URI->new("file:/foo/bar");
\& $u2 = URI->new("foo/bar", "file");
.Ve
.Vb 5
\& $u3 = URI::file->new($path);
\& $u4 = URI::file->new("c:\e\ewindows\e\e", "win32");
\& 
\& $u1->file;
\& $u1->file("mac");
.Ve
.SH "DESCRIPTION"
The \f(CWURI::file\fR class supports \f(CWURI\fR objects belonging to the \fIfile\fR
URI scheme.  This scheme allows us to map the conventional file names
found on various computer systems to the URI name space.  An old
specification of the \fIfile\fR URI scheme is found in RFC 1738.  Some
older background information is also in RFC 1630. There are no newer
specifications as far as I know.
.PP
If you want simply to construct \fIfile\fR URI objects from URI strings,
use the normal \f(CWURI\fR constructor.  If you want to construct \fIfile\fR
URI objects from the actual file names used by various systems, then
use one of the following \f(CWURI::file\fR constructors:
.Ip "$u = \s-1URI::\s0file->new( $filename, [$os] )" 4
Maps a file name to the \fIfile:\fR \s-1URI\s0 name space, creates an \s-1URI\s0 object
and returns it.  The \f(CW$filename\fR is interpreted as one belonging to the
indicated operating system ($os), which defaults to the value of the
$^O variable.  The \f(CW$filename\fR can be either absolute or relative, and
the corresponding type of \s-1URI\s0 object for \f(CW$os\fR is returned.
.Ip "$u = \s-1URI::\s0file->new_abs( $filename, [$os] )" 4
Same as \s-1URI::\s0file->new, but will make sure that the \s-1URI\s0 returned
represents an absolute file name.  If the \f(CW$filename\fR argument is
relative, then the name is resolved relative to the current directory,
i.e. this constructor is really the same as:
.Sp
.Vb 1
\&  URI::file->new($filename)->abs(URI::file->cwd);
.Ve
.Ip "$u = \s-1URI::\s0file->cwd" 4
Returns a \fIfile\fR \s-1URI\s0 that represents the current working directory.
See the \fICwd\fR manpage.
.PP
The following methods are supported for \fIfile\fR \s-1URI\s0 (in addition to
the common and generic methods described in the \fI\s-1URI\s0\fR manpage):
.Ip "$u->file( [$os] )" 4
This method return a file name.  It maps from the \s-1URI\s0 name space
to the file name space of the indicated operating system.
.Sp
It might return \f(CWundef\fR if the name can not be represented in the
indicated file system.
.Ip "$u->dir( [$os] )" 4
Some systems use a different form for names of directories than for plain
files.  Use this method if you know you want to use the name for
a directory.
.PP
The \f(CWURI::file\fR module can be used to map generic file names to names
suitable for the current system.  As such, it can work as a nice
replacement for the \f(CWFile::Spec\fR module.  For instance the following
code will translate the Unix style file name \fIFoo/Bar.pm\fR to a name
suitable for the local system.
.PP
.Vb 4
\&  $file = URI::file->new("Foo/Bar.pm", "unix")->file;
\&  die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
\&  open(FILE, $file) || die "Can't open '$file': $!";
\&  # do something with FILE
.Ve
.SH "MAPPING NOTES"
Most computer systems today have hierarchically organized file systems.
Mapping the names used in these systems to the generic URI syntax
allows us to work with relative file URIs that behave as they should
when resolved using the generic algorithm for URIs (specified in RFC
2396).  Mapping a file name to the generic URI syntax involves mapping
the path separator character to \*(L"/\*(R" and encoding of any reserved
characters that appear in the path segments of the file names.  If
path segments consisting of the strings \*(L".\*(R" or \*(L"..\*(R" have a
different meaning than what is specified for generic URIs, then these
must be encoded as well.
.PP
If the file system has device, volume or drive specifications as
the root of the name space, then it makes sense to map them to the
authority field of the generic URI syntax.  This makes sure that
relative URI can not be resolved \*(L"above\*(R" them , i.e. generally how
relative file names work in those systems.
.PP
Another common use of the authority field is to encode the host that
this file name is valid on.  The host name \*(L"localhost\*(R" is special and
generally have the same meaning as an missing or empty authority
field.  This use will be in conflict with using it as a device
specification, but can often be resolved for device specifications
having characters not legal in plain host names.
.PP
File name to URI mapping in normally not one-to-one.  There are
usually many URI that map to the same file name.  For instance an
authority of \*(L"localhost\*(R" maps the same as a URI with a missing or empty
authority.
.PP
Example 1: The Mac use \*(L":\*(R" as path separator, but not in the same way
as generic URI. \*(L":foo\*(R" is a relative name.  \*(L"foo:bar\*(R" is an absolute
name.  Also path segments can contain the \*(L"/\*(R" character as well as be
literal \*(L".\*(R" or \*(L"..\*(R".  It means that we will map like this:
.PP
.Vb 15
\&  Mac                   URI
\&  ----------            -------------------
\&  :foo:bar     <==>     foo/bar
\&  :            <==>     ./
\&  ::foo:bar    <==>     ../foo/bar
\&  :::          <==>     ../../
\&  foo:bar      <==>     file:/foo/bar
\&  foo:bar:     <==>     file:/foo/bar/
\&  ..           <==>     %2E%2E
\&  <undef>      <==      /
\&  foo/         <==      file:/foo%2F
\&  ./foo.txt    <==      file:/.%2Ffoo.txt
\&  
\&Note that if you want a relative URL, you *must* begin the path with a :.  Any
\&path that begins with [^:] will be treated as absolute.
.Ve
Example 2: The Unix file system is easy to map as it use the same path
separator as URIs, have a single root, and segments of \*(L".\*(R" and \*(L"..\*(R"
have the same meaning.  URIs that have the character \*(L"\e0\*(R" or \*(L"/\*(R" as
part of any path segment can not be turned into valid Unix file names.
.PP
.Vb 8
\&  Unix                  URI
\&  ----------            ------------------
\&  foo/bar      <==>     foo/bar
\&  /foo/bar     <==>     file:/foo/bar
\&  /foo/bar     <==      file://localhost/foo/bar
\&  file:         ==>     ./file:
\&  <undef>      <==      file:/fo%00/bar
\&  /            <==>     file:/
.Ve
.SH "SEE ALSO"
the \fIURI\fR manpage, the \fIFile::Spec\fR manpage, the \fIperlport\fR manpage
.SH "COPYRIGHT"
Copyright 1995-1998 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

.rn }` ''
.IX Title "URI::file 3"
.IX Name "URI::file - URI that map to local file names"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "$u = \s-1URI::\s0file->new( $filename, [$os] )"

.IX Item "$u = \s-1URI::\s0file->new_abs( $filename, [$os] )"

.IX Item "$u = \s-1URI::\s0file->cwd"

.IX Item "$u->file( [$os] )"

.IX Item "$u->dir( [$os] )"

.IX Header "MAPPING NOTES"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

