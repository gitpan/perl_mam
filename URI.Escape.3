.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH URI::Escape 3 "perl 5.007, patch 00" "26/Oct/101" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
URI::Escape \- Escape and unescape unsafe characters
.SH "SYNOPSIS"
.PP
.Vb 4
\& use URI::Escape;
\& $safe = uri_escape("10% is enough\en");
\& $verysafe = uri_escape("foo", "\e0-\e377");
\& $str  = uri_unescape($safe);
.Ve
.SH "DESCRIPTION"
This module provides functions to escape and unescape URI strings as
defined by RFC 2396 (and updated by RFC 2732).
URIs consist of a restricted set of characters,
denoted as \f(CWuric\fR in RFC 2396.  The restricted set of characters
consists of digits, letters, and a few graphic symbols chosen from
those common to most of the character encodings and input facilities
available to Internet users:
.PP
.Vb 3
\&  "A" .. "Z", "a" .. "z", "0" .. "9",
\&  ";", "/", "?", ":", "@", "&", "=", "+", "$", ",", "[", "]",   # reserved
\&  "-", "_", ".", "!", "~", "*", "'", "(", ")"
.Ve
In addition any byte (octet) can be represented in a URI by an escape
sequence; a triplet consisting of the character \*(L"%\*(R" followed by two
hexadecimal digits.  Bytes can also be represented directly by a
character using the US\-ASCII character for that octet (iff the
character is part of \f(CWuric\fR).
.PP
Some of the \f(CWuric\fR characters are \fIreserved\fR for use as delimiters
or as part of certain URI components.  These must be escaped if they are
to be treated as ordinary data.  Read RFC 2396 for further details.
.PP
The functions provided (and exported by default) from this module are:
.Ip "uri_escape($string, [$unsafe])" 4
This function replaces all unsafe characters in the \f(CW$string\fR with their
escape sequences and returns the result.
.Sp
The \fIuri_escape()\fR function takes an optional second argument that
overrides the set of characters that are to be escaped.  The set is
specified as a string that can be used in a regular expression
character class (between [ ]).  E.g.:
.Sp
.Vb 3
\&  "\ex00-\ex1f\ex7f-\exff"          # all control and hi-bit characters
\&  "a-z"                         # all lower case characters
\&  "^A-Za-z"                     # everything not a letter
.Ve
The default set of characters to be escaped is all those which are
\fInot\fR part of the \f(CWuric\fR character class shown above as well as the
reserved characters.  I.e. the default is:
.Sp
.Vb 1
\&  "^A-Za-z0-9\e-_.!~*'()"
.Ve
.Ip "uri_unescape($string,...)" 4
Returns a string with all \f(CW%XX\fR sequences replaced with the actual byte
(octet).
.Sp
This does the same as:
.Sp
.Vb 1
\&   $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
.Ve
but does not modify the string in-place as this \s-1RE\s0 would.  Using the
\fIuri_unescape()\fR function instead of the \s-1RE\s0 might make the code look
cleaner and is a few characters less to type.
.Sp
In a simple benchmark test I made I got something like 40% slowdown by
calling the function (instead of the inline \s-1RE\s0 above) if a few chars
where unescaped and something like 700% slowdown if none where.  If
you are going to unescape a lot of times it might be a good idea to
inline the \s-1RE\s0.
.Sp
If the \fIuri_unescape()\fR function is passed multiple strings, then each
one is unescaped returned.
.PP
The module can also export the \f(CW%escapes\fR hash which contains the
mapping from all 256 bytes to the corresponding escape code.  Lookup
in this hash is faster than evaluating \f(CWsprintf("%%%02X", ord($byte))\fR
each time.
.SH "SEE ALSO"
the \fIURI\fR manpage
.SH "COPYRIGHT"
Copyright 1995-2001 Gisle Aas.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

.rn }` ''
.IX Title "URI::Escape 3"
.IX Name "URI::Escape - Escape and unescape unsafe characters"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "uri_escape($string, [$unsafe])"

.IX Item "uri_unescape($string,...)"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

