.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::IO::Wrap 3 "perl 5.007, patch 00" "16/Aug/101" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
IO::Wrap \- wrap raw filehandles in IO::Handle interface
.SH "SYNOPSIS"
.PP
.Vb 19
\&   use IO::Wrap;
\&       
\&   ### Do stuff with any kind of filehandle (including a bare globref), or 
\&   ### any kind of blessed object that responds to a print() message.
\&   ###
\&   sub do_stuff {
\&       my $fh = shift;         
\&       
\&       ### At this point, we have no idea what the user gave us... 
\&       ### a globref? a FileHandle? a scalar filehandle name?
\&       
\&       $fh = wraphandle($fh);  
\&        
\&       ### At this point, we know we have an IO::Handle-like object!
\&       
\&       $fh->print("Hey there!");
\&       ...
\&   }
\&    
.Ve
.SH "DESCRIPTION"
Let's say you want to write some code which does I/O, but you don't 
want to force the caller to provide you with a FileHandle or IO::Handle
object.  You want them to be able to say:
.PP
.Vb 4
\&    do_stuff(\e*STDOUT);
\&    do_stuff('STDERR');
\&    do_stuff($some_FileHandle_object);
\&    do_stuff($some_IO_Handle_object);
.Ve
And even:
.PP
.Vb 1
\&    do_stuff($any_object_with_a_print_method);
.Ve
Sure, one way to do it is to force the caller to use \fItiehandle()\fR.  
But that puts the burden on them.  Another way to do it is to 
use \fBIO::Wrap\fR, which provides you with the following functions:
.Ip "wraphandle \s-1SCALAR\s0" 4
This function will take a single argument, and \*(L"wrap\*(R" it based on
what it seems to be...
.Ip "\(bu" 8
\fBA raw scalar filehandle name,\fR like \f(CW"STDOUT"\fR or \f(CW"Class::HANDLE"\fR.
In this case, the filehandle name is wrapped in an \s-1IO::\s0Wrap object, 
which is returned.
.Ip "\(bu" 8
\fBA raw filehandle glob,\fR like \f(CW\e*STDOUT\fR.
In this case, the filehandle glob is wrapped in an \s-1IO::\s0Wrap object, 
which is returned.
.Ip "\(bu" 8
\fBA blessed FileHandle object.\fR
In this case, the FileHandle is wrapped in an \s-1IO::\s0Wrap object if and only
if your FileHandle class does not support the \f(CWread()\fR method.
.Ip "\(bu" 8
\fBAny other kind of blessed object,\fR which is assumed to be already
conformant to the \s-1IO::\s0Handle interface.
In this case, you just get back that object.
.PP
If you get back an \s-1IO::\s0Wrap object, it will obey a basic subset of
the \s-1IO\s0:: interface.  That is, the following methods (note: I said
\fImethods\fR, not named operators) should work on the thing you get back:
.PP
.Vb 7
\&    close 
\&    getline 
\&    getlines 
\&    print ARGS...
\&    read BUFFER,NBYTES
\&    seek POS,WHENCE
\&    tell 
.Ve
.SH "NOTES"
Clearly, when wrapping a raw external filehandle (like \e*STDOUT), 
I didn't want to close the file descriptor when the \*(L"wrapper\*(R" object is
destroyed... since the user might not appreciate that!  Hence,
there's no DESTROY method in this class.
.PP
When wrapping a FileHandle object, however, I believe that Perl will 
invoke the FileHandle::DESTROY when the last reference goes away,
so in that case, the filehandle is closed if the wrapped FileHandle
really was the last reference to it.
.SH "WARNINGS"
This module does not allow you to wrap filehandle names which are given
as strings that lack the package they were opened in. That is, if a user 
opens FOO in package Foo, they must pass it to you either as \f(CW\e*FOO\fR 
or as \f(CW"Foo::FOO"\fR.  However, \f(CW"STDIN"\fR and friends will work just fine.
.SH "VERSION"
$Id: Wrap.pm,v 2.102 2001/08/17 02:06:33 eryq Exp $
    
.SH "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR).
President, ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).

.rn }` ''
.IX Title "lib::IO::Wrap 3"
.IX Name "IO::Wrap - wrap raw filehandles in IO::Handle interface"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "wraphandle \s-1SCALAR\s0"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "NOTES"

.IX Header "WARNINGS"

.IX Header "VERSION"

.IX Header "AUTHOR"

