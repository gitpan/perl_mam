.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH SCAN 1 "perl 5.003, patch 10" "27/Sep/96" "User Contributed Perl Documentation"
.IX Title "SCAN 1"
.UC
.IX Name "C::Scan - scan C language files for easily recognized constructs."
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
C::Scan \- scan C language files for easily recognized constructs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 5
\&  $c = new C::Scan 'filename' => $filename, 'filename_filter' => $filter,
\&                   'add_cppflags' => $addflags;
\&  $c->set('includeDirs' => [$Config::Config{shrpdir}]);
\&  
\&  my $fdec = $c->get('parsed_fdecls');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\fBThis description is \fIVERY\fR incomplete.\fR
.PP
This module uses \f(CWData::Flow\fR interface, thus one uses it in the
following fashion:
.PP
.Vb 2
\&  $c = new C::Scan(attr1 => $value1, attr2 => $value2);
\&  $c->set( attr3 => $value3 );
.Ve
.Vb 1
\&  $value4 = $c->get('attr4');
.Ve
Attributes are depending on some other attributes. The only
\fIrequired\fR attribute, i.e., the attribute which \fIshould\fR be set, is
\f(CWfilename\fR, which denotes which file to parse.
.PP
All other attributes are either optional, or would be calculated basing on values of required and optional attributes.
.Sh "Output attributes"
.IX Subsection "Output attributes"
.Ip "\f(CWincludes\fR" 14
.IX Item "\f(CWincludes\fR"
Value: reference to a list of included files.
.Ip "\f(CWdefines_args\fR" 14
.IX Item "\f(CWdefines_args\fR"
Value: reference to hash of macros with arguments. The values are
references to an array of length 2, the first element is a reference
to the list of arguments, the second one being the expansion.
Newlines are not unescaped, thus
.Sp
.Vb 2
\&  #define C(x,y) E\e
\&                 F
.Ve
will finish with \f(CW("C" => [ ["x", "y"], "E\enF"])\fR.
.Ip "\f(CWdefines_no_args\fR" 14
.IX Item "\f(CWdefines_no_args\fR"
Value: reference to hash of macros without arguments.  Newlines are
not escaped, thus
.Sp
.Vb 1
\&  #define A B
.Ve
will finish with \f(CW("A" => "B")\fR.
.Ip "\f(CWfdecls\fR" 14
.IX Item "\f(CWfdecls\fR"
Value: reference to list of declarations of functions.
.Ip "\f(CWinlines\fR" 14
.IX Item "\f(CWinlines\fR"
Value: reference to list of definitions of functions.
.Ip "\f(CWparsed_fdecls\fR" 14
.IX Item "\f(CWparsed_fdecls\fR"
Value: reference to list of parsed declarations of functions. 
.Sp
A parsed declaration is a reference to a list of \f(CW(rt, nm, args, ft,
mod)\fR. Here \f(CWrt\fR is return type of a function, \f(CWnm\fR is the name,
\f(CWargs\fR is the list of arguments, \f(CWft\fR is the full text of the
declaration, and \f(CWmod\fR is the modifier (which is always \f(CWundef\fR).
.Sp
Each entry in the list \f(CWargs\fR is of the same form \f(CW(ty, nm, args,
ft, mod)\fR, here \f(CWty\fR is the type of an argument, \f(CWnm\fR is the name (a
generated one if missing in the declaration), \f(CWargs\fR is \f(CWundef\fR, and
\f(CWmod\fR is the string of array modifiers.
.Ip "\f(CWtypedef_hash\fR" 14
.IX Item "\f(CWtypedef_hash\fR"
Value: a reference to a hash which contains known \f(CWtypedef\fRs as keys.
.Ip "\f(CWtypedef_texts\fR" 14
.IX Item "\f(CWtypedef_texts\fR"
Value: a reference to a list which contains known expansions of
\f(CWtypedef\fRs.
.Ip "\f(CWtypedefs_maybe\fR" 14
.IX Item "\f(CWtypedefs_maybe\fR"
Value: a reference to a list of \f(CWtypedef\fRed names. (Syncronized with
\f(CWtypedef_texts\fR).
.Ip "\f(CWvdecls\fR" 14
.IX Item "\f(CWvdecls\fR"
Value: a reference to a list of \f(CWextern\fR variable declarations.

.rn }` ''
