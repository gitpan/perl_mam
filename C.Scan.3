.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Scan 3 "perl 5.005, patch 53" "23/Mar/100" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
C::Scan \- scan C language files for easily recognized constructs.
.SH "SYNOPSIS"
.PP
.Vb 3
\&  $c = new C::Scan 'filename' => $filename, 'filename_filter' => $filter,
\&                   'add_cppflags' => $addflags;
\&  $c->set('includeDirs' => [$Config::Config{shrpdir}]);
.Ve
.Vb 1
\&  my $fdec = $c->get('parsed_fdecls');
.Ve
.SH "DESCRIPTION"
\fBThis description is \fIVERY\fR incomplete.\fR
.PP
This module uses \f(CWData::Flow\fR interface, thus one uses it in the
following fashion:
.PP
.Vb 2
\&  $c = new C::Scan(attr1 => $value1, attr2 => $value2);
\&  $c->set( attr3 => $value3 );
.Ve
.Vb 1
\&  $value4 = $c->get('attr4');
.Ve
Attributes are depending on some other attributes. The only
\fIrequired\fR attribute, i.e., the attribute which \fIshould\fR be set, is
\f(CWfilename\fR, which denotes which file to parse.
.PP
All other attributes are either optional, or would be calculated basing on values of required and optional attributes.
.Sh "Output attributes"
.Ip "\f(CWincludes\fR" 14
Value: reference to a list of included files.
.Ip "\f(CWdefines_args\fR" 14
Value: reference to hash of macros with arguments. The values are
references to an array of length 2, the first element is a reference
to the list of arguments, the second one being the expansion.
Newlines are not unescaped, thus
.Sp
.Vb 2
\&  #define C(x,y) E\e
\&                 F
.Ve
will finish with \f(CW("C" => [ ["x", "y"], "E\enF"])\fR.
.Ip "\f(CWdefines_no_args\fR" 14
Value: reference to hash of macros without arguments.  Newlines are
not escaped, thus
.Sp
.Vb 1
\&  #define A B
.Ve
will finish with \f(CW("A" => "B")\fR.
.Ip "\f(CWfdecls\fR" 14
Value: reference to list of declarations of functions.
.Ip "\f(CWinlines\fR" 14
Value: reference to list of definitions of functions.
.Ip "\f(CWparsed_fdecls\fR" 14
Value: reference to list of parsed declarations of functions. 
.Sp
A parsed declaration is a reference to a list of \f(CW(rt, nm, args, ft,
mod)\fR. Here \f(CWrt\fR is return type of a function, \f(CWnm\fR is the name,
\f(CWargs\fR is the list of arguments, \f(CWft\fR is the full text of the
declaration, and \f(CWmod\fR is the modifier (which is always \f(CWundef\fR).
.Sp
Each entry in the list \f(CWargs\fR is of the same form \f(CW(ty, nm, args,
ft, mod)\fR, here \f(CWty\fR is the type of an argument, \f(CWnm\fR is the name (a
generated one if missing in the declaration), \f(CWargs\fR is \f(CWundef\fR, and
\f(CWmod\fR is the string of array modifiers.
.Ip "\f(CWtypedef_hash\fR" 14
Value: a reference to a hash which contains known \f(CWtypedef\fRs as keys.
Values of the hash are array references of length 2, with what should
be put before/after the type for a standalone typedef declaration (but
without the \f(CWtypedef\fR substring).
.Sp
Parse uses naive heuristics.
.Ip "\f(CWtypedef_texts\fR" 14
Value: a reference to a list which contains known expansions of
\f(CWtypedef\fRs.
.Ip "\f(CWtypedefs_maybe\fR" 14
Value: a reference to a list of \f(CWtypedef\fRed names.  Heuristics are used.
.Ip "\f(CWvdecls\fR" 14
Value: a reference to a list of \f(CWextern\fR variable declarations.
.Ip "\f(CWvdecl_hash\fR" 14
Value: a reference to a hash of parsed \f(CWextern\fR variable declarations,
containing the variable names as keys. Values of the hash are array
references of length 2, with what should be put before/after the name
for a standalone extern variable declaration (but without the \f(CWextern\fR
substring).
.Ip "\f(CWtypedef_structs\fR" 14
Value: a reference to a hash of parsed struct declarations from typedefs.
Keys are typedefed names, values are \f(CWundef\fR if not a struct or union,
else an array reference of definitions of the elements of the structure;
each definition is itself an array reference of length 3, consisting of
what should be put before/after the name for a standalone variable
declaration, followed by the name of the element. Anonymous structs and
unions used within the definitions are given an arbitrary name including
the string \f(CWANON\fR, and referred to using that name.

.rn }` ''
.IX Title "Scan 3"
.IX Name "C::Scan - scan C language files for easily recognized constructs."

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Subsection "Output attributes"

.IX Item "\f(CWincludes\fR"

.IX Item "\f(CWdefines_args\fR"

.IX Item "\f(CWdefines_no_args\fR"

.IX Item "\f(CWfdecls\fR"

.IX Item "\f(CWinlines\fR"

.IX Item "\f(CWparsed_fdecls\fR"

.IX Item "\f(CWtypedef_hash\fR"

.IX Item "\f(CWtypedef_texts\fR"

.IX Item "\f(CWtypedefs_maybe\fR"

.IX Item "\f(CWvdecls\fR"

.IX Item "\f(CWvdecl_hash\fR"

.IX Item "\f(CWtypedef_structs\fR"

