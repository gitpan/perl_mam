.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH CGI 3 "perl 5.005, patch 53" "28/Jun/98" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
CGI \- Simple Common Gateway Interface Class
.SH "SYNOPSIS"
.PP
.Vb 2
\&  # CGI script that creates a fill-out form
\&  # and echoes back its values.
.Ve
.Vb 16
\&  use CGI qw/:standard/;
\&  print header,
\&        start_html('A Simple Example'),
\&        h1('A Simple Example'),
\&        start_form,
\&        "What's your name? ",textfield('name'),p,
\&        "What's the combination?", p,
\&        checkbox_group(-name=>'words',
\&                       -values=>['eenie','meenie','minie','moe'],
\&                       -defaults=>['eenie','minie']), p,
\&        "What's your favorite color? ",
\&        popup_menu(-name=>'color',
\&                   -values=>['red','green','blue','chartreuse']),p,
\&        submit,
\&        end_form,
\&        hr;
.Ve
.Vb 6
\&   if (param()) {
\&       print "Your name is",em(param('name')),p,
\&             "The keywords are: ",em(join(", ",param('words'))),p,
\&             "Your favorite color is ",em(param('color')),
\&             hr;
\&   }
.Ve
.SH "ABSTRACT"
This perl library uses perl5 objects to make it easy to create Web
fill-out forms and parse their contents.  This package defines CGI
objects, entities that contain the values of the current query string
and other state variables.  Using a CGI object's methods, you can
examine keywords and parameters passed to your script, and create
forms whose initial values are taken from the current query (thereby
preserving state information).  The module provides shortcut functions
that produce boilerplate HTML, reducing typing and coding errors. It
also provides functionality for some of the more advanced features of
CGI scripting, including support for file uploads, cookies, cascading
style sheets, server push, and frames.
.PP
CGI.pm also provides a simple function-oriented programming style for
those who don't need its object-oriented features.
.PP
The current version of CGI.pm is available at
.PP
.Vb 2
\&  http://www.genome.wi.mit.edu/ftp/pub/software/WWW/cgi_docs.html
\&  ftp://ftp-genome.wi.mit.edu/pub/software/WWW/
.Ve
.SH "DESCRIPTION"
.Sh "\s-1PROGRAMMING\s0 \s-1STYLE\s0"
There are two styles of programming with \s-1CGI\s0.pm, an object-oriented
style and a function-oriented style.  In the object-oriented style you
create one or more \s-1CGI\s0 objects and then use object methods to create
the various elements of the page.  Each \s-1CGI\s0 object starts out with the
list of named parameters that were passed to your \s-1CGI\s0 script by the
server.  You can modify the objects, save them to a file or database
and recreate them.  Because each object corresponds to the \*(L"state\*(R" of
the \s-1CGI\s0 script, and because each object's parameter list is
independent of the others, this allows you to save the state of the
script and restore it later.
.PP
For example, using the object oriented style, here is now you create
a simple \*(L"Hello World\*(R" \s-1HTML\s0 page:
.PP
.Vb 7
\&   #!/usr/local/bin/pelr
\&   use CGI;                             # load CGI routines
\&   $q = new CGI;                        # create new CGI object
\&   print $q->header,                    # create the HTTP header
\&         $q->start_html('hello world'), # start the HTML
\&         $q->h1('hello world'),         # level 1 header
\&         $q->end_html;                  # end the HTML
.Ve
In the function-oriented style, there is one default \s-1CGI\s0 object that
you rarely deal with directly.  Instead you just call functions to
retrieve \s-1CGI\s0 parameters, create \s-1HTML\s0 tags, manage cookies, and so
on.  This provides you with a cleaner programming interface, but
limits you to using one \s-1CGI\s0 object at a time.  The following example
prints the same page, but uses the function-oriented interface.
The main differences are that we now need to import a set of functions
into our name space (usually the \*(L"standard\*(R" functions), and we don't
need to create the \s-1CGI\s0 object.
.PP
.Vb 6
\&   #!/usr/local/bin/pelr
\&   use CGI qw/:standard/;           # load standard CGI routines
\&   print header,                    # create the HTTP header
\&         start_html('hello world'), # start the HTML
\&         h1('hello world'),         # level 1 header
\&         end_html;                  # end the HTML
.Ve
The examples in this document mainly use the object-oriented style.
See \s-1HOW\s0 \s-1TO\s0 \s-1IMPORT\s0 \s-1FUNCTIONS\s0 for important information on
function-oriented programming in \s-1CGI\s0.pm
.Sh "\s-1CALLING\s0 \s-1CGI\s0.\s-1PM\s0 \s-1ROUTINES\s0"
Most \s-1CGI\s0.pm routines accept several arguments, sometimes as many as 20
optional ones!  To simplify this interface, all routines use a named
argument calling style that looks like this:
.PP
.Vb 1
\&   print $q->header(-type=>'image/gif',-expires=>'+3d');
.Ve
Each argument name is preceded by a dash.  Neither case nor order
matters in the argument list.  \-type, \-Type, and \-\s-1TYPE\s0 are all
acceptable.  In fact, only the first argument needs to begin with a
dash.  If a dash is present in the first argument, \s-1CGI\s0.pm assumes
dashes for the subsequent ones.
.PP
You don't have to use the hyphen at allif you don't want to.  After
creating a \s-1CGI\s0 object, call the \fBuse_named_parameters()\fR method with
a nonzero value.  This will tell \s-1CGI\s0.pm that you intend to use named
parameters exclusively:
.PP
.Vb 5
\&   $query = new CGI;
\&   $query->use_named_parameters(1);
\&   $field = $query->radio_group('name'=>'OS',
\&                                'values'=>['Unix','Windows','Macintosh'],
\&                                'default'=>'Unix');
.Ve
Several routines are commonly called with just one argument.  In the
case of these routines you can provide the single argument without an
argument name.  \fIheader()\fR happens to be one of these routines.  In this
case, the single argument is the document type.
.PP
.Vb 1
\&   print $q->header('text/html');
.Ve
Other such routines are documented below.
.PP
Sometimes named arguments expect a scalar, sometimes a reference to an
array, and sometimes a reference to a hash.  Often, you can pass any
type of argument and the routine will do whatever is most appropriate.
For example, the \fIparam()\fR routine is used to set a \s-1CGI\s0 parameter to a
single or a multi-valued value.  The two cases are shown below:
.PP
.Vb 2
\&   $q->param(-name=>'veggie',-value=>'tomato');
\&   $q->param(-name=>'veggie',-value=>'[tomato','tomahto','potato','potahto']);
.Ve
A large number of routines in \s-1CGI\s0.pm actually aren't specifically
defined in the module, but are generated automatically as needed.
These are the \*(L"\s-1HTML\s0 shortcuts,\*(R" routines that generate \s-1HTML\s0 tags for
use in dynamically-generated pages.  \s-1HTML\s0 tags have both attributes
(the attribute="value\*(R" pairs within the tag itself) and contents (the
part between the opening and closing pairs.)  To distinguish between
attributes and contents, \s-1CGI\s0.pm uses the convention of passing \s-1HTML\s0
attributes as a hash reference as the first argument, and the
contents, if any, as any subsequent arguments.  It works out like
this:
.PP
.Vb 6
\&   Code                           Generated HTML
\&   ----                           --------------
\&   h1()                           <H1>
\&   h1('some','contents');         <H1>some contents</H1>
\&   h1({-align=>left});            <H1 ALIGN="LEFT">
\&   h1({-align=>left},'contents'); <H1 ALIGN="LEFT">contents</H1>
.Ve
\s-1HTML\s0 tags are described in more detail later.  
.PP
Many newcomers to \s-1CGI\s0.pm are puzzled by the difference between the
calling conventions for the \s-1HTML\s0 shortcuts, which require curly braces
around the \s-1HTML\s0 tag attributes, and the calling conventions for other
routines, which manage to generate attributes without the curly
brackets.  Don't be confused.  As a convenience the curly braces are
optional in all but the \s-1HTML\s0 shortcuts.  If you like, you can use
curly braces when calling any routine that takes named arguments.  For
example:
.PP
.Vb 1
\&   print $q->header( {-type=>'image/gif',-expires=>'+3d'} );
.Ve
If you use the \fB\-w\fR switch, you will be warned that some \s-1CGI\s0.pm argument
names conflict with built-in Perl functions.  The most frequent of
these is the \-values argument, used to create multi-valued menus,
radio button clusters and the like.  To get around this warning, you
have several choices:
.Ip "1. Use another name for the argument, if one is available.  For example, \-value is an alias for \-values." 4
.Ip "2. Change the capitalization, e.g. \-Values" 4
.Ip "3. Put quotes around the argument name, e.g. \*(N'\-values\*(T'" 4
.PP
Many routines will do something useful with a named argument that it
doesn't recognize.  For example, you can produce non-standard \s-1HTTP\s0
header fields by providing them as named arguments:
.PP
.Vb 4
\&  print $q->header(-type  =>  'text/html',
\&                   -cost  =>  'Three smackers',
\&                   -annoyance_level => 'high',
\&                   -complaints_to   => 'bit bucket');
.Ve
This will produce the following nonstandard \s-1HTTP\s0 header:
.PP
.Vb 5
\&   HTTP/1.0 200 OK
\&   Cost: Three smackers
\&   Annoyance-level: high
\&   Complaints-to: bit bucket
\&   Content-type: text/html
.Ve
Notice the way that underscores are translated automatically into
hyphens.  \s-1HTML\s0\-generating routines perform a different type of
translation. 
.PP
This feature allows you to keep up with the rapidly changing \s-1HTTP\s0 and
\s-1HTML\s0 \*(L"standards\*(R".
.Sh "\s-1CREATING\s0 A \s-1NEW\s0 \s-1QUERY\s0 \s-1OBJECT\s0 (\s-1OBJECT\s0\-\s-1ORIENTED\s0 \s-1STYLE\s0):"
.PP
.Vb 1
\&     $query = new CGI;
.Ve
This will parse the input (from both \s-1POST\s0 and \s-1GET\s0 methods) and store
it into a perl5 object called \f(CW$query\fR.  
.Sh "\s-1CREATING\s0 A \s-1NEW\s0 \s-1QUERY\s0 \s-1OBJECT\s0 \s-1FROM\s0 \s-1AN\s0 \s-1INPUT\s0 \s-1FILE\s0"
.PP
.Vb 1
\&     $query = new CGI(INPUTFILE);
.Ve
If you provide a file handle to the \fInew()\fR method, it will read
parameters from the file (or \s-1STDIN\s0, or whatever).  The file can be in
any of the forms describing below under debugging (i.e. a series of
newline delimited \s-1TAG\s0=\s-1VALUE\s0 pairs will work).  Conveniently, this type
of file is created by the \fIsave()\fR method (see below).  Multiple records
can be saved and restored.
.PP
Perl purists will be pleased to know that this syntax accepts
references to file handles, or even references to filehandle globs,
which is the \*(L"official\*(R" way to pass a filehandle:
.PP
.Vb 1
\&    $query = new CGI(\e*STDIN);
.Ve
You can also initialize the \s-1CGI\s0 object with a FileHandle or \s-1IO::\s0File
object.
.PP
If you are using the function-oriented interface and want to
initialize \s-1CGI\s0 state from a file handle, the way to do this is with
\fBrestore_parameters()\fR.  This will (re)initialize the
default \s-1CGI\s0 object from the indicated file handle.
.PP
.Vb 3
\&    open (IN,"test.in") || die;
\&    restore_parameters(IN);
\&    close IN;
.Ve
You can also initialize the query object from an associative array
reference:
.PP
.Vb 4
\&    $query = new CGI( {'dinosaur'=>'barney',
\&                       'song'=>'I love you',
\&                       'friends'=>[qw/Jessica George Nancy/]}
\&                    );
.Ve
or from a properly formatted, \s-1URL\s0\-escaped query string:
.PP
.Vb 1
\&    $query = new CGI('dinosaur=barney&color=purple');
.Ve
or from a previously existing \s-1CGI\s0 object (currently this clones the
parameter list, but none of the other object-specific fields, such as
autoescaping):
.PP
.Vb 2
\&    $old_query = new CGI;
\&    $new_query = new CGI($old_query);
.Ve
To create an empty query, initialize it from an empty string or hash:
.PP
.Vb 1
\&   $empty_query = new CGI("");
.Ve
.Vb 1
\&       -or-
.Ve
.Vb 1
\&   $empty_query = new CGI({});
.Ve
.Sh "\s-1FETCHING\s0 A \s-1LIST\s0 \s-1OF\s0 \s-1KEYWORDS\s0 \s-1FROM\s0 \s-1THE\s0 \s-1QUERY\s0:"
.PP
.Vb 1
\&     @keywords = $query->keywords
.Ve
If the script was invoked as the result of an <\s-1ISINDEX\s0> search, the
parsed keywords can be obtained as an array using the \fIkeywords()\fR method.
.Sh "\s-1FETCHING\s0 \s-1THE\s0 \s-1NAMES\s0 \s-1OF\s0 \s-1ALL\s0 \s-1THE\s0 \s-1PARAMETERS\s0 \s-1PASSED\s0 \s-1TO\s0 \s-1YOUR\s0 \s-1SCRIPT\s0:"
.PP
.Vb 1
\&     @names = $query->param
.Ve
If the script was invoked with a parameter list
(e.g. \*(L"name1=value1&name2=value2&name3=value3"), the \fIparam()\fR
method will return the parameter names as a list.  If the
script was invoked as an <\s-1ISINDEX\s0> script, there will be a
single parameter named \*(L'keywords\*(R'.
.PP
\s-1NOTE\s0: As of version 1.5, the array of parameter names returned will
be in the same order as they were submitted by the browser.
Usually this order is the same as the order in which the 
parameters are defined in the form (however, this isn't part
of the spec, and so isn't guaranteed).
.Sh "\s-1FETCHING\s0 \s-1THE\s0 \s-1VALUE\s0 \s-1OR\s0 \s-1VALUES\s0 \s-1OF\s0 A \s-1SINGLE\s0 \s-1NAMED\s0 \s-1PARAMETER\s0:"
.PP
.Vb 1
\&    @values = $query->param('foo');
.Ve
.Vb 1
\&              -or-
.Ve
.Vb 1
\&    $value = $query->param('foo');
.Ve
Pass the \fIparam()\fR method a single argument to fetch the value of the
named parameter. If the parameter is multivalued (e.g. from multiple
selections in a scrolling list), you can ask to receive an array.  Otherwise
the method will return a single value.
.Sh "\s-1SETTING\s0 \s-1THE\s0 \fI\s-1VALUE\s0\fR\|(S) \s-1OF\s0 A \s-1NAMED\s0 \s-1PARAMETER\s0:"
.PP
.Vb 1
\&    $query->param('foo','an','array','of','values');
.Ve
This sets the value for the named parameter \*(L'foo\*(R' to an array of
values.  This is one way to change the value of a field \s-1AFTER\s0
the script has been invoked once before.  (Another way is with
the \-override parameter accepted by all methods that generate
form elements.)
.PP
\fIparam()\fR also recognizes a named parameter style of calling described
in more detail later:
.PP
.Vb 1
\&    $query->param(-name=>'foo',-values=>['an','array','of','values']);
.Ve
.Vb 1
\&                              -or-
.Ve
.Vb 1
\&    $query->param(-name=>'foo',-value=>'the value');
.Ve
.Sh "\s-1APPENDING\s0 \s-1ADDITIONAL\s0 \s-1VALUES\s0 \s-1TO\s0 A \s-1NAMED\s0 \s-1PARAMETER\s0:"
.PP
.Vb 1
\&   $query->append(-name=>'foo',-values=>['yet','more','values']);
.Ve
This adds a value or list of values to the named parameter.  The
values are appended to the end of the parameter if it already exists.
Otherwise the parameter is created.  Note that this method only
recognizes the named argument calling syntax.
.Sh "\s-1IMPORTING\s0 \s-1ALL\s0 \s-1PARAMETERS\s0 \s-1INTO\s0 A \s-1NAMESPACE\s0:"
.PP
.Vb 1
\&   $query->import_names('R');
.Ve
This creates a series of variables in the \*(L'R\*(R' namespace.  For example,
\f(CW$R::foo\fR, \f(CW@R:foo\fR.  For keyword lists, a variable \f(CW@R::keywords\fR will appear.
If no namespace is given, this method will assume \*(L'Q\*(R'.
\s-1WARNING\s0:  don't import anything into \*(L'main\*(R'; this is a major security
risk!!!!
.PP
In older versions, this method was called \fBimport()\fR.  As of version 2.20, 
this name has been removed completely to avoid conflict with the built-in
Perl module \fBimport\fR operator.
.Sh "\s-1DELETING\s0 A \s-1PARAMETER\s0 \s-1COMPLETELY\s0:"
.PP
.Vb 1
\&    $query->delete('foo');
.Ve
This completely clears a parameter.  It sometimes useful for
resetting parameters that you don't want passed down between
script invocations.
.PP
If you are using the function call interface, use \*(L"\fIDelete()\fR\*(R" instead
to avoid conflicts with Perl's built-in delete operator.
.Sh "\s-1DELETING\s0 \s-1ALL\s0 \s-1PARAMETERS\s0:"
.PP
.Vb 1
\&   $query->delete_all();
.Ve
This clears the \s-1CGI\s0 object completely.  It might be useful to ensure
that all the defaults are taken when you create a fill-out form.
.PP
Use \fIDelete_all()\fR instead if you are using the function call interface.
.Sh "\s-1DIRECT\s0 \s-1ACCESS\s0 \s-1TO\s0 \s-1THE\s0 \s-1PARAMETER\s0 \s-1LIST\s0:"
.PP
.Vb 2
\&   $q->param_fetch('address')->[1] = '1313 Mockingbird Lane';
\&   unshift @{$q->param_fetch(-name=>'address')},'George Munster';
.Ve
If you need access to the parameter list in a way that isn't covered
by the methods above, you can obtain a direct reference to it by
calling the \fBparam_fetch()\fR method with the name of the .  This
will return an array reference to the named parameters, which you then
can manipulate in any way you like.
.PP
You can also use a named argument style using the \fB\-name\fR argument.
.Sh "\s-1SAVING\s0 \s-1THE\s0 \s-1STATE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SCRIPT\s0 \s-1TO\s0 A \s-1FILE\s0:"
.PP
.Vb 1
\&    $query->save(FILEHANDLE)
.Ve
This will write the current state of the form to the provided
filehandle.  You can read it back in by providing a filehandle
to the \fInew()\fR method.  Note that the filehandle can be a file, a pipe,
or whatever!
.PP
The format of the saved file is:
.PP
.Vb 5
\&        NAME1=VALUE1
\&        NAME1=VALUE1'
\&        NAME2=VALUE2
\&        NAME3=VALUE3
\&        =
.Ve
Both name and value are \s-1URL\s0 escaped.  Multi-valued \s-1CGI\s0 parameters are
represented as repeated names.  A session record is delimited by a
single = symbol.  You can write out multiple records and read them
back in with several calls to \fBnew\fR.  You can do this across several
sessions by opening the file in append mode, allowing you to create
primitive guest books, or to keep a history of users\*(R' queries.  Here's
a short example of creating multiple session records:
.PP
.Vb 1
\&   use CGI;
.Ve
.Vb 8
\&   open (OUT,">>test.out") || die;
\&   $records = 5;
\&   foreach (0..$records) {
\&       my $q = new CGI;
\&       $q->param(-name=>'counter',-value=>$_);
\&       $q->save(OUT);
\&   }
\&   close OUT;
.Ve
.Vb 6
\&   # reopen for reading
\&   open (IN,"test.out") || die;
\&   while (!eof(IN)) {
\&       my $q = new CGI(IN);
\&       print $q->param('counter'),"\en";
\&   }
.Ve
The file format used for save/restore is identical to that used by the
Whitehead Genome Center's data exchange format \*(L"Boulderio\*(R", and can be
manipulated and even databased using Boulderio utilities.  See
	
  http://www.genome.wi.mit.edu/genome_software/other/boulder.html
.PP
for further details.
.PP
If you wish to use this method from the function-oriented (non-\s-1OO\s0)
interface, the exported name for this method is \fBsave_parameters()\fR.
.Sh "\s-1USING\s0 \s-1THE\s0 \s-1FUNCTION\s0\-\s-1ORIENTED\s0 \s-1INTERFACE\s0"
To use the function-oriented interface, you must specify which \s-1CGI\s0.pm
routines or sets of routines to import into your script's namespace.
There is a small overhead associated with this importation, but it
isn't much.
.PP
.Vb 1
\&   use CGI <list of methods>;
.Ve
The listed methods will be imported into the current package; you can
call them directly without creating a \s-1CGI\s0 object first.  This example
shows how to import the \fBparam()\fR and \fBheader()\fR
methods, and then use them directly:
.PP
.Vb 3
\&   use CGI 'param','header';
\&   print header('text/plain');
\&   $zipcode = param('zipcode');
.Ve
More frequently, you'll import common sets of functions by referring
to the gropus by name.  All function sets are preceded with a \*(L":\*(R"
character as in \*(L":html3\*(R" (for tags defined in the \s-1HTML\s0 3 standard).
.PP
Here is a list of the function sets you can import:
.Ip "\fB:cgi\fR" 4
Import all \s-1CGI\s0\-handling methods, such as \fBparam()\fR, \fBpath_info()\fR
and the like.
.Ip "\fB:form\fR" 4
Import all fill-out form generating methods, such as \fBtextfield()\fR.
.Ip "\fB:html2\fR" 4
Import all methods that generate \s-1HTML\s0 2.0 standard elements.
.Ip "\fB:html3\fR" 4
Import all methods that generate \s-1HTML\s0 3.0 proposed elements (such as
<table>, <super> and <sub>).
.Ip "\fB:netscape\fR" 4
Import all methods that generate Netscape-specific \s-1HTML\s0 extensions.
.Ip "\fB:html\fR" 4
Import all \s-1HTML\s0\-generating shortcuts (i.e. \*(L'html2\*(R' + \*(L'html3\*(R' +
\&'netscape')...
.Ip "\fB:standard\fR" 4
Import \*(L"standard\*(R" features, \*(L'html2\*(R', \*(L'html3\*(R', \*(L'form\*(R' and \*(L'cgi\*(R'.
.Ip "\fB:all\fR" 4
Import all the available methods.  For the full list, see the \s-1CGI\s0.pm
code, where the variable \f(CW%TAGS\fR is defined.
.PP
If you import a function name that is not part of \s-1CGI\s0.pm, the module
will treat it as a new \s-1HTML\s0 tag and generate the appropriate
subroutine.  You can then use it like any other \s-1HTML\s0 tag.  This is to
provide for the rapidly-evolving \s-1HTML\s0 \*(L"standard.\*(R"  For example, say
Microsoft comes out with a new tag called <\s-1GRADIENT\s0> (which causes the
user's desktop to be flooded with a rotating gradient fill until his
machine reboots).  You don't need to wait for a new version of \s-1CGI\s0.pm
to start using it immeidately:
.PP
.Vb 2
\&   use CGI qw/:standard :html3 gradient/;
\&   print gradient({-start=>'red',-end=>'blue'});
.Ve
Note that in the interests of execution speed \s-1CGI\s0.pm does \fBnot\fR use
the standard the \fIExporter\fR manpage syntax for specifying load symbols.  This may
change in the future.
.PP
If you import any of the state-maintaining \s-1CGI\s0 or form-generating
methods, a default \s-1CGI\s0 object will be created and initialized
automatically the first time you use any of the methods that require
one to be present.  This includes \fBparam()\fR, \fBtextfield()\fR,
\fBsubmit()\fR and the like.  (If you need direct access to the \s-1CGI\s0
object, you can find it in the global variable \fB$\s-1CGI::Q\s0\fR).  By
importing \s-1CGI\s0.pm methods, you can create visually elegant scripts:
.PP
.Vb 17
\&   use CGI qw/:standard/;
\&   print 
\&       header,
\&       start_html('Simple Script'),
\&       h1('Simple Script'),
\&       start_form,
\&       "What's your name? ",textfield('name'),p,
\&       "What's the combination?",
\&       checkbox_group(-name=>'words',
\&                      -values=>['eenie','meenie','minie','moe'],
\&                      -defaults=>['eenie','moe']),p,
\&       "What's your favorite color?",
\&       popup_menu(-name=>'color',
\&                  -values=>['red','green','blue','chartreuse']),p,
\&       submit,
\&       end_form,
\&       hr,"\en";
.Ve
.Vb 7
\&    if (param) {
\&       print 
\&           "Your name is ",em(param('name')),p,
\&           "The keywords are: ",em(join(", ",param('words'))),p,
\&           "Your favorite color is ",em(param('color')),".\en";
\&    }
\&    print end_html;
.Ve
.Sh "\s-1PRAGMAS\s0"
In addition to the function sets, there are a number of pragmas that
you can import.  Pragmas, which are always preceded by a hyphen,
change the way that \s-1CGI\s0.pm functions in various ways.  Pragmas,
function sets, and individual functions can all be imported in the
same \fIuse()\fR line.  For example, the following use statement imports the
standard set of functions and disables debugging mode (pragma
\-no_debug):
.PP
.Vb 1
\&   use CGI qw/:standard -no_debug/;
.Ve
The current list of pragmas is as follows:
.Ip "-any" 4
When you \fIuse \s-1CGI\s0 \-any\fR, then any method that the query object
doesn't recognize will be interpreted as a new \s-1HTML\s0 tag.  This allows
you to support the next \fIad hoc\fR Netscape or Microsoft \s-1HTML\s0
extension.  This lets you go wild with new and unsupported tags:
.Sp
.Vb 3
\&   use CGI qw(-any);
\&   $q=new CGI;
\&   print $q->gradient({speed=>'fast',start=>'red',end=>'blue'});
.Ve
Since using <cite>any</cite> causes any mistyped method name
to be interpreted as an \s-1HTML\s0 tag, use it with care or not at
all.
.Ip "-compile" 4
This causes the indicated autoloaded methods to be compiled up front,
rather than deferred to later.  This is useful for scripts that run
for an extended period of time under FastCGI or mod_perl, and for
those destined to be crunched by Malcom Beattie's Perl compiler.  Use
it in conjunction with the methods or method familes you plan to use.
.Sp
.Vb 1
\&   use CGI qw(-compile :standard :html3);
.Ve
or even
.Sp
.Vb 1
\&   use CGI qw(-compile :all);
.Ve
Note that using the \-compile pragma in this way will always have
the effect of importing the compiled functions into the current
namespace.  If you want to compile without importing use the
\fIcompile()\fR method instead (see below).
.Ip "-nph" 4
This makes \s-1CGI\s0.pm produce a header appropriate for an \s-1NPH\s0 (no
parsed header) script.  You may need to do other things as well
to tell the server that the script is \s-1NPH\s0.  See the discussion
of \s-1NPH\s0 scripts below.
.Ip "-autoload" 4
This overrides the autoloader so that any function in your program
that is not recognized is referred to \s-1CGI\s0.pm for possible evaluation.
This allows you to use all the \s-1CGI\s0.pm functions without adding them to
your symbol table, which is of concern for mod_perl users who are
worried about memory consumption.  \fIWarning:\fR when
\fI\-autoload\fR is in effect, you cannot use \*(L"poetry mode\*(R"
(functions without the parenthesis).  Use \fIhr()\fR rather
than \fIhr\fR, or add something like \fIuse subs qw/hr p header/\fR 
to the top of your script.
.Ip "-no_debug" 4
This turns off the command-line processing features.  If you want to
run a \s-1CGI\s0.pm script from the command line to produce \s-1HTML\s0, and you
don't want it pausing to request \s-1CGI\s0 parameters from standard input or
the command line, then use this pragma:
.Sp
.Vb 1
\&   use CGI qw(-no_debug :standard);
.Ve
If you'd like to process the command-line parameters but not standard
input, this should work:
.Sp
.Vb 4
\&   use CGI qw(-no_debug :standard);
\&   restore_parameters(join('&',@ARGV));
\&  
\&See the section on debugging for more details.
.Ve
.Ip "-private_tempfiles" 4
\s-1CGI\s0.pm can process uploaded file. Ordinarily it spools the
uploaded file to a temporary directory, then deletes the file
when done.  However, this opens the risk of eavesdropping as
described in the file upload section.
Another \s-1CGI\s0 script author could peek at this data during the
upload, even if it is confidential information. On Unix systems,
the \-private_tempfiles pragma will cause the temporary file to be unlinked as soon
as it is opened and before any data is written into it,
eliminating the risk of eavesdropping.
n
=back
.SH "GENERATING DYNAMIC DOCUMENTS"
Most of CGI.pm's functions deal with creating documents on the fly.
Generally you will produce the HTTP header first, followed by the
document itself.  CGI.pm provides functions for generating HTTP
headers of various types as well as for generating HTML.  For creating
GIF images, see the GD.pm module.
.Sp
Each of these functions produces a fragment of HTML or HTTP which you
can print out directly so that it displays in the browser window,
append to a string, or save to a file for later use.
.Sh "\s-1CREATING\s0 A \s-1STANDARD\s0 \s-1HTTP\s0 \s-1HEADER\s0:"
Normally the first thing you will do in any \s-1CGI\s0 script is print out an
\s-1HTTP\s0 header.  This tells the browser what type of document to expect,
and gives other optional information, such as the language, expiration
date, and whether to cache the document.  The header can also be
manipulated for special purposes, such as server push and pay per view
pages.
.Sp
.Vb 1
\&        print $query->header;
.Ve
.Vb 1
\&             -or-
.Ve
.Vb 1
\&        print $query->header('image/gif');
.Ve
.Vb 1
\&             -or-
.Ve
.Vb 1
\&        print $query->header('text/html','204 No response');
.Ve
.Vb 1
\&             -or-
.Ve
.Vb 6
\&        print $query->header(-type=>'image/gif',
\&                             -nph=>1,
\&                             -status=>'402 Payment required',
\&                             -expires=>'+3d',
\&                             -cookie=>$cookie,
\&                             -Cost=>'$2.00');
.Ve
\fIheader()\fR returns the Content-type: header.  You can provide your own
\s-1MIME\s0 type if you choose, otherwise it defaults to text/html.  An
optional second parameter specifies the status code and a human-readable
message.  For example, you can specify 204, \*(L"No response\*(R" to create a
script that tells the browser to do nothing at all.
.Sp
The last example shows the named argument style for passing arguments
to the \s-1CGI\s0 methods using named parameters.  Recognized parameters are
\fB\-type\fR, \fB\-status\fR, \fB\-expires\fR, and \fB\-cookie\fR.  Any other named
parameters will be stripped of their initial hyphens and turned into
header fields, allowing you to specify any \s-1HTTP\s0 header you desire.
Internal underscores will be turned into hyphens:
.Sp
.Vb 1
\&    print $query->header(-Content_length=>3002);
.Ve
Most browsers will not cache the output from \s-1CGI\s0 scripts.  Every time
the browser reloads the page, the script is invoked anew.  You can
change this behavior with the \fB\-expires\fR parameter.  When you specify
an absolute or relative expiration interval with this parameter, some
browsers and proxy servers will cache the script's output until the
indicated expiration date.  The following forms are all valid for the
\-expires field:
.Sp
.Vb 8
\&        +30s                              30 seconds from now
\&        +10m                              ten minutes from now
\&        +1h                               one hour from now
\&        -1d                               yesterday (i.e. "ASAP!")
\&        now                               immediately
\&        +3M                               in three months
\&        +10y                              in ten years time
\&        Thursday, 25-Apr-1999 00:40:33 GMT  at the indicated time & date
.Ve
The \fB\-cookie\fR parameter generates a header that tells the browser to provide
a \*(L"magic cookie\*(R" during all subsequent transactions with your script.
Netscape cookies have a special format that includes interesting attributes
such as expiration time.  Use the \fIcookie()\fR method to create and retrieve
session cookies.
.Sp
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH\s0 (no-parse-header) script.  This is important
to use with certain servers, such as Microsoft Internet Explorer, which
expect all their scripts to be \s-1NPH\s0.
.Sh "\s-1GENERATING\s0 A \s-1REDIRECTION\s0 \s-1HEADER\s0"
.Sp
.Vb 1
\&   print $query->redirect('http://somewhere.else/in/movie/land');
.Ve
Sometimes you don't want to produce a document yourself, but simply
redirect the browser elsewhere, perhaps choosing a \s-1URL\s0 based on the
time of day or the identity of the user.  
.Sp
The \fIredirect()\fR function redirects the browser to a different \s-1URL\s0.  If
you use redirection like this, you should \fBnot\fR print out a header as
well.  As of version 2.0, we produce both the unofficial Location:
header and the official \s-1URI\s0: header.  This should satisfy most servers
and browsers.
.Sp
One hint I can offer is that relative links may not work correctly
when you generate a redirection to another document on your site.
This is due to a well-intentioned optimization that some servers use.
The solution to this is to use the full \s-1URL\s0 (including the http: part)
of the document you are redirecting to.
.Sp
You can also use named arguments:
.Sp
.Vb 2
\&    print $query->redirect(-uri=>'http://somewhere.else/in/movie/land',
\&                           -nph=>1);
.Ve
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH\s0 (no-parse-header) script.  This is important
to use with certain servers, such as Microsoft Internet Explorer, which
expect all their scripts to be \s-1NPH\s0.
.Sh "\s-1CREATING\s0 \s-1THE\s0 \s-1HTML\s0 \s-1DOCUMENT\s0 \s-1HEADER\s0"
.Sp
.Vb 8
\&   print $query->start_html(-title=>'Secrets of the Pyramids',
\&                            -author=>'fred@capricorn.org',
\&                            -base=>'true',
\&                            -target=>'_blank',
\&                            -meta=>{'keywords'=>'pharaoh secret mummy',
\&                                    'copyright'=>'copyright 1996 King Tut'},
\&                            -style=>{'src'=>'/styles/style1.css'},
\&                            -BGCOLOR=>'blue');
.Ve
After creating the \s-1HTTP\s0 header, most \s-1CGI\s0 scripts will start writing
out an \s-1HTML\s0 document.  The \fIstart_html()\fR routine creates the top of the
page, along with a lot of optional information that controls the
page's appearance and behavior.
.Sp
This method returns a canned \s-1HTML\s0 header and the opening <\s-1BODY\s0> tag.
All parameters are optional.  In the named parameter form, recognized
parameters are \-title, \-author, \-base, \-xbase and \-target (see below
for the explanation).  Any additional parameters you provide, such as
the Netscape unofficial \s-1BGCOLOR\s0 attribute, are added to the <\s-1BODY\s0>
tag.  Additional parameters must be proceeded by a hyphen.
.Sp
The argument \fB\-xbase\fR allows you to provide an \s-1HREF\s0 for the <\s-1BASE\s0> tag
different from the current location, as in
.Sp
.Vb 1
\&    -xbase=>"http://home.mcom.com/"
.Ve
All relative links will be interpreted relative to this tag.
.Sp
The argument \fB\-target\fR allows you to provide a default target frame
for all the links and fill-out forms on the page.  See the Netscape
documentation on frames for details of how to manipulate this.
.Sp
.Vb 1
\&    -target=>"answer_window"
.Ve
All relative links will be interpreted relative to this tag.
You add arbitrary meta information to the header with the \fB\-meta\fR
argument.  This argument expects a reference to an associative array
containing name/value pairs of meta information.  These will be turned
into a series of header <\s-1META\s0> tags that look something like this:
.Sp
.Vb 2
\&    <META NAME="keywords" CONTENT="pharaoh secret mummy">
\&    <META NAME="description" CONTENT="copyright 1996 King Tut">
.Ve
There is no support for the \s-1HTTP\s0\-\s-1EQUIV\s0 type of <\s-1META\s0> tag.  This is
because you can modify the \s-1HTTP\s0 header directly with the \fBheader()\fR
method.  For example, if you want to send the Refresh: header, do it
in the \fIheader()\fR method:
.Sp
.Vb 1
\&    print $q->header(-Refresh=>'10; URL=http://www.capricorn.com');
.Ve
The \fB\-style\fR tag is used to incorporate cascading stylesheets into
your code.  See the section on \s-1CASCADING\s0 \s-1STYLESHEETS\s0 for more information.
.Sp
You can place other arbitrary \s-1HTML\s0 elements to the <\s-1HEAD\s0> section with the
\fB\-head\fR tag.  For example, to place the rarely-used <\s-1LINK\s0> element in the
head section, use this:
.Sp
.Vb 2
\&    print $q->start_html(-head=>Link({-rel=>'next',
\&                                  -href=>'http://www.capricorn.com/s2.html'}));
.Ve
To incorporate multiple \s-1HTML\s0 elements into the <\s-1HEAD\s0> section, just pass an
array reference:
.Sp
.Vb 7
\&    print $q->start_html(-head=>[ 
\&                              Link({-rel=>'next',
\&                                    -href=>'http://www.capricorn.com/s2.html'}),
\&                              Link({-rel=>'previous',
\&                                    -href=>'http://www.capricorn.com/s1.html'})
\&                             ]
\&                     );
.Ve
\s-1JAVASCRIPTING\s0: The \fB\-script\fR, \fB\-noScript\fR, \fB\-onLoad\fR,
\fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onUnload\fR parameters are used
to add Netscape JavaScript calls to your pages.  \fB\-script\fR should
point to a block of text containing JavaScript function definitions.
This block will be placed within a <\s-1SCRIPT\s0> block inside the \s-1HTML\s0 (not
\s-1HTTP\s0) header.  The block is placed in the header in order to give your
page a fighting chance of having all its JavaScript functions in place
even if the user presses the stop button before the page has loaded
completely.  \s-1CGI\s0.pm attempts to format the script in such a way that
JavaScript-naive browsers will not choke on the code: unfortunately
there are some browsers, such as Chimera for Unix, that get confused
by it nevertheless.
.Sp
The \fB\-onLoad\fR and \fB\-onUnload\fR parameters point to fragments of JavaScript
code to execute when the page is respectively opened and closed by the
browser.  Usually these parameters are calls to functions defined in the
\fB\-script\fR field:
.Sp
.Vb 20
\&      $query = new CGI;
\&      print $query->header;
\&      $JSCRIPT=<<END;
\&      // Ask a silly question
\&      function riddle_me_this() {
\&         var r = prompt("What walks on four legs in the morning, " +
\&                       "two legs in the afternoon, " +
\&                       "and three legs in the evening?");
\&         response(r);
\&      }
\&      // Get a silly answer
\&      function response(answer) {
\&         if (answer == "man")
\&            alert("Right you are!");
\&         else
\&            alert("Wrong!  Guess again.");
\&      }
\&      END
\&      print $query->start_html(-title=>'The Riddle of the Sphinx',
\&                               -script=>$JSCRIPT);
.Ve
Use the \fB\-noScript\fR parameter to pass some \s-1HTML\s0 text that will be displayed on 
browsers that do not have JavaScript (or browsers where JavaScript is turned
off).
.Sp
Netscape 3.0 recognizes several attributes of the <\s-1SCRIPT\s0> tag,
including \s-1LANGUAGE\s0 and \s-1SRC\s0.  The latter is particularly interesting,
as it allows you to keep the JavaScript code in a file or \s-1CGI\s0 script
rather than cluttering up each page with the source.  To use these
attributes pass a \s-1HASH\s0 reference in the \fB\-script\fR parameter containing
one or more of \-language, \-src, or \-code:
.Sp
.Vb 4
\&    print $q->start_html(-title=>'The Riddle of the Sphinx',
\&                         -script=>{-language=>'JAVASCRIPT',
\&                                   -src=>'/javascript/sphinx.js'}
\&                         );
.Ve
.Vb 4
\&    print $q->(-title=>'The Riddle of the Sphinx',
\&               -script=>{-language=>'PERLSCRIPT'},
\&                         -code=>'print "hello world!\en;"'
\&               );
.Ve
A final feature allows you to incorporate multiple <\s-1SCRIPT\s0> sections into the
header.  Just pass the list of script sections as an array reference.
this allows you to specify different source files for different dialects
of JavaScript.  Example:     
.Sp
.Vb 17
\&     print $q-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
\&                          -script=&gt;[
\&                                    { -language =&gt; 'JavaScript1.0',
\&                                      -src      =&gt; '/javascript/utilities10.js'
\&                                    },
\&                                    { -language =&gt; 'JavaScript1.1',
\&                                      -src      =&gt; '/javascript/utilities11.js'
\&                                    },
\&                                    { -language =&gt; 'JavaScript1.2',
\&                                      -src      =&gt; '/javascript/utilities12.js'
\&                                    },
\&                                    { -language =&gt; 'JavaScript28.2',
\&                                      -src      =&gt; '/javascript/utilities219.js'
\&                                    }
\&                                 ]
\&                             );
\&     </pre>
.Ve
If this looks a bit extreme, take my advice and stick with straight \s-1CGI\s0 scripting.  
.Sp
See
.Sp
.Vb 1
\&   http://home.netscape.com/eng/mozilla/2.0/handbook/javascript/
.Ve
for more information about JavaScript.
.Sp
The old-style positional parameters are as follows:
.Ip "\fBParameters:\fR" 8
.Ip "1." 8
The title
.Ip "2." 8
The author's e-mail address (will create a <\s-1LINK\s0 \s-1REV\s0="\s-1MADE\s0"> tag if present
.Ip "3." 8
A \*(L'true\*(R' flag if you want to include a <\s-1BASE\s0> tag in the header.  This
helps resolve relative addresses to absolute ones when the document is moved, 
but makes the document hierarchy non-portable.  Use with care!
.Ip "4, 5, 6..." 8
Any other parameters you want to include in the <\s-1BODY\s0> tag.  This is a good
place to put Netscape extensions, such as colors and wallpaper patterns.
.Sh "\s-1ENDING\s0 \s-1THE\s0 \s-1HTML\s0 \s-1DOCUMENT\s0:"
.Sp
.Vb 1
\&        print $query->end_html
.Ve
This ends an \s-1HTML\s0 document by printing the </\s-1BODY\s0></\s-1HTML\s0> tags.
.Sh "\s-1CREATING\s0 A \s-1SELF\s0\-\s-1REFERENCING\s0 \s-1URL\s0 \s-1THAT\s0 \s-1PRESERVES\s0 \s-1STATE\s0 \s-1INFORMATION\s0:"
.Sp
.Vb 2
\&    $myself = $query->self_url;
\&    print "<A HREF=$myself>I'm talking to myself.</A>";
.Ve
\fIself_url()\fR will return a \s-1URL\s0, that, when selected, will reinvoke
this script with all its state information intact.  This is most
useful when you want to jump around within the document using
internal anchors but you don't want to disrupt the current contents
of the \fIform\fR\|(s).  Something like this will do the trick.
.Sp
.Vb 4
\&     $myself = $query->self_url;
\&     print "<A HREF=$myself#table1>See table 1</A>";
\&     print "<A HREF=$myself#table2>See table 2</A>";
\&     print "<A HREF=$myself#yourself>See for yourself</A>";
.Ve
If you want more control over what's returned, using the \fBurl()\fR
method instead.
.Sp
You can also retrieve the unprocessed query string with \fIquery_string()\fR:
.Sp
.Vb 1
\&    $the_string = $query->query_string;
.Ve
.Sh "\s-1OBTAINING\s0 \s-1THE\s0 \s-1SCRIPT\s0'S \s-1URL\s0"
.Sp
.Vb 6
\&    $full_url      = $query->url();
\&    $full_url      = $query->url(-full=>1);  #alternative syntax
\&    $relative_url  = $query->url(-relative=>1);
\&    $absolute_url  = $query->url(-absolute=>1);
\&    $url_with_path = $query->url(-path_info=>1);
\&    $url_with_path_and_query = $query->url(-path_info=>1,-query=>1);
.Ve
\fBurl()\fR returns the script's \s-1URL\s0 in a variety of formats.  Called
without any arguments, it returns the full form of the \s-1URL\s0, including
host name and port number
.Sp
.Vb 1
\&    http://your.host.com/path/to/script.cgi
.Ve
You can modify this format with the following named arguments:
.Ip "\fB\-absolute\fR" 8
If true, produce an absolute \s-1URL\s0, e.g.
.Sp
.Vb 1
\&    /path/to/script.cgi
.Ve
.Ip "\fB\-relative\fR" 8
Produce a relative \s-1URL\s0.  This is useful if you want to reinvoke your
script with different parameters. For example:
.Sp
.Vb 1
\&    script.cgi
.Ve
.Ip "\fB\-full\fR" 8
Produce the full \s-1URL\s0, exactly as if called without any arguments.
This overrides the \-relative and \-absolute arguments.
.Ip "\fB\-path\fR (\fB\-path_info\fR)" 8
Append the additional path information to the \s-1URL\s0.  This can be
combined with \fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-path_info\fR
is provided as a synonym.
.Ip "\fB\-query\fR (\fB\-query_string\fR)" 8
Append the query string to the \s-1URL\s0.  This can be combined with
\fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-query_string\fR is provided
as a synonym.
.SH "CREATING STANDARD HTML ELEMENTS:"
CGI.pm defines general HTML shortcut methods for most, if not all of
the HTML 3 and HTML 4 tags.  HTML shortcuts are named after a single
HTML element and return a fragment of HTML text that you can then
print or manipulate as you like.  Each shortcut returns a fragment of
HTML code that you can append to a string, save to a file, or, most
commonly, print out so that it displays in the browser window.
.Sp
This example shows how to use the HTML methods:
.Sp
.Vb 8
\&   $q = new CGI;
\&   print $q->blockquote(
\&                     "Many years ago on the island of",
\&                     $q->a({href=>"http://crete.org/"},"Crete"),
\&                     "there lived a minotaur named",
\&                     $q->strong("Fred."),
\&                    ),
\&       $q->hr;
.Ve
This results in the following HTML code (extra newlines have been
added for readability):
.Sp
.Vb 6
\&   <blockquote>
\&   Many years ago on the island of
\&   <a HREF="http://crete.org/">Crete</a> there lived
\&   a minotaur named <strong>Fred.</strong> 
\&   </blockquote>
\&   <hr>
.Ve
If you find the syntax for calling the HTML shortcuts awkward, you can
import them into your namespace and dispense with the object syntax
completely (see the next section for more details):
.Sp
.Vb 8
\&   use CGI ':standard';
\&   print blockquote(
\&      "Many years ago on the island of",
\&      a({href=>"http://crete.org/"},"Crete"),
\&      "there lived a minotaur named",
\&      strong("Fred."),
\&      ),
\&      hr;
.Ve
.Sh "\s-1PROVIDING\s0 \s-1ARGUMENTS\s0 \s-1TO\s0 \s-1HTML\s0 \s-1SHORTCUTS\s0"
The \s-1HTML\s0 methods will accept zero, one or multiple arguments.  If you
provide no arguments, you get a single tag:
.Sp
.Vb 1
\&   print hr;    #  <HR>
.Ve
If you provide one or more string arguments, they are concatenated
together with spaces and placed between opening and closing tags:
.Sp
.Vb 1
\&   print h1("Chapter","1"); # <H1>Chapter 1</H1>"
.Ve
If the first argument is an associative array reference, then the keys
and values of the associative array become the \s-1HTML\s0 tag's attributes:
.Sp
.Vb 2
\&   print a({-href=>'fred.html',-target=>'_new'},
\&      "Open a new frame");
.Ve
.Vb 4
\&            <A HREF="fred.html",TARGET="_new">Open a new frame</A>
\&   
\&You may dispense with the dashes in front of the attribute names if
\&you prefer:
.Ve
.Vb 1
\&   print img {src=>'fred.gif',align=>'LEFT'};
.Ve
.Vb 1
\&           <IMG ALIGN="LEFT" SRC="fred.gif">
.Ve
Sometimes an \s-1HTML\s0 tag attribute has no argument.  For example, ordered
lists can be marked as \s-1COMPACT\s0.  The syntax for this is an argument that
that points to an undef string:
.Sp
.Vb 1
\&   print ol({compact=>undef},li('one'),li('two'),li('three'));
.Ve
Prior to \s-1CGI\s0.pm version 2.41, providing an empty ('') string as an
attribute argument was the same as providing undef.  However, this has
changed in order to accomodate those who want to create tags of the form 
<\s-1IMG\s0 \s-1ALT\s0="">.  The difference is shown in these two pieces of code:
  
   \s-1CODE\s0                   \s-1RESULT\s0
   \fIimg\fR\|({alt=>undef})      <\s-1IMG\s0 \s-1ALT\s0>
   \fIimg\fR\|({alt=>''})         <\s-1IMT\s0 \s-1ALT\s0="">
.Sh "\s-1THE\s0 \s-1DISTRIBUTIVE\s0 \s-1PROPERTY\s0 \s-1OF\s0 \s-1HTML\s0 \s-1SHORTCUTS\s0"
One of the cool features of the \s-1HTML\s0 shortcuts is that they are
distributive.  If you give them an argument consisting of a
\fBreference\fR to a list, the tag will be distributed across each
element of the list.  For example, here's one way to make an ordered
list:
.Sp
.Vb 3
\&   print ul(
\&             li({-type=>'disc'},['Sneezy','Doc','Sleepy','Happy']);
\&           );
.Ve
This example will result in \s-1HTML\s0 output that looks like this:
.Sp
.Vb 6
\&   <UL>
\&     <LI TYPE="disc">Sneezy</LI>
\&     <LI TYPE="disc">Doc</LI>
\&     <LI TYPE="disc">Sleepy</LI>
\&     <LI TYPE="disc">Happy</LI>
\&   </UL>
.Ve
This is extremely useful for creating tables.  For example:
.Sp
.Vb 11
\&   print table({-border=>undef},
\&           caption('When Should You Eat Your Vegetables?'),
\&           Tr({-align=>CENTER,-valign=>TOP},
\&           [
\&              th(['Vegetable', 'Breakfast','Lunch','Dinner']),
\&              td(['Tomatoes' , 'no', 'yes', 'yes']),
\&              td(['Broccoli' , 'no', 'no',  'yes']),
\&              td(['Onions'   , 'yes','yes', 'yes'])
\&           ]
\&           )
\&        );
.Ve
.Sh "\s-1HTML\s0 \s-1SHORTCUTS\s0 \s-1AND\s0 \s-1LIST\s0 \s-1INTERPOLATION\s0"
Consider this bit of code:
.Sp
.Vb 1
\&   print blockquote(em('Hi'),'mom!'));
.Ve
It will ordinarily return the string that you probably expect, namely:
.Sp
.Vb 1
\&   <BLOCKQUOTE><EM>Hi</EM> mom!</BLOCKQUOTE>
.Ve
Note the space between the element \*(L"Hi\*(R" and the element \*(L"mom!\*(R".
\s-1CGI\s0.pm puts the extra space there using array interpolation, which is
controlled by the magic $\*(R" variable.  Sometimes this extra space is
not what you want, for example, when you are trying to align a series
of images.  In this case, you can simply change the value of $\*(R" to an
empty string.
.Sp
.Vb 4
\&   {
\&      local($") = '';
\&      print blockquote(em('Hi'),'mom!'));
\&    }
.Ve
I suggest you put the code in a block as shown here.  Otherwise the
change to $\*(R" will affect all subsequent code until you explicitly
reset it.
.Sh "\s-1NON\s0\-\s-1STANDARD\s0 \s-1HTML\s0 \s-1SHORTCUTS\s0"
A few \s-1HTML\s0 tags don't follow the standard pattern for various
reasons.  
.Sp
\fBcomment()\fR generates an \s-1HTML\s0 comment (<!-- comment -->).  Call it
like
.Sp
.Vb 1
\&    print comment('here is my comment');
.Ve
Because of conflicts with built-in Perl functions, the following functions
begin with initial caps:
.Sp
.Vb 4
\&    Select
\&    Tr
\&    Link
\&    Delete
.Ve
In addition, \fIstart_html()\fR, \fIend_html()\fR, \fIstart_form()\fR, \fIend_form()\fR,
\fIstart_multipart_form()\fR and all the fill-out form tags are special.
See their respective sections.
.SH "CREATING FILL\-OUT FORMS:"
\fIGeneral note\fR  The various form-creating methods all return strings
to the caller, containing the tag or tags that will create the requested
form element.  You are responsible for actually printing out these strings.
It's set up this way so that you can place formatting tags
around the form elements.
.Sp
\fIAnother note\fR The default values that you specify for the forms are only
used the \fBfirst\fR time the script is invoked (when there is no query
string).  On subsequent invocations of the script (when there is a query
string), the former values are used even if they are blank.  
.Sp
If you want to change the value of a field from its previous value, you have two
choices:
.Sp
(1) call the \fIparam()\fR method to set it.
.Sp
(2) use the \-override (alias \-force) parameter (a new feature in version 2.15).
This forces the default value to be used, regardless of the previous value:
.Sp
.Vb 5
\&   print $query->textfield(-name=>'field_name',
\&                           -default=>'starting value',
\&                           -override=>1,
\&                           -size=>50,
\&                           -maxlength=>80);
.Ve
\fIYet another note\fR By default, the text and labels of form elements are
escaped according to HTML rules.  This means that you can safely use
\*(L"<CLICK ME>\*(R" as the label for a button.  However, it also interferes with
your ability to incorporate special HTML character sequences, such as &Aacute;,
into your fields.  If you wish to turn off automatic escaping, call the
\fIautoEscape()\fR method with a false value immediately after creating the CGI object:
.Sp
.Vb 3
\&   $query = new CGI;
\&   $query->autoEscape(undef);
\&                             
.Ve
.Sh "\s-1CREATING\s0 \s-1AN\s0 \s-1ISINDEX\s0 \s-1TAG\s0"
.Sp
.Vb 1
\&   print $query->isindex(-action=>$action);
.Ve
.Vb 1
\&         -or-
.Ve
.Vb 1
\&   print $query->isindex($action);
.Ve
Prints out an <\s-1ISINDEX\s0> tag.  Not very exciting.  The parameter
\-action specifies the \s-1URL\s0 of the script to process the query.  The
default is to process the query with the current script.
.Sh "\s-1STARTING\s0 \s-1AND\s0 \s-1ENDING\s0 A \s-1FORM\s0"
.Sp
.Vb 5
\&    print $query->startform(-method=>$method,
\&                            -action=>$action,
\&                            -encoding=>$encoding);
\&      <... various form stuff ...>
\&    print $query->endform;
.Ve
.Vb 1
\&        -or-
.Ve
.Vb 3
\&    print $query->startform($method,$action,$encoding);
\&      <... various form stuff ...>
\&    print $query->endform;
.Ve
\fIstartform()\fR will return a <\s-1FORM\s0> tag with the optional method,
action and form encoding that you specify.  The defaults are:
	
    method: \s-1POST\s0
    action: this script
    encoding: application/x-www-form-urlencoded
.Sp
\fIendform()\fR returns the closing </\s-1FORM\s0> tag.  
.Sp
\fIStartform()\fR's encoding method tells the browser how to package the various
fields of the form before sending the form to the server.  Two
values are possible:
.Ip "\fBapplication/x-www-form-urlencoded\fR" 8
This is the older type of encoding used by all browsers prior to
Netscape 2.0.  It is compatible with many \s-1CGI\s0 scripts and is
suitable for short fields containing text data.  For your
convenience, \s-1CGI\s0.pm stores the name of this encoding
type in \fB$\s-1CGI::URL_ENCODED\s0\fR.
.Ip "\fBmultipart/form-data\fR" 8
This is the newer type of encoding introduced by Netscape 2.0.
It is suitable for forms that contain very large fields or that
are intended for transferring binary data.  Most importantly,
it enables the \*(L"file upload\*(R" feature of Netscape 2.0 forms.  For
your convenience, \s-1CGI\s0.pm stores the name of this encoding type
in \fB&\s-1CGI::MULTIPART\s0\fR
.Sp
Forms that use this type of encoding are not easily interpreted
by \s-1CGI\s0 scripts unless they use \s-1CGI\s0.pm or another library designed
to handle them.
.Sp
For compatibility, the \fIstartform()\fR method uses the older form of
encoding by default.  If you want to use the newer form of encoding
by default, you can call \fBstart_multipart_form()\fR instead of
\fBstartform()\fR.
.Sp
\s-1JAVASCRIPTING\s0: The \fB\-name\fR and \fB\-onSubmit\fR parameters are provided
for use with JavaScript.  The \-name parameter gives the
form a name so that it can be identified and manipulated by
JavaScript functions.  \-onSubmit should point to a JavaScript
function that will be executed just before the form is submitted to your
server.  You can use this opportunity to check the contents of the form 
for consistency and completeness.  If you find something wrong, you
can put up an alert box or maybe fix things up yourself.  You can 
abort the submission by returning false from this function.  
.Sp
Usually the bulk of JavaScript functions are defined in a <\s-1SCRIPT\s0>
block in the \s-1HTML\s0 header and \-onSubmit points to one of these function
call.  See \fIstart_html()\fR for details.
.Sh "\s-1CREATING\s0 A \s-1TEXT\s0 \s-1FIELD\s0"
.Sp
.Vb 5
\&    print $query->textfield(-name=>'field_name',
\&                            -default=>'starting value',
\&                            -size=>50,
\&                            -maxlength=>80);
\&        -or-
.Ve
.Vb 1
\&    print $query->textfield('field_name','starting value',50,80);
.Ve
\fItextfield()\fR will return a text input field.  
.Ip "\fBParameters\fR" 8
.Ip "1." 8
The first parameter is the required name for the field (\-name).  
.Ip "2." 8
The optional second parameter is the default starting value for the field
contents (\-default).  
.Ip "3." 8
The optional third parameter is the size of the field in
      characters (\-size).
.Ip "4." 8
The optional fourth parameter is the maximum number of characters the
      field will accept (\-maxlength).
.Sp
As with all these methods, the field will be initialized with its 
previous contents from earlier invocations of the script.
When the form is processed, the value of the text field can be
retrieved with:
.Sp
.Vb 1
\&       $value = $query->param('foo');
.Ve
If you want to reset it from its initial value after the script has been
called once, you can do so like this:
.Sp
.Vb 1
\&       $query->param('foo',"I'm taking over this value!");
.Ve
\s-1NEW\s0 \s-1AS\s0 \s-1OF\s0 \s-1VERSION\s0 2.15: If you don't want the field to take on its previous
value, you can force its current value by using the \-override (alias \-force)
parameter:
.Sp
.Vb 5
\&    print $query->textfield(-name=>'field_name',
\&                            -default=>'starting value',
\&                            -override=>1,
\&                            -size=>50,
\&                            -maxlength=>80);
.Ve
\s-1JAVASCRIPTING\s0: You can also provide \fB\-onChange\fR, \fB\-onFocus\fR,
\fB\-onBlur\fR, \fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onSelect\fR
parameters to register JavaScript event handlers.  The onChange
handler will be called whenever the user changes the contents of the
text field.  You can do text validation if you like.  onFocus and
onBlur are called respectively when the insertion point moves into and
out of the text field.  onSelect is called when the user changes the
portion of the text that is selected.
.Sh "\s-1CREATING\s0 A \s-1BIG\s0 \s-1TEXT\s0 \s-1FIELD\s0"
.Sp
.Vb 4
\&   print $query->textarea(-name=>'foo',
\&                          -default=>'starting value',
\&                          -rows=>10,
\&                          -columns=>50);
.Ve
.Vb 1
\&        -or
.Ve
.Vb 1
\&   print $query->textarea('foo','starting value',10,50);
.Ve
\fItextarea()\fR is just like textfield, but it allows you to specify
rows and columns for a multiline text entry box.  You can provide
a starting value for the field, which can be long and contain
multiple lines.
.Sp
\s-1JAVASCRIPTING\s0: The \fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onBlur\fR ,
\fB\-onMouseOver\fR, \fB\-onMouseOut\fR, and \fB\-onSelect\fR parameters are
recognized.  See \fItextfield()\fR.
.Sh "\s-1CREATING\s0 A \s-1PASSWORD\s0 \s-1FIELD\s0"
.Sp
.Vb 5
\&   print $query->password_field(-name=>'secret',
\&                                -value=>'starting value',
\&                                -size=>50,
\&                                -maxlength=>80);
\&        -or-
.Ve
.Vb 1
\&   print $query->password_field('secret','starting value',50,80);
.Ve
\fIpassword_field()\fR is identical to \fItextfield()\fR, except that its contents 
will be starred out on the web page.
.Sp
\s-1JAVASCRIPTING\s0: The \fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onBlur\fR,
\fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onSelect\fR parameters are
recognized.  See \fItextfield()\fR.
.Sh "\s-1CREATING\s0 A \s-1FILE\s0 \s-1UPLOAD\s0 \s-1FIELD\s0"
.Sp
.Vb 5
\&    print $query->filefield(-name=>'uploaded_file',
\&                            -default=>'starting value',
\&                            -size=>50,
\&                            -maxlength=>80);
\&        -or-
.Ve
.Vb 1
\&    print $query->filefield('uploaded_file','starting value',50,80);
.Ve
\fIfilefield()\fR will return a file upload field for Netscape 2.0 browsers.
In order to take full advantage of this \fIyou must use the new 
multipart encoding scheme\fR for the form.  You can do this either
by calling \fBstartform()\fR with an encoding type of \fB$\s-1CGI::MULTIPART\s0\fR,
or by calling the new method \fBstart_multipart_form()\fR instead of
vanilla \fBstartform()\fR.
.Ip "\fBParameters\fR" 8
.Ip "1." 8
The first parameter is the required name for the field (\-name).  
.Ip "2." 8
The optional second parameter is the starting value for the field contents
to be used as the default file name (\-default).
.Sp
The beta2 version of Netscape 2.0 currently doesn't pay any attention
to this field, and so the starting value will always be blank.  Worse,
the field loses its \*(L"sticky\*(R" behavior and forgets its previous
contents.  The starting value field is called for in the \s-1HTML\s0
specification, however, and possibly later versions of Netscape will
honor it.
.Ip "3." 8
The optional third parameter is the size of the field in
characters (\-size).
.Ip "4." 8
The optional fourth parameter is the maximum number of characters the
field will accept (\-maxlength).
.Sp
When the form is processed, you can retrieve the entered filename
by calling \fIparam()\fR.
.Sp
.Vb 1
\&       $filename = $query->param('uploaded_file');
.Ve
In Netscape Navigator 2.0, the filename that gets returned is the full
local filename on the \fBremote user's\fR machine.  If the remote user is
on a Unix machine, the filename will follow Unix conventions:
.Sp
.Vb 1
\&        /path/to/the/file
.Ve
On an \s-1MS\s0\-\s-1DOS/\s0Windows and \s-1OS/2\s0 machines, the filename will follow \s-1DOS\s0 conventions:
.Sp
.Vb 1
\&        C:\ePATH\eTO\eTHE\eFILE.MSW
.Ve
On a Macintosh machine, the filename will follow Mac conventions:
.Sp
.Vb 1
\&        HD 40:Desktop Folder:Sort Through:Reminders
.Ve
The filename returned is also a file handle.  You can read the contents
of the file using standard Perl file reading calls:
.Sp
.Vb 4
\&        # Read a text file and print it out
\&        while (<$filename>) {
\&           print;
\&        }
.Ve
.Vb 5
\&        # Copy a binary file to somewhere safe
\&        open (OUTFILE,">>/usr/local/web/users/feedback");
\&        while ($bytesread=read($filename,$buffer,1024)) {
\&           print OUTFILE $buffer;
\&        }
.Ve
When a file is uploaded the browser usually sends along some
information along with it in the format of headers.  The information
usually includes the \s-1MIME\s0 content type.  Future browsers may send
other information as well (such as modification date and size). To
retrieve this information, call \fIuploadInfo()\fR.  It returns a reference to
an associative array containing all the document headers.
.Sp
.Vb 5
\&       $filename = $query->param('uploaded_file');
\&       $type = $query->uploadInfo($filename)->{'Content-Type'};
\&       unless ($type eq 'text/html') {
\&          die "HTML FILES ONLY!";
\&       }
.Ve
If you are using a machine that recognizes \*(L"text\*(R" and \*(L"binary\*(R" data
modes, be sure to understand when and how to use them (see the Camel book).  
Otherwise you may find that binary files are corrupted during file uploads.
.Sp
\s-1JAVASCRIPTING\s0: The \fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onBlur\fR,
\fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onSelect\fR parameters are
recognized.  See \fItextfield()\fR for details.
.Sh "\s-1CREATING\s0 A \s-1POPUP\s0 \s-1MENU\s0"
.Sp
.Vb 3
\&   print $query->popup_menu('menu_name',
\&                            ['eenie','meenie','minie'],
\&                            'meenie');
.Ve
.Vb 1
\&      -or-
.Ve
.Vb 6
\&   %labels = ('eenie'=>'your first choice',
\&              'meenie'=>'your second choice',
\&              'minie'=>'your third choice');
\&   print $query->popup_menu('menu_name',
\&                            ['eenie','meenie','minie'],
\&                            'meenie',\e%labels);
.Ve
.Vb 1
\&        -or (named parameter style)-
.Ve
.Vb 4
\&   print $query->popup_menu(-name=>'menu_name',
\&                            -values=>['eenie','meenie','minie'],
\&                            -default=>'meenie',
\&                            -labels=>\e%labels);
.Ve
\fIpopup_menu()\fR creates a menu.
.Ip "1." 8
The required first argument is the menu's name (\-name).
.Ip "2." 8
The required second argument (\-values) is an array \fBreference\fR
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference to
a named array, such as \*(L"\e@foo\*(R".
.Ip "3." 8
The optional third parameter (\-default) is the name of the default
menu choice.  If not specified, the first item will be the default.
The values of the previous choice will be maintained across queries.
.Ip "4." 8
The optional fourth parameter (\-labels) is provided for people who
want to use different values for the user-visible label inside the
popup menu nd the value returned to your script.  It's a pointer to an
associative array relating menu values to user-visible labels.  If you
leave this parameter blank, the menu values will be displayed by
default.  (You can also leave a label undefined if you want to).
.Sp
When the form is processed, the selected value of the popup menu can
be retrieved using:
.Sp
.Vb 1
\&      $popup_menu_value = $query->param('menu_name');
.Ve
\s-1JAVASCRIPTING\s0: \fIpopup_menu()\fR recognizes the following event handlers:
\fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onMouseOver\fR, \fB\-onMouseOut\fR, and
\fB\-onBlur\fR.  See the \fItextfield()\fR section for details on when these
handlers are called.
.Sh "\s-1CREATING\s0 A \s-1SCROLLING\s0 \s-1LIST\s0"
.Sp
.Vb 4
\&   print $query->scrolling_list('list_name',
\&                                ['eenie','meenie','minie','moe'],
\&                                ['eenie','moe'],5,'true');
\&      -or-
.Ve
.Vb 4
\&   print $query->scrolling_list('list_name',
\&                                ['eenie','meenie','minie','moe'],
\&                                ['eenie','moe'],5,'true',
\&                                \e%labels);
.Ve
.Vb 1
\&        -or-
.Ve
.Vb 6
\&   print $query->scrolling_list(-name=>'list_name',
\&                                -values=>['eenie','meenie','minie','moe'],
\&                                -default=>['eenie','moe'],
\&                                -size=>5,
\&                                -multiple=>'true',
\&                                -labels=>\e%labels);
.Ve
\fIscrolling_list()\fR creates a scrolling list.  
.Ip "\fBParameters:\fR" 8
.Ip "1." 8
The first and second arguments are the list name (\-name) and values
(\-values).  As in the popup menu, the second argument should be an
array reference.
.Ip "2." 8
The optional third argument (\-default) can be either a reference to a
list containing the values to be selected by default, or can be a
single value to select.  If this argument is missing or undefined,
then nothing is selected when the list first appears.  In the named
parameter version, you can use the synonym \*(L"\-defaults\*(R" for this
parameter.
.Ip "3." 8
The optional fourth argument is the size of the list (\-size).
.Ip "4." 8
The optional fifth argument can be set to true to allow multiple
simultaneous selections (\-multiple).  Otherwise only one selection
will be allowed at a time.
.Ip "5." 8
The optional sixth argument is a pointer to an associative array
containing long user-visible labels for the list items (\-labels).
If not provided, the values will be displayed.
.Sp
When this form is processed, all selected list items will be returned as
a list under the parameter name \*(L'list_name\*(R'.  The values of the
selected items can be retrieved with:
.Sp
.Vb 1
\&      @selected = $query->param('list_name');
.Ve
.Sp
\s-1JAVASCRIPTING\s0: \fIscrolling_list()\fR recognizes the following event
handlers: \fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onMouseOver\fR, \fB\-onMouseOut\fR
and \fB\-onBlur\fR.  See \fItextfield()\fR for the description of when these
handlers are called.
.Sh "\s-1CREATING\s0 A \s-1GROUP\s0 \s-1OF\s0 \s-1RELATED\s0 \s-1CHECKBOXES\s0"
.Sp
.Vb 5
\&   print $query->checkbox_group(-name=>'group_name',
\&                                -values=>['eenie','meenie','minie','moe'],
\&                                -default=>['eenie','moe'],
\&                                -linebreak=>'true',
\&                                -labels=>\e%labels);
.Ve
.Vb 3
\&   print $query->checkbox_group('group_name',
\&                                ['eenie','meenie','minie','moe'],
\&                                ['eenie','moe'],'true',\e%labels);
.Ve
.Vb 1
\&   HTML3-COMPATIBLE BROWSERS ONLY:
.Ve
.Vb 4
\&   print $query->checkbox_group(-name=>'group_name',
\&                                -values=>['eenie','meenie','minie','moe'],
\&                                -rows=2,-columns=>2);
\&    
.Ve
\fIcheckbox_group()\fR creates a list of checkboxes that are related
by the same name.
.Ip "\fBParameters:\fR" 8
.Ip "1." 8
The first and second arguments are the checkbox name and values,
respectively (\-name and \-values).  As in the popup menu, the second
argument should be an array reference.  These values are used for the
user-readable labels printed next to the checkboxes as well as for the
values passed to your script in the query string.
.Ip "2." 8
The optional third argument (\-default) can be either a reference to a
list containing the values to be checked by default, or can be a
single value to checked.  If this argument is missing or undefined,
then nothing is selected when the list first appears.
.Ip "3." 8
The optional fourth argument (\-linebreak) can be set to true to place
line breaks between the checkboxes so that they appear as a vertical
list.  Otherwise, they will be strung together on a horizontal line.
.Ip "4." 8
The optional fifth argument is a pointer to an associative array
relating the checkbox values to the user-visible labels that will
be printed next to them (\-labels).  If not provided, the values will
be used as the default.
.Ip "5." 8
\fB\s-1HTML3-\s0compatible browsers\fR (such as Netscape) can take advantage of
the optional parameters \fB\-rows\fR, and \fB\-columns\fR.  These parameters
cause \fIcheckbox_group()\fR to return an \s-1HTML3\s0 compatible table containing
the checkbox group formatted with the specified number of rows and
columns.  You can provide just the \-columns parameter if you wish;
checkbox_group will calculate the correct number of rows for you.
.Sp
To include row and column headings in the returned table, you
can use the \fB\-rowheaders\fR and \fB\-colheaders\fR parameters.  Both
of these accept a pointer to an array of headings to use.
The headings are just decorative.  They don't reorganize the
interpretation of the checkboxes -- they're still a single named
unit.
.Sp
When the form is processed, all checked boxes will be returned as
a list under the parameter name \*(L'group_name\*(R'.  The values of the
\*(L"on\*(R" checkboxes can be retrieved with:
.Sp
.Vb 1
\&      @turned_on = $query->param('group_name');
.Ve
The value returned by \fIcheckbox_group()\fR is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:
.Sp
.Vb 2
\&    @h = $query->checkbox_group(-name=>'group_name',-values=>\e@values);
\&    &use_in_creative_way(@h);
.Ve
\s-1JAVASCRIPTING\s0: \fIcheckbox_group()\fR recognizes the \fB\-onClick\fR
parameter.  This specifies a JavaScript code fragment or
function call to be executed every time the user clicks on
any of the buttons in the group.  You can retrieve the identity
of the particular button clicked on using the \*(L"this\*(R" variable.
.Sh "\s-1CREATING\s0 A \s-1STANDALONE\s0 \s-1CHECKBOX\s0"
.Sp
.Vb 4
\&    print $query->checkbox(-name=>'checkbox_name',
\&                           -checked=>'checked',
\&                           -value=>'ON',
\&                           -label=>'CLICK ME');
.Ve
.Vb 1
\&        -or-
.Ve
.Vb 1
\&    print $query->checkbox('checkbox_name','checked','ON','CLICK ME');
.Ve
\fIcheckbox()\fR is used to create an isolated checkbox that isn't logically
related to any others.
.Ip "\fBParameters:\fR" 8
.Ip "1." 8
The first parameter is the required name for the checkbox (\-name).  It
will also be used for the user-readable label printed next to the
checkbox.
.Ip "2." 8
The optional second parameter (\-checked) specifies that the checkbox
is turned on by default.  Synonyms are \-selected and \-on.
.Ip "3." 8
The optional third parameter (\-value) specifies the value of the
checkbox when it is checked.  If not provided, the word \*(L"on\*(R" is
assumed.
.Ip "4." 8
The optional fourth parameter (\-label) is the user-readable label to
be attached to the checkbox.  If not provided, the checkbox name is
used.
.Sp
The value of the checkbox can be retrieved using:
.Sp
.Vb 1
\&    $turned_on = $query->param('checkbox_name');
.Ve
\s-1JAVASCRIPTING\s0: \fIcheckbox()\fR recognizes the \fB\-onClick\fR
parameter.  See \fIcheckbox_group()\fR for further details.
.Sh "\s-1CREATING\s0 A \s-1RADIO\s0 \s-1BUTTON\s0 \s-1GROUP\s0"
.Sp
.Vb 5
\&   print $query->radio_group(-name=>'group_name',
\&                             -values=>['eenie','meenie','minie'],
\&                             -default=>'meenie',
\&                             -linebreak=>'true',
\&                             -labels=>\e%labels);
.Ve
.Vb 1
\&        -or-
.Ve
.Vb 2
\&   print $query->radio_group('group_name',['eenie','meenie','minie'],
\&                                          'meenie','true',\e%labels);
.Ve
.Vb 1
\&   HTML3-COMPATIBLE BROWSERS ONLY:
.Ve
.Vb 3
\&   print $query->radio_group(-name=>'group_name',
\&                             -values=>['eenie','meenie','minie','moe'],
\&                             -rows=2,-columns=>2);
.Ve
\fIradio_group()\fR creates a set of logically-related radio buttons
(turning one member of the group on turns the others off)
.Ip "\fBParameters:\fR" 8
.Ip "1." 8
The first argument is the name of the group and is required (\-name).
.Ip "2." 8
The second argument (\-values) is the list of values for the radio
buttons.  The values and the labels that appear on the page are
identical.  Pass an array \fIreference\fR in the second argument, either
using an anonymous array, as shown, or by referencing a named array as
in \*(L"\e@foo\*(R".
.Ip "3." 8
The optional third parameter (\-default) is the name of the default
button to turn on. If not specified, the first item will be the
default.  You can provide a nonexistent button name, such as \*(L"\-\*(R" to
start up with no buttons selected.
.Ip "4." 8
The optional fourth parameter (\-linebreak) can be set to \*(L'true\*(R' to put
line breaks between the buttons, creating a vertical list.
.Ip "5." 8
The optional fifth parameter (\-labels) is a pointer to an associative
array relating the radio button values to user-visible labels to be
used in the display.  If not provided, the values themselves are
displayed.
.Ip "6." 8
\fB\s-1HTML3-\s0compatible browsers\fR (such as Netscape) can take advantage 
of the optional 
parameters \fB\-rows\fR, and \fB\-columns\fR.  These parameters cause
\fIradio_group()\fR to return an \s-1HTML3\s0 compatible table containing
the radio group formatted with the specified number of rows
and columns.  You can provide just the \-columns parameter if you
wish; radio_group will calculate the correct number of rows
for you.
.Sp
To include row and column headings in the returned table, you
can use the \fB\-rowheader\fR and \fB\-colheader\fR parameters.  Both
of these accept a pointer to an array of headings to use.
The headings are just decorative.  They don't reorganize the
interpetation of the radio buttons -- they're still a single named
unit.
.Sp
When the form is processed, the selected radio button can
be retrieved using:
.Sp
.Vb 1
\&      $which_radio_button = $query->param('group_name');
.Ve
The value returned by \fIradio_group()\fR is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:
.Sp
.Vb 2
\&    @h = $query->radio_group(-name=>'group_name',-values=>\e@values);
\&    &use_in_creative_way(@h);
.Ve
.Sh "\s-1CREATING\s0 A \s-1SUBMIT\s0 \s-1BUTTON\s0 "
.Sp
.Vb 2
\&   print $query->submit(-name=>'button_name',
\&                        -value=>'value');
.Ve
.Vb 1
\&        -or-
.Ve
.Vb 1
\&   print $query->submit('button_name','value');
.Ve
\fIsubmit()\fR will create the query submission button.  Every form
should have one of these.
.Ip "\fBParameters:\fR" 8
.Ip "1." 8
The first argument (\-name) is optional.  You can give the button a
name if you have several submission buttons in your form and you want
to distinguish between them.  The name will also be used as the
user-visible label.  Be aware that a few older browsers don't deal with this correctly and
\fBnever\fR send back a value from a button.
.Ip "2." 8
The second argument (\-value) is also optional.  This gives the button
a value that will be passed to your script in the query string.
.Sp
You can figure out which button was pressed by using different
values for each one:
.Sp
.Vb 1
\&     $which_one = $query->param('button_name');
.Ve
\s-1JAVASCRIPTING\s0: \fIradio_group()\fR recognizes the \fB\-onClick\fR
parameter.  See \fIcheckbox_group()\fR for further details.
.Sh "\s-1CREATING\s0 A \s-1RESET\s0 \s-1BUTTON\s0"
.Sp
.Vb 1
\&   print $query->reset
.Ve
\fIreset()\fR creates the \*(L"reset\*(R" button.  Note that it restores the
form to its value from the last time the script was called, 
\s-1NOT\s0 necessarily to the defaults.
.Sh "\s-1CREATING\s0 A \s-1DEFAULT\s0 \s-1BUTTON\s0"
.Sp
.Vb 1
\&   print $query->defaults('button_label')
.Ve
\fIdefaults()\fR creates a button that, when invoked, will cause the
form to be completely reset to its defaults, wiping out all the
changes the user ever made.
.Sh "\s-1CREATING\s0 A \s-1HIDDEN\s0 \s-1FIELD\s0"
.Sp
.Vb 2
\&        print $query->hidden(-name=>'hidden_name',
\&                             -default=>['value1','value2'...]);
.Ve
.Vb 1
\&                -or-
.Ve
.Vb 1
\&        print $query->hidden('hidden_name','value1','value2'...);
.Ve
\fIhidden()\fR produces a text field that can't be seen by the user.  It
is useful for passing state variable information from one invocation
of the script to the next.
.Ip "\fBParameters:\fR" 8
.Ip "1." 8
The first argument is required and specifies the name of this
field (\-name).
.Ip "2.  " 8
The second argument is also required and specifies its value
(\-default).  In the named parameter style of calling, you can provide
a single value here or a reference to a whole list
.Sp
Fetch the value of a hidden field this way:
.Sp
.Vb 1
\&     $hidden_value = $query->param('hidden_name');
.Ve
Note, that just like all the other form elements, the value of a
hidden field is \*(L"sticky\*(R".  If you want to replace a hidden field with
some other values after the script has been called once you'll have to
do it manually:
.Sp
.Vb 1
\&     $query->param('hidden_name','new','values','here');
.Ve
.Sh "\s-1CREATING\s0 A \s-1CLICKABLE\s0 \s-1IMAGE\s0 \s-1BUTTON\s0"
.Sp
.Vb 3
\&     print $query->image_button(-name=>'button_name',
\&                                -src=>'/source/URL',
\&                                -align=>'MIDDLE');      
.Ve
.Vb 1
\&        -or-
.Ve
.Vb 1
\&     print $query->image_button('button_name','/source/URL','MIDDLE');
.Ve
\fIimage_button()\fR produces a clickable image.  When it's clicked on the
position of the click is returned to your script as \*(L"button_name.x\*(R"
and \*(L"button_name.y\*(R", where \*(L"button_name\*(R" is the name you've assigned
to it.
.Sp
\s-1JAVASCRIPTING\s0: \fIimage_button()\fR recognizes the \fB\-onClick\fR
parameter.  See \fIcheckbox_group()\fR for further details.
.Ip "\fBParameters:\fR" 8
.Ip "1." 8
The first argument (\-name) is required and specifies the name of this
field.
.Ip "2." 8
The second argument (\-src) is also required and specifies the \s-1URL\s0
.Ip "3. The third option (\-align, optional) is an alignment type, and may be \s-1TOP\s0, \s-1BOTTOM\s0 or \s-1MIDDLE\s0" 8
.Sp
Fetch the value of the button this way:
     \f(CW$x\fR = \f(CW$query\fR\->\fIparam\fR\|('button_name.x');
     \f(CW$y\fR = \f(CW$query\fR\->\fIparam\fR\|('button_name.y');
.Sh "\s-1CREATING\s0 A \s-1JAVASCRIPT\s0 \s-1ACTION\s0 \s-1BUTTON\s0"
.Sp
.Vb 3
\&     print $query->button(-name=>'button_name',
\&                          -value=>'user visible label',
\&                          -onClick=>"do_something()");
.Ve
.Vb 1
\&        -or-
.Ve
.Vb 1
\&     print $query->button('button_name',"do_something()");
.Ve
\fIbutton()\fR produces a button that is compatible with Netscape 2.0's
JavaScript.  When it's pressed the fragment of JavaScript code
pointed to by the \fB\-onClick\fR parameter will be executed.  On
non-Netscape browsers this form element will probably not even
display.
.SH "NETSCAPE COOKIES"
Netscape browsers versions 1.1 and higher support a so-called
\*(L"cookie\*(R" designed to help maintain state within a browser session.
CGI.pm has several methods that support cookies.
.Sp
A cookie is a name=value pair much like the named parameters in a CGI
query string.  CGI scripts create one or more cookies and send
them to the browser in the HTTP header.  The browser maintains a list
of cookies that belong to a particular Web server, and returns them
to the CGI script during subsequent interactions.
.Sp
In addition to the required name=value pair, each cookie has several
optional attributes:
.Ip "1. an expiration time" 8
This is a time/date string (in a special \s-1GMT\s0 format) that indicates
when a cookie expires.  The cookie will be saved and returned to your
script until this expiration date is reached if the user exits
Netscape and restarts it.  If an expiration date isn't specified, the cookie
will remain active until the user quits Netscape.
.Ip "2. a domain" 8
This is a partial or complete domain name for which the cookie is 
valid.  The browser will return the cookie to any host that matches
the partial domain name.  For example, if you specify a domain name
of \*(L".capricorn.com\*(R", then Netscape will return the cookie to
Web servers running on any of the machines \*(L"www.capricorn.com\*(R", 
\*(L"www2.capricorn.com\*(R", \*(L"feckless.capricorn.com\*(R", etc.  Domain names
must contain at least two periods to prevent attempts to match
on top level domains like \*(L".edu\*(R".  If no domain is specified, then
the browser will only return the cookie to servers on the host the
cookie originated from.
.Ip "3. a path" 8
If you provide a cookie path attribute, the browser will check it
against your script's \s-1URL\s0 before returning the cookie.  For example,
if you specify the path \*(L"/cgi-bin\*(R", then the cookie will be returned
to each of the scripts \*(L"/cgi-bin/tally.pl\*(R", \*(L"/cgi-bin/order.pl\*(R",
and \*(L"/cgi-bin/customer_service/complain.pl\*(R", but not to the script
\*(L"/cgi-private/site_admin.pl\*(R".  By default, path is set to \*(L"/\*(R", which
causes the cookie to be sent to any \s-1CGI\s0 script on your site.
.Ip "4. a \*(N"secure\*(T" flag" 8
If the \*(L"secure\*(R" attribute is set, the cookie will only be sent to your
script if the \s-1CGI\s0 request is occurring on a secure channel, such as \s-1SSL\s0.
.Sp
The interface to Netscape cookies is the \fBcookie()\fR method:
.Sp
.Vb 7
\&    $cookie = $query->cookie(-name=>'sessionID',
\&                             -value=>'xyzzy',
\&                             -expires=>'+1h',
\&                             -path=>'/cgi-bin/database',
\&                             -domain=>'.capricorn.org',
\&                             -secure=>1);
\&    print $query->header(-cookie=>$cookie);
.Ve
\fBcookie()\fR creates a new cookie.  Its parameters include:
.Ip "\fB\-name\fR" 8
The name of the cookie (required).  This can be any string at all.
Although Netscape limits its cookie names to non-whitespace
alphanumeric characters, \s-1CGI\s0.pm removes this restriction by escaping
and unescaping cookies behind the scenes.
.Ip "\fB\-value\fR" 8
The value of the cookie.  This can be any scalar value,
array reference, or even associative array reference.  For example,
you can store an entire associative array into a cookie this way:
.Sp
.Vb 2
\&        $cookie=$query->cookie(-name=>'family information',
\&                               -value=>\e%childrens_ages);
.Ve
.Ip "\fB\-path\fR" 8
The optional partial path for which this cookie will be valid, as described
above.
.Ip "\fB\-domain\fR" 8
The optional partial domain for which this cookie will be valid, as described
above.
.Ip "\fB\-expires\fR" 8
The optional expiration date for this cookie.  The format is as described 
in the section on the \fBheader()\fR method:
.Sp
.Vb 1
\&        "+1h"  one hour from now
.Ve
.Ip "\fB\-secure\fR" 8
If set to true, this cookie will only be used within a secure
\s-1SSL\s0 session.
.Sp
The cookie created by \fIcookie()\fR must be incorporated into the \s-1HTTP\s0
header within the string returned by the \fIheader()\fR method:
.Sp
.Vb 1
\&        print $query->header(-cookie=>$my_cookie);
.Ve
To create multiple cookies, give \fIheader()\fR an array reference:
.Sp
.Vb 5
\&        $cookie1 = $query->cookie(-name=>'riddle_name',
\&                                  -value=>"The Sphynx's Question");
\&        $cookie2 = $query->cookie(-name=>'answers',
\&                                  -value=>\e%answers);
\&        print $query->header(-cookie=>[$cookie1,$cookie2]);
.Ve
To retrieve a cookie, request it by name by calling \fIcookie()\fR
method without the \fB\-value\fR parameter:
.Sp
.Vb 4
\&        use CGI;
\&        $query = new CGI;
\&        %answers = $query->cookie(-name=>'answers');
\&        # $query->cookie('answers') will work too!
.Ve
The cookie and \s-1CGI\s0 namespaces are separate.  If you have a parameter
named \*(L'answers\*(R' and a cookie named \*(L'answers\*(R', the values retrieved by
\fIparam()\fR and \fIcookie()\fR are independent of each other.  However, it's
simple to turn a \s-1CGI\s0 parameter into a cookie, and vice-versa:
.Sp
.Vb 4
\&   # turn a CGI parameter into a cookie
\&   $c=$q->cookie(-name=>'answers',-value=>[$q->param('answers')]);
\&   # vice-versa
\&   $q->param(-name=>'answers',-value=>[$q->cookie('answers')]);
.Ve
See the \fBcookie.cgi\fR example script for some ideas on how to use
cookies effectively.
.Sp
\fB\s-1NOTE\s0:\fR There appear to be some (undocumented) restrictions on
Netscape cookies.  In Netscape 2.01, at least, I haven't been able to
set more than three cookies at a time.  There may also be limits on
the length of cookies.  If you need to store a lot of information,
it's probably better to create a unique session \s-1ID\s0, store it in a
cookie, and use the session \s-1ID\s0 to locate an external file/database
saved on the server's side of the connection.
.SH "WORKING WITH NETSCAPE FRAMES"
It's possible for CGI.pm scripts to write into several browser
panels and windows using Netscape's frame mechanism.  
There are three techniques for defining new frames programmatically:
.Ip "1. Create a <Frameset> document" 8
After writing out the \s-1HTTP\s0 header, instead of creating a standard
\s-1HTML\s0 document using the \fIstart_html()\fR call, create a <\s-1FRAMESET\s0> 
document that defines the frames on the page.  Specify your \fIscript\fR\|(s)
(with appropriate parameters) as the \s-1SRC\s0 for each of the frames.
.Sp
There is no specific support for creating <\s-1FRAMESET\s0> sections 
in \s-1CGI\s0.pm, but the \s-1HTML\s0 is very simple to write.  See the frame
documentation in Netscape's home pages for details 
.Sp
.Vb 1
\&  http://home.netscape.com/assist/net_sites/frames.html
.Ve
.Ip "2. Specify the destination for the document in the \s-1HTTP\s0 header" 8
You may provide a \fB\-target\fR parameter to the \fIheader()\fR method:
   
    print \f(CW$q\fR\->\fIheader\fR\|(\-target=>'ResultsWindow');
.Sp
This will tell Netscape to load the output of your script into the
frame named \*(L"ResultsWindow\*(R".  If a frame of that name doesn't
already exist, Netscape will pop up a new window and load your
script's document into that.  There are a number of magic names
that you can use for targets.  See the frame documents on Netscape's
home pages for details.
.Ip "3. Specify the destination for the document in the <\s-1FORM\s0> tag" 8
You can specify the frame to load in the \s-1FORM\s0 tag itself.  With
\s-1CGI\s0.pm it looks like this:
.Sp
.Vb 1
\&    print $q->startform(-target=>'ResultsWindow');
.Ve
When your script is reinvoked by the form, its output will be loaded
into the frame named \*(L"ResultsWindow\*(R".  If one doesn't already exist
a new window will be created.
.Sp
The script \*(L"frameset.cgi\*(R" in the examples directory shows one way to
create pages in which the fill-out form and the response live in
side-by-side frames.
.SH "LIMITED SUPPORT FOR CASCADING STYLE SHEETS"
CGI.pm has limited support for HTML3's cascading style sheets (css).
To incorporate a stylesheet into your document, pass the
\fIstart_html()\fR method a \fB\-style\fR parameter.  The value of this
parameter may be a scalar, in which case it is incorporated directly
into a <STYLE> section, or it may be a hash reference.  In the latter
case you should provide the hash with one or more of \fB\-src\fR or
\fB\-code\fR.  \fB\-src\fR points to a URL where an externally-defined
stylesheet can be found.  \fB\-code\fR points to a scalar value to be
incorporated into a <STYLE> section.  Style definitions in \fB\-code\fR
override similarly-named ones in \fB\-src\fR, hence the name \*(L"cascading.\*(R"
.Sp
You may also specify the type of the stylesheet by adding the optional
\fB\-type\fR parameter to the hash pointed to by \fB\-style\fR.  If not
specified, the style defaults to \*(L'text/css\*(R'.
.Sp
To refer to a style within the body of your document, add the
\fB\-class\fR parameter to any HTML element:
.Sp
.Vb 1
\&    print h1({-class=>'Fancy'},'Welcome to the Party');
.Ve
Or define styles on the fly with the \fB\-style\fR parameter:
.Sp
.Vb 1
\&    print h1({-style=>'Color: red;'},'Welcome to Hell');
.Ve
You may also use the new \fBspan()\fR element to apply a style to a
section of text:
.Sp
.Vb 4
\&    print span({-style=>'Color: red;'},
\&               h1('Welcome to Hell'),
\&               "Where did that handbasket get to?"
\&               );
.Ve
Note that you must import the \*(L":html3\*(R" definitions to have the
\fBspan()\fR method available.  Here's a quick and dirty example of using
CSS's.  See the CSS specification at
http://www.w3.org/pub/WWW/TR/Wd-css-1.html for more information.
.Sp
.Vb 1
\&    use CGI qw/:standard :html3/;
.Ve
.Vb 29
\&    #here's a stylesheet incorporated directly into the page
\&    $newStyle=<<END;
\&    <!-- 
\&    P.Tip {
\&        margin-right: 50pt;
\&        margin-left: 50pt;
\&        color: red;
\&    }
\&    P.Alert {
\&        font-size: 30pt;
\&        font-family: sans-serif;
\&      color: red;
\&    }
\&    -->
\&    END
\&    print header();
\&    print start_html( -title=>'CGI with Style',
\&                      -style=>{-src=>'http://www.capricorn.com/style/st1.css',
\&                               -code=>$newStyle}
\&                     );
\&    print h1('CGI with Style'),
\&          p({-class=>'Tip'},
\&            "Better read the cascading style sheet spec before playing with this!"),
\&          span({-style=>'color: magenta'},
\&               "Look Mom, no hands!",
\&               p(),
\&               "Whooo wee!"
\&               );
\&    print end_html;
.Ve
.SH "DEBUGGING"
If you are running the script
from the command line or in the perl debugger, you can pass the script
a list of keywords or parameter=value pairs on the command line or 
from standard input (you don't have to worry about tricking your
script into reading from environment variables).
You can pass keywords like this:
.Sp
.Vb 1
\&    your_script.pl keyword1 keyword2 keyword3
.Ve
or this:
.Sp
.Vb 1
\&   your_script.pl keyword1+keyword2+keyword3
.Ve
or this:
.Sp
.Vb 1
\&    your_script.pl name1=value1 name2=value2
.Ve
or this:
.Sp
.Vb 1
\&    your_script.pl name1=value1&name2=value2
.Ve
or even as newline-delimited parameters on standard input.
.Sp
When debugging, you can use quotes and backslashes to escape 
characters in the familiar shell manner, letting you place
spaces and other funny characters in your parameter=value
pairs:
.Sp
.Vb 1
\&   your_script.pl "name1='I am a long value'" "name2=two\e words"
.Ve
.Sh "\s-1DUMPING\s0 \s-1OUT\s0 \s-1ALL\s0 \s-1THE\s0 \s-1NAME/VALUE\s0 \s-1PAIRS\s0"
The \fIdump()\fR method produces a string consisting of all the query's
name/value pairs formatted nicely as a nested list.  This is useful
for debugging purposes:
.Sp
.Vb 2
\&    print $query->dump
\&    
.Ve
Produces something that looks like:
.Sp
.Vb 11
\&    <UL>
\&    <LI>name1
\&        <UL>
\&        <LI>value1
\&        <LI>value2
\&        </UL>
\&    <LI>name2
\&        <UL>
\&        <LI>value1
\&        </UL>
\&    </UL>
.Ve
You can pass a value of \*(L'true\*(R' to \fIdump()\fR in order to get it to
print the results out as plain text, suitable for incorporating
into a <\s-1PRE\s0> section.
.Sp
As a shortcut, as of version 1.56 you can interpolate the entire \s-1CGI\s0
object into a string and it will be replaced with the a nice \s-1HTML\s0 dump
shown above:
.Sp
.Vb 2
\&    $query=new CGI;
\&    print "<H2>Current Values</H2> $query\en";
.Ve
.SH "FETCHING ENVIRONMENT VARIABLES"
Some of the more useful environment variables can be fetched
through this interface.  The methods are as follows:
.Ip "\fBaccept()\fR" 8
Return a list of \s-1MIME\s0 types that the remote browser
accepts. If you give this method a single argument
corresponding to a \s-1MIME\s0 type, as in
\f(CW$query\fR\->\fIaccept\fR\|('text/html'), it will return a
floating point value corresponding to the browser's
preference for this type from 0.0 (don't want) to 1.0.
Glob types (e.g. text/*) in the browser's accept list
are handled correctly.
.Ip "\fBraw_cookie()\fR" 8
Returns the \s-1HTTP_COOKIE\s0 variable, an \s-1HTTP\s0 extension implemented by
Netscape browsers version 1.1 and higher.  Cookies have a special
format, and this method call just returns the raw form (?cookie
dough).  See \fIcookie()\fR for ways of setting and retrieving cooked
cookies.
.Sp
Called with no parameters, \fIraw_cookie()\fR returns the packed cookie
structure.  You can separate it into individual cookies by splitting
on the character sequence \*(L"; \*(L".  Called with the name of a cookie,
retrieves the \fBunescaped\fR form of the cookie.  You can use the
regular \fIcookie()\fR method to get the names, or use the \fIraw_fetch()\fR
method from the \s-1CGI::\s0Cookie module.
.Ip "\fBuser_agent()\fR" 8
Returns the \s-1HTTP_USER_AGENT\s0 variable.  If you give
this method a single argument, it will attempt to
pattern match on it, allowing you to do something
like \f(CW$query\fR\->\fIuser_agent\fR\|(netscape);
.Ip "\fBpath_info()\fR" 8
Returns additional path information from the script \s-1URL\s0.
E.G. fetching /cgi-bin/your_script/additional/stuff will
result in \f(CW$query\fR\->\fIpath_info()\fR returning
\*(L"additional/stuff\*(R".
.Sp
\s-1NOTE\s0: The Microsoft Internet Information Server
is broken with respect to additional path information.  If
you use the Perl \s-1DLL\s0 library, the \s-1IIS\s0 server will attempt to
execute the additional path information as a Perl script.
If you use the ordinary file associations mapping, the
path information will be present in the environment, 
but incorrect.  The best thing to do is to avoid using additional
path information in \s-1CGI\s0 scripts destined for use with \s-1IIS\s0.
.Ip "\fBpath_translated()\fR" 8
As per \fIpath_info()\fR but returns the additional
path information translated into a physical path, e.g.
\*(L"/usr/local/etc/httpd/htdocs/additional/stuff\*(R".
.Sp
The Microsoft \s-1IIS\s0 is broken with respect to the translated
path as well.
.Ip "\fBremote_host()\fR" 8
Returns either the remote host name or \s-1IP\s0 address.
if the former is unavailable.
.Ip "\fBscript_name()\fR Return the script name as a partial \s-1URL\s0, for self-refering scripts." 8
.Ip "\fBreferer()\fR" 8
Return the \s-1URL\s0 of the page the browser was viewing
prior to fetching your script.  Not available for all
browsers.
.Ip "\fBauth_type ()\fR" 8
Return the authorization/verification method in use for this
script, if any.
.Ip "\fBserver_name ()\fR" 8
Returns the name of the server, usually the machine's host
name.
.Ip "\fBvirtual_host ()\fR" 8
When using virtual hosts, returns the name of the host that
the browser attempted to contact
.Ip "\fBserver_software ()\fR" 8
Returns the server software and version number.
.Ip "\fBremote_user ()\fR" 8
Return the authorization/verification name used for user
verification, if this script is protected.
.Ip "\fBuser_name ()\fR" 8
Attempt to obtain the remote user's name, using a variety
of different techniques.  This only works with older browsers
such as Mosaic.  Netscape does not reliably report the user
name!
.Ip "\fBrequest_method()\fR" 8
Returns the method used to access your script, usually
one of \*(L'\s-1POST\s0\*(R', \*(L'\s-1GET\s0\*(R' or \*(L'\s-1HEAD\s0\*(R'.
.SH "USING NPH SCRIPTS"
NPH, or \*(L"no-parsed-header\*(R", scripts bypass the server completely by
sending the complete HTTP header directly to the browser.  This has
slight performance benefits, but is of most use for taking advantage
of HTTP extensions that are not directly supported by your server,
such as server push and PICS headers.
.Sp
Servers use a variety of conventions for designating CGI scripts as
NPH.  Many Unix servers look at the beginning of the script's name for
the prefix \*(L"nph-\*(R".  The Macintosh WebSTAR server and Microsoft's
Internet Information Server, in contrast, try to decide whether a
program is an NPH script by examining the first line of script output.
.Sp
CGI.pm supports NPH scripts with a special NPH mode.  When in this
mode, CGI.pm will output the necessary extra header information when
the \fIheader()\fR and \fIredirect()\fR methods are
called.
.Sp
The Microsoft Internet Information Server requires NPH mode.  As of version
2.30, CGI.pm will automatically detect when the script is running under IIS
and put itself into this mode.  You do not need to do this manually, although
it won't hurt anything if you do.
.Sp
There are a number of ways to put CGI.pm into NPH mode:
.Ip "In the \fBuse\fR statement " 8
Simply add the \*(L"\-nph\*(R" pragmato the list of symbols to be imported into
your script:
.Sp
.Vb 1
\&      use CGI qw(:standard -nph)
.Ve
.Ip "By calling the \fBnph()\fR method:" 8
Call \fBnph()\fR with a non-zero parameter at any point after using \s-1CGI\s0.pm in your program.
.Sp
.Vb 1
\&      CGI->nph(1)
.Ve
.Ip "By using \fB\-nph\fR parameters in the \fBheader()\fR and \fBredirect()\fR  statements:" 8
.Sp
.Vb 1
\&      print $q->header(-nph=>1);
.Ve
.SH "Server Push"
CGI.pm provides three simple functions for producing multipart
documents of the type needed to implement server push.  These
functions were graciously provided by Ed Jordan <ed@fidalgo.net>.  To
import these into your namespace, you must import the \*(L":push\*(R" set.
You are also advised to put the script into NPH mode and to set $| to
1 to avoid buffering problems.
.Sp
Here is a simple script that demonstrates server push:
.Sp
.Vb 10
\&  #!/usr/local/bin/perl
\&  use CGI qw/:push -nph/;
\&  $| = 1;
\&  print multipart_init(-boundary=>'----------------here we go!');
\&  while (1) {
\&      print multipart_start(-type=>'text/plain'),
\&            "The current time is ",scalar(localtime),"\en",
\&            multipart_end;
\&      sleep 1;
\&  }
.Ve
This script initializes server push by calling \fBmultipart_init()\fR.
It then enters an infinite loop in which it begins a new multipart
section by calling \fBmultipart_start()\fR, prints the current local time,
and ends a multipart section with \fBmultipart_end()\fR.  It then sleeps
a second, and begins again.
.Ip "multipart_init()         multipart_init(\-boundary=>$boundary);" 8
Initialize the multipart system.  The \-boundary argument specifies
what \s-1MIME\s0 boundary string to use to separate parts of the document.
If not provided, \s-1CGI\s0.pm chooses a reasonable boundary for you.
.Ip "multipart_start()" 8
.Sp
.Vb 1
\&  multipart_start(-type=>$type)
.Ve
Start a new part of the multipart document using the specified \s-1MIME\s0
type.  If not specified, text/html is assumed.
.Ip "multipart_end()" 8
.Sp
.Vb 1
\&  multipart_end()
.Ve
End a part.  You must remember to call \fImultipart_end()\fR once for each
\fImultipart_start()\fR.
.Sp
Users interested in server push applications should also have a look
at the \s-1CGI::\s0Push module.
.SH "Avoiding Denial of Service Attacks"
A potential problem with CGI.pm is that, by default, it attempts to
process form POSTings no matter how large they are.  A wily hacker
could attack your site by sending a CGI script a huge POST of many
megabytes.  CGI.pm will attempt to read the entire POST into a
variable, growing hugely in size until it runs out of memory.  While
the script attempts to allocate the memory the system may slow down
dramatically.  This is a form of denial of service attack.
.Sp
Another possible attack is for the remote user to force CGI.pm to
accept a huge file upload.  CGI.pm will accept the upload and store it
in a temporary directory even if your script doesn't expect to receive
an uploaded file.  CGI.pm will delete the file automatically when it
terminates, but in the meantime the remote user may have filled up the
server's disk space, causing problems for other programs.
.Sp
The best way to avoid denial of service attacks is to limit the amount
of memory, CPU time and disk space that CGI scripts can use.  Some Web
servers come with built-in facilities to accomplish this. In other
cases, you can use the shell \fIlimit\fR or \fIulimit\fR
commands to put ceilings on CGI resource usage.
.Sp
CGI.pm also has some simple built-in protections against denial of
service attacks, but you must activate them before you can use them.
These take the form of two global variables in the CGI name space:
.Ip "\fB$\s-1CGI::POST_MAX\s0\fR" 8
If set to a non-negative integer, this variable puts a ceiling
on the size of POSTings, in bytes.  If \s-1CGI\s0.pm detects a \s-1POST\s0
that is greater than the ceiling, it will immediately exit with an error
message.  This value will affect both ordinary POSTs and
multipart POSTs, meaning that it limits the maximum size of file
uploads as well.  You should set this to a reasonably high
value, such as 1 megabyte.
.Ip "\fB$\s-1CGI::DISABLE_UPLOADS\s0\fR" 8
If set to a non-zero value, this will disable file uploads
completely.  Other fill-out form values will work as usual.
.Sp
You can use these variables in either of two ways.
.Ip "\fB1. On a script-by-script basis\fR" 8
Set the variable at the top of the script, right after the \*(L"use\*(R" statement:
.Sp
.Vb 4
\&    use CGI qw/:standard/;
\&    use CGI::Carp 'fatalsToBrowser';
\&    $CGI::POST_MAX=1024 * 100;  # max 100K posts
\&    $CGI::DISABLE_UPLOADS = 1;  # no uploads
.Ve
.Ip "\fB2. Globally for all scripts\fR" 8
Open up \s-1CGI\s0.pm, find the definitions for \f(CW$POST_MAX\fR and 
\f(CW$DISABLE_UPLOADS\fR, and set them to the desired values.  You'll 
find them towards the top of the file in a subroutine named 
\fIinitialize_globals()\fR.
.Sp
Since an attempt to send a \s-1POST\s0 larger than \f(CW$POST_MAX\fR bytes
will cause a fatal error, you might want to use \s-1CGI::\s0Carp to echo the
fatal error message to the browser window as shown in the example
above.  Otherwise the remote user will see only a generic \*(L"Internal
Server\*(R" error message.  See the the \fI\s-1CGI::\s0Carp\fR manpage manual page for more
details.
.SH "COMPATIBILITY WITH CGI\-LIB.PL"
To make it easier to port existing programs that use cgi-lib.pl
the compatibility routine \*(L"ReadParse\*(R" is provided.  Porting is
simple:
.Sp
OLD VERSION
    require \*(L"cgi-lib.pl\*(R";
    &ReadParse;
    print \*(L"The value of the antique is \f(CW$in\fR{antique}.\en\*(R";
.Sp
NEW VERSION
    use CGI;
    CGI::ReadParse
    print \*(L"The value of the antique is \f(CW$in\fR{antique}.\en\*(R";
.Sp
CGI.pm's \fIReadParse()\fR routine creates a tied variable named \f(CW%in\fR,
which can be accessed to obtain the query variables.  Like
ReadParse, you can also provide your own variable.  Infrequently
used features of ReadParse, such as the creation of \f(CW@in\fR and \f(CW$in\fR 
variables, are not supported.
.Sp
Once you use ReadParse, you can retrieve the query object itself
this way:
.Sp
.Vb 3
\&    $q = $in{CGI};
\&    print $q->textfield(-name=>'wow',
\&                        -value=>'does this really work?');
.Ve
This allows you to start using the more interesting features
of CGI.pm without rewriting your old scripts from scratch.
.SH "AUTHOR INFORMATION"
Copyright 1995-1997, Lincoln D. Stein.  All rights reserved.  It may
be used and modified freely, but I do request that this copyright
notice remain attached to the file.  You may modify this module as you
wish, but if you redistribute a modified version, please attach a note
listing the modifications you have made.
.Sp
Address bug reports and comments to:
lstein@genome.wi.mit.edu
.SH "CREDITS"
Thanks very much to:
.Ip "Matt Heffron (heffron@falstaff.css.beckman.com)" 8
.Ip "James Taylor (james.taylor@srs.gov)" 8
.Ip "Scott Anguish <sanguish@digifix.com>" 8
.Ip "Mike Jewell (mlj3u@virginia.edu)" 8
.Ip "Timothy Shimmin (tes@kbs.citri.edu.au)" 8
.Ip "Joergen Haegg (jh@axis.se)" 8
.Ip "Laurent Delfosse (delfosse@csgrad1.cs.wvu.edu)" 8
.Ip "Richard Resnick (applepi1@aol.com)" 8
.Ip "Craig Bishop (csb@barwonwater.vic.gov.au)" 8
.Ip "Tony Curtis (tc@vcpc.univie.ac.at)" 8
.Ip "Tim Bunce (Tim.Bunce@ig.co.uk)" 8
.Ip "Tom Christiansen (tchrist@convex.com)" 8
.Ip "Andreas Koenig (k@franz.ww.\s-1TU\s0\-Berlin.\s-1DE\s0)" 8
.Ip "Tim MacKenzie (Tim.MacKenzie@fulcrum.com.au)" 8
.Ip "Kevin B. Hendricks (kbhend@dogwood.tyler.wm.edu)" 8
.Ip "Stephen Dahmen (joyfire@inxpress.net)" 8
.Ip "Ed Jordan (ed@fidalgo.net)" 8
.Ip "David Alan Pisoni (david@cnation.com)" 8
.Ip "Doug MacEachern (dougm@opengroup.org)" 8
.Ip "Robin Houston (robin@oneworld.org)" 8
.Ip "...and many many more..." 8
for suggestions and bug fixes.
.SH "A COMPLETE EXAMPLE OF A SIMPLE FORM\-BASED SCRIPT"
.Sp
.Vb 5
\&        #!/usr/local/bin/perl
\&     
\&        use CGI;
\& 
\&        $query = new CGI;
.Ve
.Vb 59
\&        print $query->header;
\&        print $query->start_html("Example CGI.pm Form");
\&        print "<H1> Example CGI.pm Form</H1>\en";
\&        &print_prompt($query);
\&        &do_work($query);
\&        &print_tail;
\&        print $query->end_html;
\& 
\&        sub print_prompt {
\&           my($query) = @_;
\& 
\&           print $query->startform;
\&           print "<EM>What's your name?</EM><BR>";
\&           print $query->textfield('name');
\&           print $query->checkbox('Not my real name');
\& 
\&           print "<P><EM>Where can you find English Sparrows?</EM><BR>";
\&           print $query->checkbox_group(
\&                                 -name=>'Sparrow locations',
\&                                 -values=>[England,France,Spain,Asia,Hoboken],
\&                                 -linebreak=>'yes',
\&                                 -defaults=>[England,Asia]);
\& 
\&           print "<P><EM>How far can they fly?</EM><BR>",
\&                $query->radio_group(
\&                        -name=>'how far',
\&                        -values=>['10 ft','1 mile','10 miles','real far'],
\&                        -default=>'1 mile');
\& 
\&           print "<P><EM>What's your favorite color?</EM>  ";
\&           print $query->popup_menu(-name=>'Color',
\&                                    -values=>['black','brown','red','yellow'],
\&                                    -default=>'red');
\& 
\&           print $query->hidden('Reference','Monty Python and the Holy Grail');
\& 
\&           print "<P><EM>What have you got there?</EM><BR>";
\&           print $query->scrolling_list(
\&                         -name=>'possessions',
\&                         -values=>['A Coconut','A Grail','An Icon',
\&                                   'A Sword','A Ticket'],
\&                         -size=>5,
\&                         -multiple=>'true');
\& 
\&           print "<P><EM>Any parting comments?</EM><BR>";
\&           print $query->textarea(-name=>'Comments',
\&                                  -rows=>10,
\&                                  -columns=>50);
\& 
\&           print "<P>",$query->reset;
\&           print $query->submit('Action','Shout');
\&           print $query->submit('Action','Scream');
\&           print $query->endform;
\&           print "<HR>\en";
\&        }
\& 
\&        sub do_work {
\&           my($query) = @_;
\&           my(@values,$key);
.Ve
.Vb 1
\&           print "<H2>Here are the current settings in this form</H2>";
.Ve
.Vb 14
\&           foreach $key ($query->param) {
\&              print "<STRONG>$key</STRONG> -> ";
\&              @values = $query->param($key);
\&              print join(", ",@values),"<BR>\en";
\&          }
\&        }
\& 
\&        sub print_tail {
\&           print <<END;
\&        <HR>
\&        <ADDRESS>Lincoln D. Stein</ADDRESS><BR>
\&        <A HREF="/">Home Page</A>
\&        END
\&        }
.Ve
.SH "BUGS"
This module has grown large and monolithic.  Furthermore it's doing many
things, such as handling URLs, parsing CGI input, writing HTML, etc., that
are also done in the LWP modules. It should be discarded in favor of
the CGI::* modules, but somehow I continue to work on it.
.Sp
Note that the code is truly contorted in order to avoid spurious
warnings when programs are run with the \fB\-w\fR switch.
.SH "SEE ALSO"
the \fICGI::Carp\fR manpage, the \fIURI::URL\fR manpage, the \fICGI::Request\fR manpage, the \fICGI::MiniSvr\fR manpage,
the \fICGI::Base\fR manpage, the \fICGI::Form\fR manpage, the \fICGI::Apache\fR manpage, the \fICGI::Switch\fR manpage,
the \fICGI::Push\fR manpage, the \fICGI::Fast\fR manpage

.rn }` ''
.IX Title "CGI 3"
.IX Name "CGI - Simple Common Gateway Interface Class"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "ABSTRACT"

.IX Header "DESCRIPTION"

.IX Subsection "\s-1PROGRAMMING\s0 \s-1STYLE\s0"

.IX Subsection "\s-1CALLING\s0 \s-1CGI\s0.\s-1PM\s0 \s-1ROUTINES\s0"

.IX Item "1. Use another name for the argument, if one is available.  For example, \-value is an alias for \-values."

.IX Item "2. Change the capitalization, e.g. \-Values"

.IX Item "3. Put quotes around the argument name, e.g. \*(N'\-values\*(T'"

.IX Subsection "\s-1CREATING\s0 A \s-1NEW\s0 \s-1QUERY\s0 \s-1OBJECT\s0 (\s-1OBJECT\s0\-\s-1ORIENTED\s0 \s-1STYLE\s0):"

.IX Subsection "\s-1CREATING\s0 A \s-1NEW\s0 \s-1QUERY\s0 \s-1OBJECT\s0 \s-1FROM\s0 \s-1AN\s0 \s-1INPUT\s0 \s-1FILE\s0"

.IX Subsection "\s-1FETCHING\s0 A \s-1LIST\s0 \s-1OF\s0 \s-1KEYWORDS\s0 \s-1FROM\s0 \s-1THE\s0 \s-1QUERY\s0:"

.IX Subsection "\s-1FETCHING\s0 \s-1THE\s0 \s-1NAMES\s0 \s-1OF\s0 \s-1ALL\s0 \s-1THE\s0 \s-1PARAMETERS\s0 \s-1PASSED\s0 \s-1TO\s0 \s-1YOUR\s0 \s-1SCRIPT\s0:"

.IX Subsection "\s-1FETCHING\s0 \s-1THE\s0 \s-1VALUE\s0 \s-1OR\s0 \s-1VALUES\s0 \s-1OF\s0 A \s-1SINGLE\s0 \s-1NAMED\s0 \s-1PARAMETER\s0:"

.IX Subsection "\s-1SETTING\s0 \s-1THE\s0 \fI\s-1VALUE\s0\fR\|(S) \s-1OF\s0 A \s-1NAMED\s0 \s-1PARAMETER\s0:"

.IX Subsection "\s-1APPENDING\s0 \s-1ADDITIONAL\s0 \s-1VALUES\s0 \s-1TO\s0 A \s-1NAMED\s0 \s-1PARAMETER\s0:"

.IX Subsection "\s-1IMPORTING\s0 \s-1ALL\s0 \s-1PARAMETERS\s0 \s-1INTO\s0 A \s-1NAMESPACE\s0:"

.IX Subsection "\s-1DELETING\s0 A \s-1PARAMETER\s0 \s-1COMPLETELY\s0:"

.IX Subsection "\s-1DELETING\s0 \s-1ALL\s0 \s-1PARAMETERS\s0:"

.IX Subsection "\s-1DIRECT\s0 \s-1ACCESS\s0 \s-1TO\s0 \s-1THE\s0 \s-1PARAMETER\s0 \s-1LIST\s0:"

.IX Subsection "\s-1SAVING\s0 \s-1THE\s0 \s-1STATE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SCRIPT\s0 \s-1TO\s0 A \s-1FILE\s0:"

.IX Subsection "\s-1USING\s0 \s-1THE\s0 \s-1FUNCTION\s0\-\s-1ORIENTED\s0 \s-1INTERFACE\s0"

.IX Item "\fB:cgi\fR"

.IX Item "\fB:form\fR"

.IX Item "\fB:html2\fR"

.IX Item "\fB:html3\fR"

.IX Item "\fB:netscape\fR"

.IX Item "\fB:html\fR"

.IX Item "\fB:standard\fR"

.IX Item "\fB:all\fR"

.IX Subsection "\s-1PRAGMAS\s0"

.IX Item "-any"

.IX Item "-compile"

.IX Item "-nph"

.IX Item "-autoload"

.IX Item "-no_debug"

.IX Item "-private_tempfiles"

.IX Header "GENERATING DYNAMIC DOCUMENTS"

.IX Subsection "\s-1CREATING\s0 A \s-1STANDARD\s0 \s-1HTTP\s0 \s-1HEADER\s0:"

.IX Subsection "\s-1GENERATING\s0 A \s-1REDIRECTION\s0 \s-1HEADER\s0"

.IX Subsection "\s-1CREATING\s0 \s-1THE\s0 \s-1HTML\s0 \s-1DOCUMENT\s0 \s-1HEADER\s0"

.IX Item "\fBParameters:\fR"

.IX Item "1."

.IX Item "2."

.IX Item "3."

.IX Item "4, 5, 6..."

.IX Subsection "\s-1ENDING\s0 \s-1THE\s0 \s-1HTML\s0 \s-1DOCUMENT\s0:"

.IX Subsection "\s-1CREATING\s0 A \s-1SELF\s0\-\s-1REFERENCING\s0 \s-1URL\s0 \s-1THAT\s0 \s-1PRESERVES\s0 \s-1STATE\s0 \s-1INFORMATION\s0:"

.IX Subsection "\s-1OBTAINING\s0 \s-1THE\s0 \s-1SCRIPT\s0'S \s-1URL\s0"

.IX Item "\fB\-absolute\fR"

.IX Item "\fB\-relative\fR"

.IX Item "\fB\-full\fR"

.IX Item "\fB\-path\fR (\fB\-path_info\fR)"

.IX Item "\fB\-query\fR (\fB\-query_string\fR)"

.IX Header "CREATING STANDARD HTML ELEMENTS:"

.IX Subsection "\s-1PROVIDING\s0 \s-1ARGUMENTS\s0 \s-1TO\s0 \s-1HTML\s0 \s-1SHORTCUTS\s0"

.IX Subsection "\s-1THE\s0 \s-1DISTRIBUTIVE\s0 \s-1PROPERTY\s0 \s-1OF\s0 \s-1HTML\s0 \s-1SHORTCUTS\s0"

.IX Subsection "\s-1HTML\s0 \s-1SHORTCUTS\s0 \s-1AND\s0 \s-1LIST\s0 \s-1INTERPOLATION\s0"

.IX Subsection "\s-1NON\s0\-\s-1STANDARD\s0 \s-1HTML\s0 \s-1SHORTCUTS\s0"

.IX Header "CREATING FILL\-OUT FORMS:"

.IX Subsection "\s-1CREATING\s0 \s-1AN\s0 \s-1ISINDEX\s0 \s-1TAG\s0"

.IX Subsection "\s-1STARTING\s0 \s-1AND\s0 \s-1ENDING\s0 A \s-1FORM\s0"

.IX Item "\fBapplication/x-www-form-urlencoded\fR"

.IX Item "\fBmultipart/form-data\fR"

.IX Subsection "\s-1CREATING\s0 A \s-1TEXT\s0 \s-1FIELD\s0"

.IX Item "\fBParameters\fR"

.IX Item "1."

.IX Item "2."

.IX Item "3."

.IX Item "4."

.IX Subsection "\s-1CREATING\s0 A \s-1BIG\s0 \s-1TEXT\s0 \s-1FIELD\s0"

.IX Subsection "\s-1CREATING\s0 A \s-1PASSWORD\s0 \s-1FIELD\s0"

.IX Subsection "\s-1CREATING\s0 A \s-1FILE\s0 \s-1UPLOAD\s0 \s-1FIELD\s0"

.IX Item "\fBParameters\fR"

.IX Item "1."

.IX Item "2."

.IX Item "3."

.IX Item "4."

.IX Subsection "\s-1CREATING\s0 A \s-1POPUP\s0 \s-1MENU\s0"

.IX Item "1."

.IX Item "2."

.IX Item "3."

.IX Item "4."

.IX Subsection "\s-1CREATING\s0 A \s-1SCROLLING\s0 \s-1LIST\s0"

.IX Item "\fBParameters:\fR"

.IX Item "1."

.IX Item "2."

.IX Item "3."

.IX Item "4."

.IX Item "5."

.IX Subsection "\s-1CREATING\s0 A \s-1GROUP\s0 \s-1OF\s0 \s-1RELATED\s0 \s-1CHECKBOXES\s0"

.IX Item "\fBParameters:\fR"

.IX Item "1."

.IX Item "2."

.IX Item "3."

.IX Item "4."

.IX Item "5."

.IX Subsection "\s-1CREATING\s0 A \s-1STANDALONE\s0 \s-1CHECKBOX\s0"

.IX Item "\fBParameters:\fR"

.IX Item "1."

.IX Item "2."

.IX Item "3."

.IX Item "4."

.IX Subsection "\s-1CREATING\s0 A \s-1RADIO\s0 \s-1BUTTON\s0 \s-1GROUP\s0"

.IX Item "\fBParameters:\fR"

.IX Item "1."

.IX Item "2."

.IX Item "3."

.IX Item "4."

.IX Item "5."

.IX Item "6."

.IX Subsection "\s-1CREATING\s0 A \s-1SUBMIT\s0 \s-1BUTTON\s0 "

.IX Item "\fBParameters:\fR"

.IX Item "1."

.IX Item "2."

.IX Subsection "\s-1CREATING\s0 A \s-1RESET\s0 \s-1BUTTON\s0"

.IX Subsection "\s-1CREATING\s0 A \s-1DEFAULT\s0 \s-1BUTTON\s0"

.IX Subsection "\s-1CREATING\s0 A \s-1HIDDEN\s0 \s-1FIELD\s0"

.IX Item "\fBParameters:\fR"

.IX Item "1."

.IX Item "2.  "

.IX Subsection "\s-1CREATING\s0 A \s-1CLICKABLE\s0 \s-1IMAGE\s0 \s-1BUTTON\s0"

.IX Item "\fBParameters:\fR"

.IX Item "1."

.IX Item "2."

.IX Item "3. The third option (\-align, optional) is an alignment type, and may be \s-1TOP\s0, \s-1BOTTOM\s0 or \s-1MIDDLE\s0"

.IX Subsection "\s-1CREATING\s0 A \s-1JAVASCRIPT\s0 \s-1ACTION\s0 \s-1BUTTON\s0"

.IX Header "NETSCAPE COOKIES"

.IX Item "1. an expiration time"

.IX Item "2. a domain"

.IX Item "3. a path"

.IX Item "4. a \*(N"secure\*(T" flag"

.IX Item "\fB\-name\fR"

.IX Item "\fB\-value\fR"

.IX Item "\fB\-path\fR"

.IX Item "\fB\-domain\fR"

.IX Item "\fB\-expires\fR"

.IX Item "\fB\-secure\fR"

.IX Header "WORKING WITH NETSCAPE FRAMES"

.IX Item "1. Create a <Frameset> document"

.IX Item "2. Specify the destination for the document in the \s-1HTTP\s0 header"

.IX Item "3. Specify the destination for the document in the <\s-1FORM\s0> tag"

.IX Header "LIMITED SUPPORT FOR CASCADING STYLE SHEETS"

.IX Header "DEBUGGING"

.IX Subsection "\s-1DUMPING\s0 \s-1OUT\s0 \s-1ALL\s0 \s-1THE\s0 \s-1NAME/VALUE\s0 \s-1PAIRS\s0"

.IX Header "FETCHING ENVIRONMENT VARIABLES"

.IX Item "\fBaccept()\fR"

.IX Item "\fBraw_cookie()\fR"

.IX Item "\fBuser_agent()\fR"

.IX Item "\fBpath_info()\fR"

.IX Item "\fBpath_translated()\fR"

.IX Item "\fBremote_host()\fR"

.IX Item "\fBscript_name()\fR Return the script name as a partial \s-1URL\s0, for self-refering scripts."

.IX Item "\fBreferer()\fR"

.IX Item "\fBauth_type ()\fR"

.IX Item "\fBserver_name ()\fR"

.IX Item "\fBvirtual_host ()\fR"

.IX Item "\fBserver_software ()\fR"

.IX Item "\fBremote_user ()\fR"

.IX Item "\fBuser_name ()\fR"

.IX Item "\fBrequest_method()\fR"

.IX Header "USING NPH SCRIPTS"

.IX Item "In the \fBuse\fR statement "

.IX Item "By calling the \fBnph()\fR method:"

.IX Item "By using \fB\-nph\fR parameters in the \fBheader()\fR and \fBredirect()\fR  statements:"

.IX Header "Server Push"

.IX Item "multipart_init()         multipart_init(\-boundary=>$boundary);"

.IX Item "multipart_start()"

.IX Item "multipart_end()"

.IX Header "Avoiding Denial of Service Attacks"

.IX Item "\fB$\s-1CGI::POST_MAX\s0\fR"

.IX Item "\fB$\s-1CGI::DISABLE_UPLOADS\s0\fR"

.IX Item "\fB1. On a script-by-script basis\fR"

.IX Item "\fB2. Globally for all scripts\fR"

.IX Header "COMPATIBILITY WITH CGI\-LIB.PL"

.IX Header "AUTHOR INFORMATION"

.IX Header "CREDITS"

.IX Item "Matt Heffron (heffron@falstaff.css.beckman.com)"

.IX Item "James Taylor (james.taylor@srs.gov)"

.IX Item "Scott Anguish <sanguish@digifix.com>"

.IX Item "Mike Jewell (mlj3u@virginia.edu)"

.IX Item "Timothy Shimmin (tes@kbs.citri.edu.au)"

.IX Item "Joergen Haegg (jh@axis.se)"

.IX Item "Laurent Delfosse (delfosse@csgrad1.cs.wvu.edu)"

.IX Item "Richard Resnick (applepi1@aol.com)"

.IX Item "Craig Bishop (csb@barwonwater.vic.gov.au)"

.IX Item "Tony Curtis (tc@vcpc.univie.ac.at)"

.IX Item "Tim Bunce (Tim.Bunce@ig.co.uk)"

.IX Item "Tom Christiansen (tchrist@convex.com)"

.IX Item "Andreas Koenig (k@franz.ww.\s-1TU\s0\-Berlin.\s-1DE\s0)"

.IX Item "Tim MacKenzie (Tim.MacKenzie@fulcrum.com.au)"

.IX Item "Kevin B. Hendricks (kbhend@dogwood.tyler.wm.edu)"

.IX Item "Stephen Dahmen (joyfire@inxpress.net)"

.IX Item "Ed Jordan (ed@fidalgo.net)"

.IX Item "David Alan Pisoni (david@cnation.com)"

.IX Item "Doug MacEachern (dougm@opengroup.org)"

.IX Item "Robin Houston (robin@oneworld.org)"

.IX Item "...and many many more..."

.IX Header "A COMPLETE EXAMPLE OF A SIMPLE FORM\-BASED SCRIPT"

.IX Header "BUGS"

.IX Header "SEE ALSO"

