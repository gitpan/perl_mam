.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH MD5 3 "perl 5.005, patch 53" "4/Nov/98" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Digest::MD5 \- Perl interface to the MD5 Algorithm
.SH "SYNOPSIS"
.PP
.Vb 2
\& # Functional style
\& use Digest::MD5  qw(md5 md5_hex md5_base64);
.Ve
.Vb 4
\& $digest = md5($data);
\& $digest = md5_hex($data);
\& $digest = md5_base64($data);
\&    
.Ve
.Vb 2
\& # OO style
\& use Digest::MD5;
.Ve
.Vb 1
\& $ctx = Digest::MD5->new;
.Ve
.Vb 2
\& $ctx->add($data);
\& $ctx->addfile(*FILE);
.Ve
.Vb 3
\& $digest = $ctx->digest;
\& $digest = $ctx->hexdigest;
\& $digest = $ctx->b64digest;
.Ve
.SH "DESCRIPTION"
The \f(CWDigest::MD5\fR module allows you to use the RSA Data Security
Inc. MD5 Message Digest algorithm from within Perl programs.  The
algorithm takes as input a message of arbitrary length and produces as
output a 128-bit \*(L"fingerprint\*(R" or \*(L"message digest\*(R" of the input.
.PP
The \f(CWDigest::MD5\fR module provide a procedural interface for simple
use, as well as an object oriented interface that can handle messages
of arbitrary length and which can read files directly.
.PP
A binary digest will be 16 bytes long.  A hex digest will be 32
characters long.  A base64 digest will be 22 characters long.
.SH "FUNCTIONS"
The following functions can be exported from the \f(CWDigest::MD5\fR
module.  No functions are exported by default.
.Ip "md5($data,...)" 4
This function will concatenate all arguments, calculate the \s-1MD5\s0 digest
of this \*(L"message\*(R", and return it in binary form.
.Ip "md5_hex($data,...)" 4
Same as \fImd5()\fR, but will return the digest in hexadecimal form.
.Ip "md5_base64($data,...)" 4
Same as \fImd5()\fR, but will return the digest as a base64 encoded string.
.SH "METHODS"
The following methods are available:
.Ip "$md5 = Digest::\s-1MD5\s0->new" 4
The constructor returns a new \f(CWDigest::MD5\fR object which encapsulate
the state of the \s-1MD5\s0 message-digest algorithm.  You can add data to
the object and finally ask for the digest.
.Sp
If called as a instance method (i.e. \f(CW$md5\fR\->new) it will just reset the
state the object to the state of a newly created object.  No new
object is created in this case.
.Ip "$md5->reset" 4
This is just an alias for \f(CW$md5\fR\->new.
.Ip "$md5->add($data,...)" 4
The \f(CW$data\fR provided as argument are appended to the message we
calculate the digest for.  The return value is the \f(CW$md5\fR object itself.
.Ip "$md5->addfile($io_handle)" 4
The \f(CW$io_handle\fR is read until \s-1EOF\s0 and the content is appended to the
message we calculate the digest for.  The return value is the \f(CW$md5\fR
object itself.
.Ip "$md5->digest" 4
Return the binary digest for the message.
.Sp
Note that the \f(CWdigest\fR operation is effectively a destructive,
read-once operation. Once it has been performed, the \f(CWDigest::MD5\fR
object is automatically \f(CWreset\fR and can be used to calculate another
digest value.
.Ip "$md5->hexdigest" 4
Same as \f(CW$md5\fR\->digest, but will return the digest in hexadecimal form.
.Ip "$md5->b64digest" 4
Same as \f(CW$md5\fR\->digest, but will return the digest as a base64 encoded
string.
.SH "EXAMPLES"
The simplest way to use this library is to import the \fImd5_hex()\fR
function (or one of its cousins):
.PP
.Vb 2
\&    use Digest::MD5 qw(md5_hex);
\&    print "Digest is ", md5_hex("foobarbaz"), "\en";
.Ve
The above example would print out the message
.PP
.Vb 1
\&    Digest is 6df23dc03f9b54cc38a0fc1483df6e21
.Ve
provided that the implementation is working correctly.  The same
checksum can also be calculated in OO style:
.PP
.Vb 8
\&    use Digest::MD5;
\&    
\&    $md5 = Digest::MD5->new;
\&    $md5->add('foo', 'bar');
\&    $md5->add('baz');
\&    $digest = $md5->digest();
\&    
\&    print "Digest is ", unpack("H*", $digest), "\en";
.Ve
With OO style you can break the message arbitrary.  This means that we
are no longer limited to have space for the whole message in memory.
We can handle messages of any size.
.PP
This is useful when calculating checksum for files:
.PP
.Vb 1
\&    use Digest::MD5;
.Ve
.Vb 3
\&    my $file = shift || "/etc/passwd";
\&    open(FILE, $file) or die "Can't open '$file': $!";
\&    binmode(FILE);
.Ve
.Vb 6
\&    $md5 = Digest::MD5->new;
\&    while (<FILE>) {
\&        $md5->add($_);
\&    }
\&    close(FILE);
\&    print $md5->b64digest, " $file\en";
.Ve
Or we can use the builtin addfile method to read the file much faster:
.PP
.Vb 1
\&    use Digest::MD5;
.Ve
.Vb 3
\&    my $file = shift || "/etc/passwd";
\&    open(FILE, $file) or die "Can't open '$file': $!";
\&    binmode(FILE);
.Ve
.Vb 1
\&    print Digest::MD5->new->addfile(*FILE)->hexdigest, " $file\en";
.Ve
.SH "SEE ALSO"
the \fIDigest\fR manpage,
the \fIDigest::MD2\fR manpage,
the \fIDigest::SHA1\fR manpage,
the \fIDigest::HMAC\fR manpage
.PP
the \fImd5sum(1)\fR manpage
.PP
RFC 1321
.SH "COPYRIGHT"
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
.Vb 3
\& Copyright 1998 Gisle Aas.
\& Copyright 1995-1996 Neil Winton.
\& Copyright 1991-1992 RSA Data Security, Inc.
.Ve
The MD5 algorithm is defined in RFC 1321. The basic C code
implementing the algorithm is derived from that in the RFC and is
covered by the following copyright:
.Ip "" 4
Copyright (C) 1991-2, \s-1RSA\s0 Data Security, Inc. Created 1991. All
rights reserved.
.Sp
License to copy and use this software is granted provided that it
is identified as the \*(L"\s-1RSA\s0 Data Security, Inc. \s-1MD5\s0 Message-Digest
Algorithm\*(R" in all material mentioning or referencing this software
or this function.
.Sp
License is also granted to make and use derivative works provided
that such works are identified as \*(L"derived from the \s-1RSA\s0 Data
Security, Inc. \s-1MD5\s0 Message-Digest Algorithm\*(R" in all material
mentioning or referencing the derived work.
.Sp
\s-1RSA\s0 Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided \*(L"as is\*(R"
without express or implied warranty of any kind.
.Sp
These notices must be retained in any copies of any part of this
documentation and/or software.
.PP
This copyright does not prohibit distribution of any version of Perl
containing this extension under the terms of the \s-1GNU\s0 or Artistic
licenses.
.SH "AUTHORS"
The original MD5 interface was written by Neil Winton
(\f(CWN.Winton@axion.bt.co.uk\fR).
.PP
This release was made by Gisle Aas <gisle@aas.no>

.rn }` ''
.IX Title "MD5 3"
.IX Name "Digest::MD5 - Perl interface to the MD5 Algorithm"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "FUNCTIONS"

.IX Item "md5($data,...)"

.IX Item "md5_hex($data,...)"

.IX Item "md5_base64($data,...)"

.IX Header "METHODS"

.IX Item "$md5 = Digest::\s-1MD5\s0->new"

.IX Item "$md5->reset"

.IX Item "$md5->add($data,...)"

.IX Item "$md5->addfile($io_handle)"

.IX Item "$md5->digest"

.IX Item "$md5->hexdigest"

.IX Item "$md5->b64digest"

.IX Header "EXAMPLES"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

.IX Item ""

.IX Header "AUTHORS"

