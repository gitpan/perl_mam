.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH READLINE 1 "perl 5.003, patch 05" "7/Jul/96" "User Contributed Perl Documentation"
.IX Title "READLINE 1"
.UC
.IX Name "Term::ReadLine - Perl interface to various C<readline> packages. If
no real package is found, substitutes stubs instead of basic functions."
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
Term::ReadLine \- Perl interface to various \f(CWreadline\fR packages. If
no real package is found, substitutes stubs instead of basic functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 10
\&  use Term::ReadLine;
\&  $term = new Term::ReadLine 'Simple Perl calc';
\&  $prompt = "Enter your arithmetic expression: ";
\&  $OUT = $term->OUT || STDOUT;
\&  while ( defined ($_ = $term->readline($prompt)) ) {
\&    $res = eval($_), "\en";
\&    warn $@ if $@;
\&    print $OUT $res, "\en" unless $@;
\&    $term->addhistory($_) if /\eS/;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Minimal set of supported functions"
.IX Subsection "Minimal set of supported functions"
All the supported functions should be called as methods, i.e., either as 
.PP
.Vb 1
\&  $term = new Term::ReadLine 'name';
.Ve
or as 
.PP
.Vb 1
\&  $term->addhistory('row');
.Ve
where \f(CW$term\fR is a return value of Term::ReadLine->Init.
.Ip "\f(CWReadLine\fR" 12
.IX Item "\f(CWReadLine\fR"
returns the actual package that executes the commands. Among possible
values are \f(CWTerm::ReadLine::Gnu\fR, \f(CWTerm::ReadLine::Perl\fR,
\f(CWTerm::ReadLine::Stub Exporter\fR.
.Ip "\f(CWnew\fR" 12
.IX Item "\f(CWnew\fR"
returns the handle for subsequent calls to following
functions. Argument is the name of the application. Optionally can be
followed by two arguments for \f(CWIN\fR and \f(CWOUT\fR filehandles. These
arguments should be globs.
.Ip "\f(CWreadline(prompt[, preput])\fR" 12
.IX Item "\f(CWreadline(prompt[, preput])\fR"
gets an input line, \fIpossibly\fR with actual \f(CWreadline\fR
support. Trailing newline is removed. Returns \f(CWundef\fR on \f(CWEOF\fR. \f(CWpreput\fR 
is an optional argument meaning the initial value of input. The optional
argument is granted only if the value \f(CWpreput\fR is in \f(CWFeatures\fR.
.Ip "\f(CWaddhistory(line1, line2, ...)\fR" 12
.IX Item "\f(CWaddhistory(line1, line2, ...)\fR"
adds the lines to the history of input, from where it can be used if
the actual \f(CWreadline\fR is present.
.Ip "\f(CWSetHistory(line1, line2, ...)\fR" 12
.IX Item "\f(CWSetHistory(line1, line2, ...)\fR"
sets the history of input, from where it can be used if
the actual \f(CWreadline\fR is present.
.Ip "\f(CWGetHistory\fR" 12
.IX Item "\f(CWGetHistory\fR"
returns the history of input as a list, if actual \f(CWreadline\fR is present.
.Ip "\f(CWIN\fR, \f(CWOUT\fR" 12
.IX Item "\f(CWIN\fR, \f(CWOUT\fR"
return the filehandles for input and output or \f(CWundef\fR if \f(CWreadline\fR
input and output cannot be used for Perl.
.Ip "\f(CWMinLine\fR" 12
.IX Item "\f(CWMinLine\fR"
If argument is specified, it is an advice on minimal size of line to
be included into history.  \f(CWundef\fR means do not include anything into
history. Returns the old value.
.Ip "\f(CWfindConsole\fR" 12
.IX Item "\f(CWfindConsole\fR"
returns an array with two strings that give most appropriate names for
files for input and output using conventions C<"<$in">, \f(CW">out"\fR.
.Ip "\f(CWFeatures\fR" 12
.IX Item "\f(CWFeatures\fR"
Returns a reference to a hash with keys being features present in
current implementation. Several optional features are used in the
minimal interface: \f(CWappname\fR should be present if the first argument
to \f(CWnew\fR is recognized, and \f(CWminline\fR should be present if
\f(CWMinLine\fR method is not dummy.  \f(CWautohistory\fR should be present if
lines are put into history automatically (maybe subject to
\f(CWMinLine\fR), and \f(CWaddhistory\fR if \f(CWaddhistory\fR method is not dummy. 
\f(CWpreput\fR means the second argument to \f(CWreadline\fR method is processed.
\f(CWgetHistory\fR and \f(CWsetHistory\fR denote that the corresponding methods are 
present. \f(CWtkRunning\fR denotes that a Tk application may run while ReadLine
is getting input \fB(undocumented feature)\fR.
.PP
Actually \f(CWTerm::ReadLine\fR can use some other package, that will
support reacher set of commands.
.SH "EXPORTS"
.IX Header "EXPORTS"
None

.rn }` ''
