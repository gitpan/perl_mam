.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH FileHandle 3 "perl 5.005, patch 53" "28/May/98" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
FileHandle \- supply object methods for filehandles
.SH "SYNOPSIS"
.PP
.Vb 1
\&    use FileHandle;
.Ve
.Vb 5
\&    $fh = new FileHandle;
\&    if ($fh->open("< file")) {
\&        print <$fh>;
\&        $fh->close;
\&    }
.Ve
.Vb 5
\&    $fh = new FileHandle "> FOO";
\&    if (defined $fh) {
\&        print $fh "bar\en";
\&        $fh->close;
\&    }
.Ve
.Vb 5
\&    $fh = new FileHandle "file", "r";
\&    if (defined $fh) {
\&        print <$fh>;
\&        undef $fh;       # automatically closes the file
\&    }
.Ve
.Vb 5
\&    $fh = new FileHandle "file", O_WRONLY|O_APPEND;
\&    if (defined $fh) {
\&        print $fh "corge\en";
\&        undef $fh;       # automatically closes the file
\&    }
.Ve
.Vb 2
\&    $pos = $fh->getpos;
\&    $fh->setpos($pos);
.Ve
.Vb 1
\&    $fh->setvbuf($buffer_var, _IOLBF, 1024);
.Ve
.Vb 1
\&    ($readfh, $writefh) = FileHandle::pipe;
.Ve
.Vb 1
\&    autoflush STDOUT 1;
.Ve
.SH "DESCRIPTION"
NOTE: This class is now a front-end to the IO::* classes.
.PP
\f(CWFileHandle::new\fR creates a \f(CWFileHandle\fR, which is a reference to a
newly created symbol (see the \f(CWSymbol\fR package).  If it receives any
parameters, they are passed to \f(CWFileHandle::open\fR; if the open fails,
the \f(CWFileHandle\fR object is destroyed.  Otherwise, it is returned to
the caller.
.PP
\f(CWFileHandle::new_from_fd\fR creates a \f(CWFileHandle\fR like \f(CWnew\fR does.
It requires two parameters, which are passed to \f(CWFileHandle::fdopen\fR;
if the fdopen fails, the \f(CWFileHandle\fR object is destroyed.
Otherwise, it is returned to the caller.
.PP
\f(CWFileHandle::open\fR accepts one parameter or two.  With one parameter,
it is just a front end for the built-in \f(CWopen\fR function.  With two
parameters, the first parameter is a filename that may include
whitespace or other special characters, and the second parameter is
the open mode, optionally followed by a file permission value.
.PP
If \f(CWFileHandle::open\fR receives a Perl mode string (">\*(R", \*(L"+<\*(R", etc.)
or a POSIX \fIfopen()\fR mode string ("w\*(R", \*(L"r+\*(R", etc.), it uses the basic
Perl \f(CWopen\fR operator.
.PP
If \f(CWFileHandle::open\fR is given a numeric mode, it passes that mode
and the optional permissions value to the Perl \f(CWsysopen\fR operator.
For convenience, \f(CWFileHandle::import\fR tries to import the O_XXX
constants from the Fcntl module.  If dynamic loading is not available,
this may fail, but the rest of FileHandle will still work.
.PP
\f(CWFileHandle::fdopen\fR is like \f(CWopen\fR except that its first parameter
is not a filename but rather a file handle name, a FileHandle object,
or a file descriptor number.
.PP
If the C functions \fIfgetpos()\fR and \fIfsetpos()\fR are available, then
\f(CWFileHandle::getpos\fR returns an opaque value that represents the
current position of the FileHandle, and \f(CWFileHandle::setpos\fR uses
that value to return to a previously visited position.
.PP
If the C function \fIsetvbuf()\fR is available, then \f(CWFileHandle::setvbuf\fR
sets the buffering policy for the FileHandle.  The calling sequence
for the Perl function is the same as its C counterpart, including the
macros \f(CW_IOFBF\fR, \f(CW_IOLBF\fR, and \f(CW_IONBF\fR, except that the buffer
parameter specifies a scalar variable to use as a buffer.  WARNING: A
variable used as a buffer by \f(CWFileHandle::setvbuf\fR must not be
modified in any way until the FileHandle is closed or until
\f(CWFileHandle::setvbuf\fR is called again, or memory corruption may
result!
.PP
See the \fIperlfunc\fR manpage for complete descriptions of each of the following
supported \f(CWFileHandle\fR methods, which are just front ends for the
corresponding built-in functions:
.PP
.Vb 8
\&    close
\&    fileno
\&    getc
\&    gets
\&    eof
\&    clearerr
\&    seek
\&    tell
.Ve
See the \fIperlvar\fR manpage for complete descriptions of each of the following
supported \f(CWFileHandle\fR methods:
.PP
.Vb 12
\&    autoflush
\&    output_field_separator
\&    output_record_separator
\&    input_record_separator
\&    input_line_number
\&    format_page_number
\&    format_lines_per_page
\&    format_lines_left
\&    format_name
\&    format_top_name
\&    format_line_break_characters
\&    format_formfeed
.Ve
Furthermore, for doing normal I/O you might need these:
.Ip "$fh->print" 5
See the \f(CWprint\fR entry in the \fIperlfunc\fR manpage.
.Ip "$fh->printf" 5
See the \f(CWprintf\fR entry in the \fIperlfunc\fR manpage.
.Ip "$fh->getline" 5
This works like <$fh> described in the section on \fII/O Operators\fR in the \fIperlop\fR manpage
except that it's more readable and can be safely called in an
array context but still returns just one line.
.Ip "$fh->getlines" 5
This works like <$fh> when called in an array context to
read all the remaining lines in a file, except that it's more readable.
It will also \fIcroak()\fR if accidentally called in a scalar context.
.PP
There are many other functions available since FileHandle is descended
from \s-1IO::\s0File, \s-1IO::\s0Seekable, and \s-1IO::\s0Handle.  Please see those
respective pages for documentation on more functions.
.SH "SEE ALSO"
The \fBIO\fR extension,
the \fIperlfunc\fR manpage, 
the section on \fII/O Operators\fR in the \fIperlop\fR manpage.

.rn }` ''
.IX Title "FileHandle 3"
.IX Name "FileHandle - supply object methods for filehandles"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "$fh->print"

.IX Item "$fh->printf"

.IX Item "$fh->getline"

.IX Item "$fh->getlines"

.IX Header "SEE ALSO"

