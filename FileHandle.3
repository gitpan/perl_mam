.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH FileHandle 3 "perl 5.003, patch 05" "4/Sep/96" "Perl Programmers Reference Guide"
.IX Title "FileHandle 3"
.UC
.IX Name "FileHandle - supply object methods for filehandles"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
FileHandle \- supply object methods for filehandles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 1
\&    use FileHandle;
.Ve
.Vb 5
\&    $fh = new FileHandle;
\&    if ($fh->open "< file") {
\&        print <$fh>;
\&        $fh->close;
\&    }
.Ve
.Vb 5
\&    $fh = new FileHandle "> FOO";
\&    if (defined $fh) {
\&        print $fh "bar\en";
\&        $fh->close;
\&    }
.Ve
.Vb 5
\&    $fh = new FileHandle "file", "r";
\&    if (defined $fh) {
\&        print <$fh>;
\&        undef $fh;       # automatically closes the file
\&    }
.Ve
.Vb 5
\&    $fh = new FileHandle "file", O_WRONLY|O_APPEND;
\&    if (defined $fh) {
\&        print $fh "corge\en";
\&        undef $fh;       # automatically closes the file
\&    }
.Ve
.Vb 2
\&    $pos = $fh->getpos;
\&    $fh->setpos $pos;
.Ve
.Vb 1
\&    $fh->setvbuf($buffer_var, _IOLBF, 1024);
.Ve
.Vb 1
\&    ($readfh, $writefh) = FileHandle::pipe;
.Ve
.Vb 1
\&    autoflush STDOUT 1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\f(CWFileHandle::new\fR creates a \f(CWFileHandle\fR, which is a reference to a
newly created symbol (see the \f(CWSymbol\fR package).  If it receives any
parameters, they are passed to \f(CWFileHandle::open\fR; if the open fails,
the \f(CWFileHandle\fR object is destroyed.  Otherwise, it is returned to
the caller.
.PP
\f(CWFileHandle::new_from_fd\fR creates a \f(CWFileHandle\fR like \f(CWnew\fR does.
It requires two parameters, which are passed to \f(CWFileHandle::fdopen\fR;
if the fdopen fails, the \f(CWFileHandle\fR object is destroyed.
Otherwise, it is returned to the caller.
.PP
\f(CWFileHandle::open\fR accepts one parameter or two.  With one parameter,
it is just a front end for the built-in \f(CWopen\fR function.  With two
parameters, the first parameter is a filename that may include
whitespace or other special characters, and the second parameter is
the open mode, optionally followed by a file permission value.
.PP
If \f(CWFileHandle::open\fR receives a Perl mode string (">\*(R", \*(L"+<\*(R", etc.)
or a POSIX \fIfopen()\fR mode string ("w\*(R", \*(L"r+\*(R", etc.), it uses the basic
Perl \f(CWopen\fR operator.
.PP
If \f(CWFileHandle::open\fR is given a numeric mode, it passes that mode
and the optional permissions value to the Perl \f(CWsysopen\fR operator.
For convenience, \f(CWFileHandle::import\fR tries to import the O_XXX
constants from the Fcntl module.  If dynamic loading is not available,
this may fail, but the rest of FileHandle will still work.
.PP
\f(CWFileHandle::fdopen\fR is like \f(CWopen\fR except that its first parameter
is not a filename but rather a file handle name, a FileHandle object,
or a file descriptor number.
.PP
If the C functions \fIfgetpos()\fR and \fIfsetpos()\fR are available, then
\f(CWFileHandle::getpos\fR returns an opaque value that represents the
current position of the FileHandle, and \f(CWFileHandle::setpos\fR uses
that value to return to a previously visited position.
.PP
If the C function \fIsetvbuf()\fR is available, then \f(CWFileHandle::setvbuf\fR
sets the buffering policy for the FileHandle.  The calling sequence
for the Perl function is the same as its C counterpart, including the
macros \f(CW_IOFBF\fR, \f(CW_IOLBF\fR, and \f(CW_IONBF\fR, except that the buffer
parameter specifies a scalar variable to use as a buffer.  WARNING: A
variable used as a buffer by \f(CWFileHandle::setvbuf\fR must not be
modified in any way until the FileHandle is closed or until
\f(CWFileHandle::setvbuf\fR is called again, or memory corruption may
result!
.PP
See the \fIperlfunc\fR manpage for complete descriptions of each of the following
supported \f(CWFileHandle\fR methods, which are just front ends for the
corresponding built-in functions:
  
    close
    fileno
    getc
    gets
    eof
    clearerr
    seek
    tell
.PP
See the \fIperlvar\fR manpage for complete descriptions of each of the following
supported \f(CWFileHandle\fR methods:
.PP
.Vb 12
\&    autoflush
\&    output_field_separator
\&    output_record_separator
\&    input_record_separator
\&    input_line_number
\&    format_page_number
\&    format_lines_per_page
\&    format_lines_left
\&    format_name
\&    format_top_name
\&    format_line_break_characters
\&    format_formfeed
.Ve
Furthermore, for doing normal I/O you might need these:
.Ip "$fh->print" 5
.IX Item "$fh->print"
See the \f(CWprint\fR entry in the \fIperlfunc\fR manpage.
.Ip "$fh->printf" 5
.IX Item "$fh->printf"
See the \f(CWprintf\fR entry in the \fIperlfunc\fR manpage.
.Ip "$fh->getline" 5
.IX Item "$fh->getline"
This works like <$fh> described in the section on \fII/O Operators\fR in the \fIperlop\fR manpage
except that it's more readable and can be safely called in an
array context but still returns just one line.
.Ip "$fh->getlines" 5
.IX Item "$fh->getlines"
This works like <$fh> when called in an array context to
read all the remaining lines in a file, except that it's more readable.
It will also \fIcroak()\fR if accidentally called in a scalar context.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the \fIperlfunc\fR manpage, 
the section on \fII/O Operators\fR in the \fIperlop\fR manpage,
the section on \fIFileHandle\fR in the \fIPOSIX\fR manpage
.SH "BUGS"
.IX Header "BUGS"
Due to backwards compatibility, all filehandles resemble objects
of class \f(CWFileHandle\fR, or actually classes derived from that class.
They actually aren't.  Which means you can't derive your own 
class from \f(CWFileHandle\fR and inherit those methods.

.rn }` ''
