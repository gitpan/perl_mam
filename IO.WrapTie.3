.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::IO::WrapTie 3 "perl 5.007, patch 00" "16/Aug/101" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
IO::WrapTie \- wrap tieable objects in IO::Handle interface
.PP
\fIThis is currently Alpha code, released for comments.  
  Please give me your feedback!\fR
.SH "SYNOPSIS"
First of all, you'll need \fItie()\fR, so:
.PP
.Vb 1
\&   require 5.004;
.Ve
\fIFunction interface (experimental).\fR
Use this with any existing class...
.PP
.Vb 2
\&   use IO::WrapTie;
\&   use FooHandle;                  ### implements TIEHANDLE interface
.Ve
.Vb 2
\&   ### Suppose we want a "FooHandle->new(&FOO_RDWR, 2)".
\&   ### We can instead say...
.Ve
.Vb 1
\&   $FH = wraptie('FooHandle', &FOO_RDWR, 2); 
.Ve
.Vb 3
\&   ### Now we can use...    
\&   print $FH "Hello, ";            ### traditional operator syntax...
\&   $FH->print("world!\en");         ### ...and OO syntax as well!
.Ve
\fIOO interface (preferred).\fR
You can inherit from the IO::WrapTie::Slave mixin to get a
nifty \f(CWnew_tie()\fR constructor...
.PP
.Vb 2
\&   #------------------------------    
\&   package FooHandle;                        ### a class which can TIEHANDLE
.Ve
.Vb 3
\&   use IO::WrapTie;  
\&   @ISA = qw(IO::WrapTie::Slave);            ### inherit new_tie()
\&   ...
.Ve
.Vb 2
\&   #------------------------------    
\&   package main; 
.Ve
.Vb 3
\&   $FH = FooHandle->new_tie(&FOO_RDWR, 2);   ### $FH is an IO::WrapTie::Master
\&   print $FH "Hello, ";                      ### traditional operator syntax
\&   $FH->print("world!\en");                   ### OO syntax
.Ve
See IO::Scalar as an example.  It also shows you how to create classes
which work both with and without 5.004.
.SH "DESCRIPTION"
Suppose you have a class \f(CWFooHandle\fR, where...
.Ip "\(bu" 4
\fBFooHandle does not inherit from \s-1IO::\s0Handle;\fR that is, it performs
filehandle-like I/O, but to something other than an underlying
file descriptor.  Good examples are \s-1IO::\s0Scalar (for printing to a
string) and \s-1IO::\s0Lines (for printing to an array of lines).
.Ip "\(bu" 4
\fBFooHandle implements the \s-1TIEHANDLE\s0 interface\fR (see the \fIperltie\fR manpage);
that is, it provides methods \s-1TIEHANDLE\s0, \s-1GETC\s0, \s-1PRINT\s0, \s-1PRINTF\s0,
\s-1READ\s0, and \s-1READLINE\s0.
.Ip "\(bu" 4
\fBFooHandle implements the traditional \s-1OO\s0 interface\fR of
FileHandle and \s-1IO::\s0Handle; i.e., it contains methods like \fIgetline()\fR, 
\fIread()\fR, \fIprint()\fR, \fIseek()\fR, \fItell()\fR, \fIeof()\fR, etc.
.PP
Normally, users of your class would have two options:
.Ip "\(bu" 4
\fBUse only \s-1OO\s0 syntax,\fR and forsake named I/O operators like \*(L'print\*(R'.
.Ip "\(bu " 4
\fBUse with tie,\fR and forsake treating it as a first-class object 
(i.e., class-specific methods can only be invoked through the underlying
object via \fItied()\fR... giving the object a \*(L"split personality").
.PP
But now with \s-1IO::\s0WrapTie, you can say:
.PP
.Vb 4
\&    $WT = wraptie('FooHandle', &FOO_RDWR, 2);
\&    $WT->print("Hello, world\en");   ### OO syntax
\&    print $WT "Yes!\en";             ### Named operator syntax too!
\&    $WT->weird_stuff;               ### Other methods!
.Ve
And if you're authoring a class like FooHandle, just have it inherit 
from \f(CWIO::WrapTie::Slave\fR and that first line becomes even prettier:
.PP
.Vb 1
\&    $WT = FooHandle->new_tie(&FOO_RDWR, 2);
.Ve
\fBThe bottom line:\fR now, almost any class can look and work exactly like
an \s-1IO::\s0Handle... and be used both with \s-1OO\s0 and non-\s-1OO\s0 filehandle syntax.
.SH "HOW IT ALL WORKS"
.Sh "The data structures"
Consider this example code, using classes in this distribution:
.PP
.Vb 2
\&    use IO::Scalar;
\&    use IO::WrapTie;
.Ve
.Vb 3
\&    $WT = wraptie('IO::Scalar',\e$s);
\&    print $WT "Hello, ";
\&    $WT->print("world!\en");
.Ve
In it, the \fIwraptie()\fR function creates a data structure as follows:
.PP
.Vb 24
\&                          * $WT is a blessed reference to a tied filehandle
\&              $WT           glob; that glob is tied to the "Slave" object.
\&               |          * You would do all your i/o with $WT directly.
\&               |       
\&               |
\&               |     ,---isa--> IO::WrapTie::Master >--isa--> IO::Handle
\&               V    /
\&        .-------------. 
\&        |             | 
\&        |             |   * Perl i/o operators work on the tied object,  
\&        |  "Master"   |     invoking the TIEHANDLE methods.
\&        |             |   * Method invocations are delegated to the tied 
\&        |             |     slave.
\&        `-------------' 
\&               |    
\&    tied(*$WT) |     .---isa--> IO::WrapTie::Slave
\&               V    /   
\&        .-------------.
\&        |             |
\&        |   "Slave"   |   * Instance of FileHandle-like class which doesn't
\&        |             |     actually use file descriptors, like IO::Scalar.
\&        |  IO::Scalar |   * The slave can be any kind of object.
\&        |             |   * Must implement the TIEHANDLE interface.
\&        `-------------'
.Ve
\fI\s-1NOTE\s0:\fR just as an \s-1IO::\s0Handle is really just a blessed reference to a 
\fItraditional\fR filehandle glob... so also, an \s-1IO::\s0WrapTie::Master 
is really just a blessed reference to a filehandle 
glob \fIwhich has been tied to some \*(L"slave\*(R" class.\fR
.Sh "How \fIwraptie()\fR works"
.Ip "1." 4
The call to function \f(CWwraptie(SLAVECLASS, TIEARGS...)\fR is 
passed onto \f(CWIO::WrapTie::Master::new()\fR.  
Note that class \s-1IO::\s0WrapTie::Master is a subclass of \s-1IO::\s0Handle.
.Ip "2." 4
The \f(CWIO::WrapTie::Master::new\fR method creates a new \s-1IO::\s0Handle object,
reblessed into class \s-1IO::\s0WrapTie::Master.  This object is the \fImaster\fR, 
which will be returned from the constructor.  At the same time...
.Ip "3." 4
The \f(CWnew\fR method also creates the \fIslave\fR: this is an instance 
of \s-1SLAVECLASS\s0 which is created by tying the master's \s-1IO::\s0Handle 
to \s-1SLAVECLASS\s0 via \f(CWtie(HANDLE, SLAVECLASS, TIEARGS...)\fR.  
This call to \f(CWtie()\fR creates the slave in the following manner:
.Ip "4." 4
Class \s-1SLAVECLASS\s0 is sent the message \f(CWTIEHANDLE(TIEARGS...)\fR; it 
will usually delegate this to \f(CWSLAVECLASS::new(TIEARGS...)\fR, resulting
in a new instance of \s-1SLAVECLASS\s0 being created and returned.
.Ip "5." 4
Once both master and slave have been created, the master is returned
to the caller.  
.Sh "How I/O operators work (on the master)"
Consider using an i/o operator on the master:
.PP
.Vb 1
\&    print $WT "Hello, world!\en";   
.Ve
Since the master ($\s-1WT\s0) is really a [blessed] reference to a glob, 
the normal Perl i/o operators like \f(CWprint\fR may be used on it.
They will just operate on the symbol part of the glob.
.PP
Since the glob is tied to the slave, the slave's \s-1PRINT\s0 method 
(part of the \s-1TIEHANDLE\s0 interface) will be automatically invoked.  
.PP
If the slave is an \s-1IO::\s0Scalar, that means \s-1IO::\s0Scalar::\s-1PRINT\s0 will be 
invoked, and that method happens to delegate to the \f(CWprint()\fR method 
of the same class.  So the \fIreal\fR work is ultimately done by 
\fI\s-1IO::\s0Scalar::print()\fR.
.Sh "How methods work (on the master)"
Consider using a method on the master:
.PP
.Vb 1
\&    $WT->print("Hello, world!\en");
.Ve
Since the master ($\s-1WT\s0) is blessed into the class \s-1IO::\s0WrapTie::Master,
Perl first attempts to find a \f(CWprint()\fR method there.  Failing that,
Perl next attempts to find a \f(CWprint()\fR method in the superclass,
\s-1IO::\s0Handle.  It just so happens that there \fIis\fR such a method;
that method merely invokes the \f(CWprint\fR i/o operator on the self object...
and for that, see above!
.PP
But let's suppose we're dealing with a method which \fIisn't\fR part
of \s-1IO::\s0Handle... for example:
.PP
.Vb 1
\&    my $sref = $WT->sref;
.Ve
In this case, the intuitive behavior is to have the master delegate the
method invocation to the slave (now do you see where the designations
come from?).  This is indeed what happens: \s-1IO::\s0WrapTie::Master contains
an \s-1AUTOLOAD\s0 method which performs the delegation.  
.PP
So: when \f(CWsref()\fR can't be found in \s-1IO::\s0Handle, the \s-1AUTOLOAD\s0 method
of \s-1IO::\s0WrapTie::Master is invoked, and the standard behavior of
delegating the method to the underlying slave (here, an \s-1IO::\s0Scalar)
is done.
.PP
Sometimes, to get this to work properly, you may need to create 
a subclass of \s-1IO::\s0WrapTie::Master which is an effective master for
\fIyour\fR class, and do the delegation there.
.SH "NOTES"
\fBWhy not simply use the object's OO interface?\fR 
    Because that means forsaking the use of named operators
like \fIprint()\fR, and you may need to pass the object to a subroutine
which will attempt to use those operators:
.PP
.Vb 2
\&    $O = FooHandle->new(&FOO_RDWR, 2);
\&    $O->print("Hello, world\en");  ### OO syntax is okay, BUT....
.Ve
.Vb 2
\&    sub nope { print $_[0] "Nope!\en" }
\& X  nope($O);                     ### ERROR!!! (not a glob ref)
.Ve
\fBWhy not simply use tie()?\fR 
    Because (1) you have to use \fItied()\fR to invoke methods in the
object's public interface (yuck), and (2) you may need to pass 
the tied symbol to another subroutine which will attempt to treat 
it in an OO\-way... and that will break it:
.PP
.Vb 2
\&    tie *T, 'FooHandle', &FOO_RDWR, 2; 
\&    print T "Hello, world\en";   ### Operator is okay, BUT... 
.Ve
.Vb 1
\&    tied(*T)->other_stuff;      ### yuck! AND...
.Ve
.Vb 2
\&    sub nope { shift->print("Nope!\en") }
\& X  nope(\e*T);                  ### ERROR!!! (method "print" on unblessed ref)
.Ve
\fBWhy a master and slave? 
  Why not simply write FooHandle to inherit from IO::Handle?\fR
    I tried this, with an implementation similar to that of IO::Socket.  
The problem is that \fIthe whole point is to use this with objects
that don't have an underlying file/socket descriptor.\fR.
Subclassing IO::Handle will work fine for the OO stuff, and fine with 
named operators \fIif\fR you \fItie()\fR... but if you just attempt to say:
.PP
.Vb 2
\&    $IO = FooHandle->new(&FOO_RDWR, 2);
\&    print $IO "Hello!\en";
.Ve
you get a warning from Perl like:
.PP
.Vb 1
\&    Filehandle GEN001 never opened
.Ve
because it's trying to do system-level i/o on an (unopened) file 
descriptor.  To avoid this, you apparently have to \fItie()\fR the handle...
which brings us right back to where we started!  At least the
IO::WrapTie mixin lets us say:
.PP
.Vb 2
\&    $IO = FooHandle->new_tie(&FOO_RDWR, 2);
\&    print $IO "Hello!\en";
.Ve
and so is not \fItoo\fR bad.  \f(CW:-)\fR
.SH "WARNINGS"
Remember: this stuff is for doing FileHandle-like i/o on things
\fIwithout underlying file descriptors\fR.  If you have an underlying
file descriptor, you're better off just inheriting from IO::Handle.
.PP
\fBBe aware that new_tie() always returns an instance of a
kind of IO::WrapTie::Master...\fR it does \fBnot\fR return an instance 
of the i/o class you're tying to!  
.PP
Invoking some methods on the master object causes AUTOLOAD to delegate
them to the slave object... so it \fIlooks\fR like you're manipulating a 
\*(L"FooHandle\*(R" object directly, but you're not.
.PP
I have not explored all the ramifications of this use of \fItie()\fR.
\fIHere there be dragons\fR.
.SH "VERSION"
$Id: WrapTie.pm,v 2.102 2001/08/17 02:06:33 eryq Exp $
.SH "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR).
President, ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).

.rn }` ''
.IX Title "lib::IO::WrapTie 3"
.IX Name "IO::WrapTie - wrap tieable objects in IO::Handle interface"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu "

.IX Header "HOW IT ALL WORKS"

.IX Subsection "The data structures"

.IX Subsection "How \fIwraptie()\fR works"

.IX Item "1."

.IX Item "2."

.IX Item "3."

.IX Item "4."

.IX Item "5."

.IX Subsection "How I/O operators work (on the master)"

.IX Subsection "How methods work (on the master)"

.IX Header "NOTES"

.IX Header "WARNINGS"

.IX Header "VERSION"

.IX Header "AUTHOR"

