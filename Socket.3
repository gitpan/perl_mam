.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Socket 3 "perl 5.005, patch 53" "29/Jun/98" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Socket, sockaddr_in, sockaddr_un, inet_aton, inet_ntoa \- load the C socket.h defines and structure manipulators 
.SH "SYNOPSIS"
.PP
.Vb 1
\&    use Socket;
.Ve
.Vb 6
\&    $proto = getprotobyname('udp');
\&    socket(Socket_Handle, PF_INET, SOCK_DGRAM, $proto);
\&    $iaddr = gethostbyname('hishost.com');
\&    $port = getservbyname('time', 'udp');
\&    $sin = sockaddr_in($port, $iaddr);
\&    send(Socket_Handle, 0, 0, $sin);
.Ve
.Vb 7
\&    $proto = getprotobyname('tcp');
\&    socket(Socket_Handle, PF_INET, SOCK_STREAM, $proto);
\&    $port = getservbyname('smtp', 'tcp');
\&    $sin = sockaddr_in($port,inet_aton("127.1"));
\&    $sin = sockaddr_in(7,inet_aton("localhost"));
\&    $sin = sockaddr_in(7,INADDR_LOOPBACK);
\&    connect(Socket_Handle,$sin);
.Ve
.Vb 3
\&    ($port, $iaddr) = sockaddr_in(getpeername(Socket_Handle));
\&    $peer_host = gethostbyaddr($iaddr, AF_INET);
\&    $peer_addr = inet_ntoa($iaddr);
.Ve
.Vb 5
\&    $proto = getprotobyname('tcp');
\&    socket(Socket_Handle, PF_UNIX, SOCK_STREAM, $proto);
\&    unlink('/tmp/usock');
\&    $sun = sockaddr_un('/tmp/usock');
\&    connect(Socket_Handle,$sun);
.Ve
.SH "DESCRIPTION"
This module is just a translation of the C \fIsocket.h\fR file.
Unlike the old mechanism of requiring a translated \fIsocket.ph\fR
file, this uses the \fBh2xs\fR program (see the Perl source distribution)
and your native C compiler.  This means that it has a 
far more likely chance of getting the numbers right.  This includes
all of the commonly used pound-defines like AF_INET, SOCK_STREAM, etc.
.PP
Also, some common socket \*(L"newline\*(R" constants are provided: the
constants \f(CWCR\fR, \f(CWLF\fR, and \f(CWCRLF\fR, as well as \f(CW$CR\fR, \f(CW$LF\fR, and
\f(CW$CRLF\fR, which map to \f(CW\e015\fR, \f(CW\e012\fR, and \f(CW\e015\e012\fR.  If you do
not want to use the literal characters in your programs, then use
the constants provided here.  They are not exported by default, but can
be imported individually, and with the \f(CW:crlf\fR export tag:
.PP
.Vb 1
\&    use Socket qw(:DEFAULT :crlf);
.Ve
In addition, some structure manipulation functions are available:
.Ip "inet_aton \s-1HOSTNAME\s0" 5
Takes a string giving the name of a host, and translates that
to the 4-byte string (structure). Takes arguments of both
the \*(L'rtfm.mit.edu\*(R' type and \*(L'18.181.0.24\*(R'. If the host name
cannot be resolved, returns undef. For multi-homed hosts (hosts
with more than one address), the first address found is returned.
.Ip "inet_ntoa \s-1IP_ADDRESS\s0" 5
Takes a four byte ip address (as returned by \fIinet_aton()\fR)
and translates it into a string of the form \*(L'd.d.d.d\*(R'
where the \*(L'd's are numbers less than 256 (the normal
readable four dotted number notation for internet addresses).
.Ip "\s-1INADDR_ANY\s0" 5
Note: does not return a number, but a packed string.
.Sp
Returns the 4-byte wildcard ip address which specifies any
of the hosts ip addresses. (A particular machine can have
more than one ip address, each address corresponding to
a particular network interface. This wildcard address
allows you to bind to all of them simultaneously.)
Normally equivalent to \fIinet_aton\fR\|('0.0.0.0').
.Ip "\s-1INADDR_BROADCAST\s0" 5
Note: does not return a number, but a packed string.
.Sp
Returns the 4-byte \*(L'this-lan\*(R' ip broadcast address.
This can be useful for some protocols to solicit information
from all servers on the same \s-1LAN\s0 cable.
Normally equivalent to \fIinet_aton\fR\|('255.255.255.255').
.Ip "\s-1INADDR_LOOPBACK\s0" 5
Note \- does not return a number.
.Sp
Returns the 4-byte loopback address. Normally equivalent
to \fIinet_aton\fR\|('localhost').
.Ip "\s-1INADDR_NONE\s0" 5
Note \- does not return a number.
.Sp
Returns the 4-byte \*(L'invalid\*(R' ip address. Normally equivalent
to \fIinet_aton\fR\|('255.255.255.255').
.Ip "sockaddr_in \s-1PORT\s0, \s-1ADDRESS\s0" 5
.Ip "sockaddr_in \s-1SOCKADDR_IN\s0" 5
In an array context, unpacks its \s-1SOCKADDR_IN\s0 argument and returns an array
consisting of (\s-1PORT\s0, \s-1ADDRESS\s0).  In a scalar context, packs its (\s-1PORT\s0,
\s-1ADDRESS\s0) arguments as a \s-1SOCKADDR_IN\s0 and returns it.  If this is confusing,
use \fIpack_sockaddr_in()\fR and \fIunpack_sockaddr_in()\fR explicitly.
.Ip "pack_sockaddr_in \s-1PORT\s0, \s-1IP_ADDRESS\s0" 5
Takes two arguments, a port number and a 4 byte \s-1IP_ADDRESS\s0 (as returned by
\fIinet_aton()\fR). Returns the sockaddr_in structure with those arguments
packed in with \s-1AF_INET\s0 filled in.  For internet domain sockets, this
structure is normally what you need for the arguments in \fIbind()\fR,
\fIconnect()\fR, and \fIsend()\fR, and is also returned by \fIgetpeername()\fR,
\fIgetsockname()\fR and \fIrecv()\fR.
.Ip "unpack_sockaddr_in \s-1SOCKADDR_IN\s0" 5
Takes a sockaddr_in structure (as returned by \fIpack_sockaddr_in()\fR) and
returns an array of two elements: the port and the 4-byte ip-address.
Will croak if the structure does not have \s-1AF_INET\s0 in the right place.
.Ip "sockaddr_un \s-1PATHNAME\s0" 5
.Ip "sockaddr_un \s-1SOCKADDR_UN\s0" 5
In an array context, unpacks its \s-1SOCKADDR_UN\s0 argument and returns an array
consisting of (\s-1PATHNAME\s0).  In a scalar context, packs its \s-1PATHNAME\s0
arguments as a \s-1SOCKADDR_UN\s0 and returns it.  If this is confusing, use
\fIpack_sockaddr_un()\fR and \fIunpack_sockaddr_un()\fR explicitly.
These are only supported if your system has <\fIsys/un.h\fR>.
.Ip "pack_sockaddr_un \s-1PATH\s0" 5
Takes one argument, a pathname. Returns the sockaddr_un structure with
that path packed in with \s-1AF_UNIX\s0 filled in. For unix domain sockets, this
structure is normally what you need for the arguments in \fIbind()\fR,
\fIconnect()\fR, and \fIsend()\fR, and is also returned by \fIgetpeername()\fR,
\fIgetsockname()\fR and \fIrecv()\fR.
.Ip "unpack_sockaddr_un \s-1SOCKADDR_UN\s0" 5
Takes a sockaddr_un structure (as returned by \fIpack_sockaddr_un()\fR)
and returns the pathname.  Will croak if the structure does not
have \s-1AF_UNIX\s0 in the right place.

.rn }` ''
.IX Title "Socket 3"
.IX Name "Socket, sockaddr_in, sockaddr_un, inet_aton, inet_ntoa - load the C socket.h defines and structure manipulators"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "inet_aton \s-1HOSTNAME\s0"

.IX Item "inet_ntoa \s-1IP_ADDRESS\s0"

.IX Item "\s-1INADDR_ANY\s0"

.IX Item "\s-1INADDR_BROADCAST\s0"

.IX Item "\s-1INADDR_LOOPBACK\s0"

.IX Item "\s-1INADDR_NONE\s0"

.IX Item "sockaddr_in \s-1PORT\s0, \s-1ADDRESS\s0"

.IX Item "sockaddr_in \s-1SOCKADDR_IN\s0"

.IX Item "pack_sockaddr_in \s-1PORT\s0, \s-1IP_ADDRESS\s0"

.IX Item "unpack_sockaddr_in \s-1SOCKADDR_IN\s0"

.IX Item "sockaddr_un \s-1PATHNAME\s0"

.IX Item "sockaddr_un \s-1SOCKADDR_UN\s0"

.IX Item "pack_sockaddr_un \s-1PATH\s0"

.IX Item "unpack_sockaddr_un \s-1SOCKADDR_UN\s0"

