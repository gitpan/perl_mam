.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::XML::Handler::XMLWriter 3 "perl 5.007, patch 00" "22/Feb/100" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
XML::Handler::XMLWriter \- a PerlSAX handler for writing readable XML
.SH "SYNOPSIS"
.PP
.Vb 2
\& use XML::Parser::PerlSAX;
\& use XML::Handler::XMLWriter;
.Ve
.Vb 1
\& $my_handler = XML::Handler::XMLWriter->new( I<OPTIONS> );
.Ve
.Vb 2
\& XML::Parser::PerlSAX->new->parse(Source => { SystemId => 'REC-xml-19980210.xml' },
\&                                  Handler => $my_handler);
.Ve
.SH "DESCRIPTION"
\f(CWXML::Handler::XMLWriter\fR is a PerlSAX handler for writing readable
XML (in contrast to Canonical XML, for example).
XML::Handler::XMLWriter can be used with a parser to reformat XML,
with XML::DOM or XML::Grove to write out XML, or with other PerlSAX
modules that generate events.
.PP
\f(CWXML::Handler::XMLWriter\fR is intended to be used with PerlSAX event
generators and does not perform any checking itself (for example,
matching start and end element events).  If you want to generate XML
directly from your Perl code, use the XML::Writer module.  XML::Writer
has an easy to use interface and performs many checks to make sure
that the XML you generate is well-formed.
.PP
\f(CWXML::Handler::XMLWriter\fR is a subclass of \f(CWXML::Handler::Subs\fR.
\f(CWXML::Handler::XMLWriter\fR can be further subclassed to alter it's
behavior or to add element-specific handling.  In the subclass, each
time an element starts, a method by that name prefixed with `s_\*(R' is
called with the element to be processed.  Each time an element ends, a
method with that name prefixed with `e_\*(R' is called.  Any special
characters in the element name are replaced by underscores.  If there
isn't a start or end method for an element, the default action is to
write the start or end tag.  Start and end methods can use the
`\f(CWprint_start_element()\fR\*(R' and `\f(CWprint_end_element()\fR\*(R' methods to
print start or end tags.  Subclasses can call the `\f(CWprint()\fR\*(R' method
to write additional output.
.PP
Subclassing XML::Handler::XMLWriter in this way is similar to
XML::Parser's Stream style.
.PP
XML::Handler::Subs maintains a stack of element names,
`\f(CW$self-\fR{Names}\*(R', and a stack of element nodes, `\f(CW$self-\fR{Nodes}>\*(R'
that can be used by subclasses.  The current element is pushed on the
stacks before calling an element-name start method and popped off the
stacks after calling the element-name end method.
.PP
See XML::Handler::Subs for additional methods.
.PP
In addition to the standard PerlSAX handler methods (see PerlSAX for
descriptions), XML::Handler::XMLWriter supports the following methods:
.Ip "new( \fI\s-1OPTIONS\s0\fR )" 4
Creates and returns a new instance of \s-1XML::\s0Handler::XMLWriter with the
given \fI\s-1OPTIONS\s0\fR.  Options may be changed at any time by modifying
them directly in the hash returned.  \fI\s-1OPTIONS\s0\fR can be a list of key,
value pairs or a hash.  The following \fI\s-1OPTIONS\s0\fR are supported:
.Ip "Output" 8
An \s-1IO::\s0Handle or one of it's subclasses (such as \s-1IO::\s0File), if this
parameter is not present and the AsString option is not used, the
module will write to standard output.
.Ip "AsString" 8
Return the generated \s-1XML\s0 as a string from the `\f(CWparse()\fR\*(R' method of
the PerlSAX event generator.
.Ip "Newlines" 8
A true or false value; if this parameter is present and its value is
true, then the module will insert an extra newline before the closing
delimiter of start, end, and empty tags to guarantee that the document
does not end up as a single, long line.  If the paramter is not
present, the module will not insert the newlines.
.Ip "IsSGML" 8
A true or false value; if this parameter is present and its value is
true, then the module will generate \s-1SGML\s0 rather than \s-1XML\s0.
.Ip "print_start_element($element)" 4
Print a start tag for `\f(CW$element\fR\*(R'.  This is the default action for
the PerlSAX `\f(CWstart_element()\fR\*(R' handler, but subclasses may use this
if they define a start method for an element.
.Ip "print_end_element($element)" 4
Prints an end tag for `\f(CW$element\fR\*(R'.  This is the default action for
the PerlSAX `\f(CWend_element()\fR\*(R' handler, but subclasses may use this
if they define a start method for an element.
.Ip "print($output)" 4
Write `\f(CW$output\fR\*(R' to Output and/or append it to the string to be
returned.  Subclasses may use this to write additional output.
.SH "TODO"
.Ip "\(bu" 4
An Elements option that provides finer control over newlines than the
Newlines option, where you can choose before and after newline for
element start and end tags.  Inspired by the Python XMLWriter.
.Ip "\(bu" 4
Support Doctype and \s-1XML\s0 declarations.
.SH "AUTHOR"
Ken MacLeod, ken@bitsko.slc.ut.us
This module is partially derived from XML::Writer by David Megginson.
.SH "SEE ALSO"
\fIperl\fR\|(1), PerlSAX.\fIpod\fR\|(3)

.rn }` ''
.IX Title "lib::XML::Handler::XMLWriter 3"
.IX Name "XML::Handler::XMLWriter - a PerlSAX handler for writing readable XML"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "new( \fI\s-1OPTIONS\s0\fR )"

.IX Item "Output"

.IX Item "AsString"

.IX Item "Newlines"

.IX Item "IsSGML"

.IX Item "print_start_element($element)"

.IX Item "print_end_element($element)"

.IX Item "print($output)"

.IX Header "TODO"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "AUTHOR"

.IX Header "SEE ALSO"

