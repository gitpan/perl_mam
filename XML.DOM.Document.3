.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH DOCUMENT 1 "perl 5.007, patch 00" "26/Aug/101" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
XML::DOM::Document \- An XML document node in XML::DOM
.SH "DESCRIPTION"
XML::DOM::Document extends the \fIXML::DOM::Node\fR manpage.
.PP
It is the main root of the XML document structure as returned by 
XML::DOM::Parser::parse and XML::DOM::Parser::parsefile.
.PP
Since elements, text nodes, comments, processing instructions, etc.
cannot exist outside the context of a Document, the Document interface
also contains the factory methods needed to create these objects. The
Node objects created have a getOwnerDocument method which associates
them with the Document within whose context they were created.
.Sh "\s-1METHODS\s0"
.Ip "getDocumentElement" 4
This is a convenience method that allows direct access to
the child node that is the root Element of the document.
.Ip "getDoctype" 4
The Document Type Declaration (see DocumentType) associated
with this document. For \s-1HTML\s0 documents as well as \s-1XML\s0
documents without a document type declaration this returns
undef. The \s-1DOM\s0 Level 1 does not support editing the Document
Type Declaration.
.Sp
\fBNot In \s-1DOM\s0 Spec\fR: This implementation allows editing the doctype. 
See \fI\s-1XML::DOM::\s0ignoreReadOnly\fR for details.
.Ip "getImplementation" 4
The DOMImplementation object that handles this document. A
\s-1DOM\s0 application may use objects from multiple implementations.
.Ip "createElement (tagName)" 4
Creates an element of the type specified. Note that the
instance returned implements the Element interface, so
attributes can be specified directly on the returned object.
.Sp
DOMExceptions:
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 8
Raised if the tagName does not conform to the \s-1XML\s0 spec.
.Ip "createTextNode (data)" 4
Creates a Text node given the specified string.
.Ip "createComment (data)" 4
Creates a Comment node given the specified string.
.Ip "createCDATASection (data)" 4
Creates a CDATASection node given the specified string.
.Ip "createAttribute (name [, value [, specified ]])" 4
Creates an Attr of the given name. Note that the Attr
instance can then be set on an Element using the setAttribute method.
.Sp
\fBNot In \s-1DOM\s0 Spec\fR: The \s-1DOM\s0 Spec does not allow passing the value or the 
specified property in this method. In this implementation they are optional.
.Sp
Parameters:
 \fIvalue\fR     The attribute's value. See Attr::setValue for details.
              If the value is not supplied, the specified property is set to 0.
 \fIspecified\fR Whether the attribute value was specified or whether the default
              value was used. If not supplied, it's assumed to be 1.
.Sp
DOMExceptions:
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 8
Raised if the name does not conform to the \s-1XML\s0 spec.
.Ip "createProcessingInstruction (target, data)" 4
Creates a ProcessingInstruction node given the specified name and data strings.
.Sp
Parameters:
 \fItarget\fR  The target part of the processing instruction.
 \fIdata\fR    The data for the node.
.Sp
DOMExceptions:
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 8
Raised if the target does not conform to the \s-1XML\s0 spec.
.Ip "createDocumentFragment" 4
Creates an empty DocumentFragment object.
.Ip "createEntityReference (name)" 4
Creates an EntityReference object.
.Sh "Additional methods not in the \s-1DOM\s0 Spec"
.Ip "getXMLDecl and setXMLDecl (xmlDecl)" 4
Returns the XMLDecl for this Document or undef if none was specified.
Note that XMLDecl is not part of the list of child nodes.
.Ip "setDoctype (doctype)" 4
Sets or replaces the DocumentType. 
\fB\s-1NOTE\s0\fR: Don't use appendChild or insertBefore to set the DocumentType.
Even though doctype will be part of the list of child nodes, it is handled
specially.
.Ip "getDefaultAttrValue (elem, attr)" 4
Returns the default attribute value as a string or undef, if none is available.
.Sp
Parameters:
 \fIelem\fR    The element tagName.
 \fIattr\fR    The attribute name.
.Ip "getEntity (name)" 4
Returns the Entity with the specified name.
.Ip "createXMLDecl (version, encoding, standalone)" 4
Creates an XMLDecl object. All parameters may be undefined.
.Ip "createDocumentType (name, sysId, pubId)" 4
Creates a DocumentType object. SysId and pubId may be undefined.
.Ip "createNotation (name, base, sysId, pubId)" 4
Creates a new Notation object. Consider using 
\s-1XML::DOM::\s0DocumentType::addNotation!
.Ip "createEntity (parameter, notationName, value, sysId, pubId, ndata)" 4
Creates an Entity object. Consider using \s-1XML::DOM::\s0DocumentType::addEntity!
.Ip "createElementDecl (name, model)" 4
Creates an ElementDecl object.
.Sp
DOMExceptions:
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 8
Raised if the element name (tagName) does not conform to the \s-1XML\s0 spec.
.Ip "createAttlistDecl (name)" 4
Creates an AttlistDecl object.
.Sp
DOMExceptions:
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 8
Raised if the element name (tagName) does not conform to the \s-1XML\s0 spec.
.Ip "expandEntity (entity [, parameter])" 4
Expands the specified entity or parameter entity (if parameter=1) and returns
its value as a string, or undef if the entity does not exist.
(The entity name should not contain the \*(L'%\*(R', \*(L'&\*(R' or \*(L';\*(R' delimiters.)
.Ip "check ( [$checker] )" 4
Uses the specified the \fI\s-1XML::\s0Checker\fR manpage to validate the document.
If no \s-1XML::\s0Checker is supplied, a new \s-1XML::\s0Checker is created.
See the \fI\s-1XML::\s0Checker\fR manpage for details.
.Ip "check_sax ( [$checker] )" 4
Similar to \fIcheck()\fR except it uses the \s-1SAX\s0 interface to \s-1XML::\s0Checker instead of 
the expat interface. This method may disappear or replace \fIcheck()\fR at some time.
.Ip "createChecker ()" 4
Creates an \s-1XML::\s0Checker based on the document's \s-1DTD\s0.
The \f(CW$checker\fR can be reused to check any elements within the document.
Create a new the \fI\s-1XML::\s0Checker\fR manpage whenever the \s-1DOCTYPE\s0 section of the document 
is altered!

.rn }` ''
.IX Title "DOCUMENT 1"
.IX Name "XML::DOM::Document - An XML document node in XML::DOM"

.IX Header "NAME"

.IX Header "DESCRIPTION"

.IX Subsection "\s-1METHODS\s0"

.IX Item "getDocumentElement"

.IX Item "getDoctype"

.IX Item "getImplementation"

.IX Item "createElement (tagName)"

.IX Item "\(bu \s-1INVALID_CHARACTER_ERR\s0"

.IX Item "createTextNode (data)"

.IX Item "createComment (data)"

.IX Item "createCDATASection (data)"

.IX Item "createAttribute (name [, value [, specified ]])"

.IX Item "\(bu \s-1INVALID_CHARACTER_ERR\s0"

.IX Item "createProcessingInstruction (target, data)"

.IX Item "\(bu \s-1INVALID_CHARACTER_ERR\s0"

.IX Item "createDocumentFragment"

.IX Item "createEntityReference (name)"

.IX Subsection "Additional methods not in the \s-1DOM\s0 Spec"

.IX Item "getXMLDecl and setXMLDecl (xmlDecl)"

.IX Item "setDoctype (doctype)"

.IX Item "getDefaultAttrValue (elem, attr)"

.IX Item "getEntity (name)"

.IX Item "createXMLDecl (version, encoding, standalone)"

.IX Item "createDocumentType (name, sysId, pubId)"

.IX Item "createNotation (name, base, sysId, pubId)"

.IX Item "createEntity (parameter, notationName, value, sysId, pubId, ndata)"

.IX Item "createElementDecl (name, model)"

.IX Item "\(bu \s-1INVALID_CHARACTER_ERR\s0"

.IX Item "createAttlistDecl (name)"

.IX Item "\(bu \s-1INVALID_CHARACTER_ERR\s0"

.IX Item "expandEntity (entity [, parameter])"

.IX Item "check ( [$checker] )"

.IX Item "check_sax ( [$checker] )"

.IX Item "createChecker ()"

