.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH OS2::REXX 3 "perl 5.003, patch 93" "13/Mar/97" "Perl Programmers Reference Guide"
.IX Title "OS2::REXX 3"
.UC
.IX Name "OS2::REXX - access to DLLs with REXX calling convention and REXX runtime."
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
OS2::REXX \- access to DLLs with REXX calling convention and REXX runtime.
.Sh "\s-1NOTE\s0"
.IX Subsection "\s-1NOTE\s0"
By default, the \s-1REXX\s0 variable pool is not available, neither
to Perl, nor to external \s-1REXX\s0 functions. To enable it, you need to put
your code inside \f(CWREXX_call\fR function.  \s-1REXX\s0 functions which do not use
variables may be usable even without \f(CWREXX_call\fR though.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 7
\&        use OS2::REXX;
\&        $ydb = load OS2::REXX "ydbautil" or die "Cannot load: $!";
\&        @pid = $ydb->RxProcId();
\&        REXX_call {
\&          tie $s, OS2::REXX, "TEST";
\&          $s = 1;
\&        };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Load \s-1REXX\s0 \s-1DLL\s0"
.IX Subsection "Load \s-1REXX\s0 \s-1DLL\s0"
.PP
.Vb 1
\&        $dll = load OS2::REXX NAME [, WHERE];
.Ve
\s-1NAME\s0 is \s-1DLL\s0 name, without path and extension.
.PP
Directories are searched \s-1WHERE\s0 first (list of dirs), then environment
paths \s-1PERL5REXX\s0, \s-1PERLREXX\s0 or, as last resort, \s-1PATH\s0.
.PP
The \s-1DLL\s0 is not unloaded when the variable dies.
.PP
Returns \s-1DLL\s0 object reference, or undef on failure.
.Sh "Define function prefix:"
.IX Subsection "Define function prefix:"
.PP
.Vb 1
\&        $dll->prefix(NAME);
.Ve
Define the prefix of external functions, prepended to the function
names used within your program, when looking for the entries in the
\s-1DLL\s0.
.Sh "Example"
.IX Subsection "Example"
.PP
.Vb 3
\&                $dll = load OS2::REXX "RexxBase";
\&                $dll->prefix("RexxBase_");
\&                $dll->Init();
.Ve
is the same as
.PP
.Vb 2
\&                $dll = load OS2::REXX "RexxBase";
\&                $dll->RexxBase_Init();
.Ve
.Sh "Define queue:"
.IX Subsection "Define queue:"
.PP
.Vb 1
\&        $dll->queue(NAME);
.Ve
Define the name of the \s-1REXX\s0 queue passed to all external
functions of this module. Defaults to \*(L"\s-1SESSION\s0\*(R".
.PP
Check for functions (optional):
.PP
.Vb 1
\&        BOOL = $dll->find(NAME [, NAME [, ...]]);
.Ve
Returns true if all functions are available.
.Sh "Call external \s-1REXX\s0 function:"
.IX Subsection "Call external \s-1REXX\s0 function:"
.PP
.Vb 1
\&        $dll->function(arguments);
.Ve
Returns the return string if the return code is 0, else undef.
Dies with error message if the function is not available.
.SH "Accessing REXX\-runtime"
.IX Header "Accessing REXX\-runtime"
While calling functions with REXX signature does not require the presence
of the system REXX DLL, there are some actions which require REXX\-runtime 
present. Among them is the access to REXX variables by name.
.PP
One enables REXX runtime by bracketing your code by
.PP
.Vb 1
\&        REXX_call BLOCK;
.Ve
(trailing semicolon required!) or
.PP
.Vb 1
\&        REXX_call \e&subroutine_name;
.Ve
Inside such a call one has access to REXX variables (see below), and to
.PP
.Vb 3
\&        REXX_eval EXPR;
\&        REXX_eval_with EXPR, 
\&                subroutine_name_in_REXX => \e&Perl_subroutine
.Ve
.Sh "Bind scalar variable to \s-1REXX\s0 variable:"
.IX Subsection "Bind scalar variable to \s-1REXX\s0 variable:"
.PP
.Vb 1
\&        tie $var, OS2::REXX, "NAME";
.Ve
.Sh "Bind array variable to \s-1REXX\s0 stem variable:"
.IX Subsection "Bind array variable to \s-1REXX\s0 stem variable:"
.PP
.Vb 1
\&        tie @var, OS2::REXX, "NAME.";
.Ve
Only scalar operations work so far. No array assignments, no array
operations, ... \s-1FORGET\s0 \s-1IT\s0.
.Sh "Bind hash array variable to \s-1REXX\s0 stem variable:"
.IX Subsection "Bind hash array variable to \s-1REXX\s0 stem variable:"
.PP
.Vb 1
\&        tie %var, OS2::REXX, "NAME.";
.Ve
To access all visible \s-1REXX\s0 variables via hash array, bind to "";
.PP
No array assignments. No array operations, other than hash array
operations. Just like the *dbm based implementations.
.PP
For the usual \s-1REXX\s0 stem variables, append a "." to the name,
as shown above. If the hash key is part of the stem name, for
example if you bind to "", you cannot use lower case in the stem
part of the key and it is subject to character set restrictions.
.Sh "Erase individual \s-1REXX\s0 variables (bound or not):"
.IX Subsection "Erase individual \s-1REXX\s0 variables (bound or not):"
.PP
.Vb 1
\&        OS2::REXX::drop("NAME" [, "NAME" [, ...]]);
.Ve
.Sh "Erase \s-1REXX\s0 variables with given stem (bound or not):"
.IX Subsection "Erase \s-1REXX\s0 variables with given stem (bound or not):"
.PP
.Vb 1
\&        OS2::REXX::dropall("STEM" [, "STEM" [, ...]]);
.Ve
.SH "NOTES"
.IX Header "NOTES"
Note that while function and variable names are case insensitive in the
REXX language, function names exported by a DLL and the REXX variables
(as seen by Perl through the chosen API) are all case sensitive!
.PP
Most REXX DLLs export function names all upper case, but there are a
few which export mixed case names (such as RxExtras). When trying to
find the entry point, both exact case and all upper case are searched.
If the DLL exports \*(L"RxNap\*(R", you have to specify the exact case, if it
exports \*(L"RXOPEN\*(R", you can use any case.
.PP
To avoid interfering with subroutine names defined by Perl (DESTROY)
or used within the REXX module (prefix, find), it is best to use mixed
case and to avoid lowercase only or uppercase only names when calling
REXX functions. Be consistent. The same function written in different
ways results in different Perl stubs.
.PP
There is no REXX interpolation on variable names, so the REXX variable
name TEST.ONE is not affected by some other REXX variable ONE. And it
is not the same variable as TEST.one!
.PP
You cannot call REXX functions which are not exported by the DLL.
While most DLLs export all their functions, some, like RxFTP, export
only \*(L"...LoadFuncs\*(R", which registers the functions within REXX only.
.PP
You cannot call 16-bit DLLs. The few interesting ones I found
(FTP,NETB,APPC) do not export their functions.
.PP
I do not know whether the REXX API is reentrant with respect to
exceptions (signals) when the REXX top-level exception handler is
overridden. So unless you know better than I do, do not access REXX
variables (probably tied to Perl variables) or call REXX functions
which access REXX queues or REXX variables in signal handlers.
.PP
See \f(CWt/rx*.t\fR for examples.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andreas Kaiser ak@ananke.s.bawue.de, with additions by Ilya Zakharevich
ilya@math.ohio-state.edu.

.rn }` ''
