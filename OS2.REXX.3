.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OS2::REXX 3"
.TH OS2::REXX 3 "2003-09-30" "perl v5.8.2" "Perl Programmers Reference Guide"
.SH "NAME"
OS2::REXX \- access to DLLs with REXX calling convention and REXX runtime.
.Sh "NOTE"
.IX Subsection "NOTE"
By default, the REXX variable pool is not available, neither
to Perl, nor to external REXX functions. To enable it, you need to put
your code inside \f(CW\*(C`REXX_call\*(C'\fR function.  REXX functions which do not use
variables may be usable even without \f(CW\*(C`REXX_call\*(C'\fR though.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&        use OS2::REXX;
\&        $ydb = load OS2::REXX "ydbautil" or die "Cannot load: $!";
\&        @pid = $ydb->RxProcId();
\&        REXX_call {
\&          tie $s, OS2::REXX, "TEST";
\&          $s = 1;
\&        };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Load \s-1REXX\s0 \s-1DLL\s0"
.IX Subsection "Load REXX DLL"
.Vb 1
\&        $dll = load OS2::REXX NAME [, WHERE];
.Ve
.PP
\&\s-1NAME\s0 is \s-1DLL\s0 name, without path and extension.
.PP
Directories are searched \s-1WHERE\s0 first (list of dirs), then environment
paths \s-1PERL5REXX\s0, \s-1PERLREXX\s0, \s-1PATH\s0 or, as last resort, OS/2\-ish search 
is performed in default \s-1DLL\s0 path (without adding paths and extensions).
.PP
The \s-1DLL\s0 is not unloaded when the variable dies.
.PP
Returns \s-1DLL\s0 object reference, or undef on failure.
.Sh "Define function prefix:"
.IX Subsection "Define function prefix:"
.Vb 1
\&        $dll->prefix(NAME);
.Ve
.PP
Define the prefix of external functions, prepended to the function
names used within your program, when looking for the entries in the
\&\s-1DLL\s0.
.Sh "Example"
.IX Subsection "Example"
.Vb 3
\&                $dll = load OS2::REXX "RexxBase";
\&                $dll->prefix("RexxBase_");
\&                $dll->Init();
.Ve
.PP
is the same as
.PP
.Vb 2
\&                $dll = load OS2::REXX "RexxBase";
\&                $dll->RexxBase_Init();
.Ve
.Sh "Define queue:"
.IX Subsection "Define queue:"
.Vb 1
\&        $dll->queue(NAME);
.Ve
.PP
Define the name of the \s-1REXX\s0 queue passed to all external
functions of this module. Defaults to \*(L"\s-1SESSION\s0\*(R".
.PP
Check for functions (optional):
.PP
.Vb 1
\&        BOOL = $dll->find(NAME [, NAME [, ...]]);
.Ve
.PP
Returns true if all functions are available.
.Sh "Call external \s-1REXX\s0 function:"
.IX Subsection "Call external REXX function:"
.Vb 1
\&        $dll->function(arguments);
.Ve
.PP
Returns the return string if the return code is 0, else undef.
Dies with error message if the function is not available.
.SH "Accessing REXX-runtime"
.IX Header "Accessing REXX-runtime"
While calling functions with \s-1REXX\s0 signature does not require the presence
of the system \s-1REXX\s0 \s-1DLL\s0, there are some actions which require REXX-runtime 
present. Among them is the access to \s-1REXX\s0 variables by name.
.PP
One enables \s-1REXX\s0 runtime by bracketing your code by
.PP
.Vb 1
\&        REXX_call BLOCK;
.Ve
.PP
(trailing semicolon required!) or
.PP
.Vb 1
\&        REXX_call \e&subroutine_name;
.Ve
.PP
Inside such a call one has access to \s-1REXX\s0 variables (see below).
.PP
An alternative way to execute code inside a \s-1REXX\s0 compartment is
.PP
.Vb 3
\&        REXX_eval EXPR;
\&        REXX_eval_with EXPR, 
\&                subroutine_name_in_REXX => \e&Perl_subroutine
.Ve
.PP
Here \f(CW\*(C`EXPR\*(C'\fR is a \s-1REXX\s0 code to run; to execute Perl code one needs to put
it inside \fIPerl_subroutine()\fR, and call this subroutine from \s-1REXX\s0, as in
.PP
.Vb 3
\&        REXX_eval_with <<EOE, foo => sub { 123 * shift };
\&          say foo(2)
\&        EOE
.Ve
.PP
If one needs more Perl subroutines available, one can \*(L"import\*(R" them into
\&\s-1REXX\s0 from inside \fIPerl_subroutine()\fR; since \s-1REXX\s0 is not case\-sensitive,
the names should be uppercased.
.PP
.Vb 1
\&        use OS2::REXX 'register';
.Ve
.PP
.Vb 3
\&        sub BAR { 123 + shift}
\&        sub BAZ { 789 }
\&        sub importer { register qw(BAR BAZ) }
.Ve
.PP
.Vb 5
\&        REXX_eval_with <<'EOE', importer => \e&importer;
\&          call importer
\&          say bar(34)
\&          say baz()
\&        EOE
.Ve
.Sh "Bind scalar variable to \s-1REXX\s0 variable:"
.IX Subsection "Bind scalar variable to REXX variable:"
.Vb 1
\&        tie $var, OS2::REXX, "NAME";
.Ve
.Sh "Bind array variable to \s-1REXX\s0 stem variable:"
.IX Subsection "Bind array variable to REXX stem variable:"
.Vb 1
\&        tie @var, OS2::REXX, "NAME.";
.Ve
.PP
Only scalar operations work so far. No array assignments, no array
operations, ... \s-1FORGET\s0 \s-1IT\s0.
.Sh "Bind hash array variable to \s-1REXX\s0 stem variable:"
.IX Subsection "Bind hash array variable to REXX stem variable:"
.Vb 1
\&        tie %var, OS2::REXX, "NAME.";
.Ve
.PP
To access all visible \s-1REXX\s0 variables via hash array, bind to "";
.PP
No array assignments. No array operations, other than hash array
operations. Just like the *dbm based implementations.
.PP
For the usual \s-1REXX\s0 stem variables, append a \*(L".\*(R" to the name,
as shown above. If the hash key is part of the stem name, for
example if you bind to "", you cannot use lower case in the stem
part of the key and it is subject to character set restrictions.
.Sh "Erase individual \s-1REXX\s0 variables (bound or not):"
.IX Subsection "Erase individual REXX variables (bound or not):"
.Vb 1
\&        OS2::REXX::drop("NAME" [, "NAME" [, ...]]);
.Ve
.Sh "Erase \s-1REXX\s0 variables with given stem (bound or not):"
.IX Subsection "Erase REXX variables with given stem (bound or not):"
.Vb 1
\&        OS2::REXX::dropall("STEM" [, "STEM" [, ...]]);
.Ve
.Sh "Make Perl functions available in \s-1REXX:\s0"
.IX Subsection "Make Perl functions available in REXX:"
.Vb 1
\&        OS2::REXX::register("NAME" [, "NAME" [, ...]]);
.Ve
.PP
Since \s-1REXX\s0 is not case\-sensitive, the names should be uppercase.
.SH "Subcommand handlers"
.IX Header "Subcommand handlers"
By default, the executed \s-1REXX\s0 code runs without any default subcommand
handler present.  A subcommand handler named \f(CW\*(C`PERLEVAL\*(C'\fR is defined, but
not made a default.  Use \f(CW\*(C`ADDRESS PERLEVAL\*(C'\fR \s-1REXX\s0 command to make it a default
handler; alternatively, use \f(CW\*(C`ADDRESS Handler WhatToDo\*(C'\fR to direct a command
to the handler you like.
.PP
Experiments show that the handler \f(CW\*(C`CMD\*(C'\fR is also available; probably it is
provided by the \s-1REXX\s0 runtime.
.SH "Interfacing from REXX to Perl"
.IX Header "Interfacing from REXX to Perl"
This module provides an interface from Perl to \s-1REXX\s0, and from REXX-inside-Perl
back to Perl.  There is an alternative scenario which allows usage of Perl
from inside \s-1REXX\s0.
.PP
A \s-1DLL\s0 \fIPerlRexx\fR provides an \s-1API\s0 to Perl as \s-1REXX\s0 functions
.PP
.Vb 9
\&  PERL
\&  PERLTERM
\&  PERLINIT
\&  PERLEXIT
\&  PERLEVAL
\&  PERLLASTERROR
\&  PERLEXPORTALL
\&  PERLDROPALL
\&  PERLDROPALLEXIT
.Ve
.PP
A subcommand handler \f(CW\*(C`PERLEVALSUBCOMMAND\*(C'\fR can also be registered.  Calling
the function \s-1\fIPERLEXPORTALL\s0()\fR exports all these functions, as well as
exports this subcommand handler under the name \f(CW\*(C`EVALPERL\*(C'\fR.  \s-1\fIPERLDROPALL\s0()\fR
inverts this action (and unloads \s-1\fIPERLEXPORTALL\s0()\fR as well).  In particular
.PP
.Vb 5
\&  rc = RxFuncAdd("PerlExportAll", 'PerlRexx', "PERLEXPORTALL")
\&  rc = PerlExportAll()
\&  res = PERLEVAL(perlarg)
\&  ADDRESS EVALPERL perlarg1
\&  rc = PerlDropAllExit()
.Ve
.PP
loads all the functions above, evals the Perl code in the \s-1REXX\s0 variable
\&\f(CW\*(C`perlarg\*(C'\fR, putting the result into the \s-1REXX\s0 variable \f(CW\*(C`res\*(C'\fR,
then evals the Perl code in the \s-1REXX\s0 variable \f(CW\*(C`perlarg1\*(C'\fR, and, finally,
drops the loaded functions and the subcommand handler, deinitializes
the Perl interpreter, and exits the Perl's C runtime library.
.PP
\&\s-1\fIPERLEXIT\s0()\fR or \s-1\fIPERLDROPALLEXIT\s0()\fR should be called as the last command of
the \s-1REXX\s0 program.  (This is considered as a bug.)  Their purpose is to flush
all the output buffers of the Perl's C runtime library.
.PP
\&\f(CW\*(C`PERLLASTERROR\*(C'\fR gives the reason for the failure of the last \s-1\fIPERLEVAL\s0()\fR.
It is useful inside \f(CW\*(C`signal on syntax\*(C'\fR handler.  \s-1\fIPERLINIT\s0()\fR and \s-1\fIPERLTERM\s0()\fR
initialize and deinitialize the Perl interpreter.
.PP
\&\f(CW\*(C`PERLEVAL(string)\*(C'\fR initializes the Perl interpreter (if needed), and
evaluates \f(CW\*(C`string\*(C'\fR as Perl code.  The result is returned to \s-1REXX\s0 stringified,
undefined result is considered as failure.
.PP
\&\f(CW\*(C`PERL(string)\*(C'\fR does the same as \f(CW\*(C`PERLEVAL(string)\*(C'\fR wrapped by calls to
\&\s-1\fIPERLINIT\s0()\fR and \s-1\fIPERLEXIT\s0()\fR.
.SH "NOTES"
.IX Header "NOTES"
Note that while function and variable names are case insensitive in the
\&\s-1REXX\s0 language, function names exported by a \s-1DLL\s0 and the \s-1REXX\s0 variables
(as seen by Perl through the chosen \s-1API\s0) are all case sensitive!
.PP
Most \s-1REXX\s0 DLLs export function names all upper case, but there are a
few which export mixed case names (such as RxExtras). When trying to
find the entry point, both exact case and all upper case are searched.
If the \s-1DLL\s0 exports \*(L"RxNap\*(R", you have to specify the exact case, if it
exports \*(L"\s-1RXOPEN\s0\*(R", you can use any case.
.PP
To avoid interfering with subroutine names defined by Perl (\s-1DESTROY\s0)
or used within the \s-1REXX\s0 module (prefix, find), it is best to use mixed
case and to avoid lowercase only or uppercase only names when calling
\&\s-1REXX\s0 functions. Be consistent. The same function written in different
ways results in different Perl stubs.
.PP
There is no \s-1REXX\s0 interpolation on variable names, so the \s-1REXX\s0 variable
name \s-1TEST\s0.ONE is not affected by some other \s-1REXX\s0 variable \s-1ONE\s0. And it
is not the same variable as \s-1TEST\s0.one!
.PP
You cannot call \s-1REXX\s0 functions which are not exported by the \s-1DLL\s0.
While most DLLs export all their functions, some, like RxFTP, export
only \*(L"...LoadFuncs\*(R", which registers the functions within \s-1REXX\s0 only.
.PP
You cannot call 16\-bit DLLs. The few interesting ones I found
(\s-1FTP\s0,NETB,APPC) do not export their functions.
.PP
I do not know whether the \s-1REXX\s0 \s-1API\s0 is reentrant with respect to
exceptions (signals) when the \s-1REXX\s0 top-level exception handler is
overridden. So unless you know better than I do, do not access \s-1REXX\s0
variables (probably tied to Perl variables) or call \s-1REXX\s0 functions
which access \s-1REXX\s0 queues or \s-1REXX\s0 variables in signal handlers.
.PP
See \f(CW\*(C`t/rx*.t\*(C'\fR and the next section for examples.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\&  use OS2::REXX;
.Ve
.PP
.Vb 1
\&  sub Ender::DESTROY { $vrexx->VExit; print "Exiting...\en" }
.Ve
.PP
.Vb 4
\&  $vrexx = OS2::REXX->load('VREXX');
\&  REXX_call {                   # VOpenWindow takes a stem
\&    local $SIG{TERM} = sub {die}; # enable Ender::DESTROY
\&    local $SIG{INT} = sub {die};        # enable Ender::DESTROY
.Ve
.PP
.Vb 3
\&    $code = $vrexx->VInit;
\&    print "Init code = `$code'\en";
\&    die "error initializing VREXX" if $code eq 'ERROR';
.Ve
.PP
.Vb 1
\&    my $ender = bless [], 'Ender'; # Call Ender::DESTROY on exit
.Ve
.PP
.Vb 1
\&    print "VREXX Version ", $vrexx->VGetVersion, "\en";
.Ve
.PP
.Vb 2
\&    tie %pos, 'OS2::REXX', 'POS.' or die;
\&    %pos = ( LEFT   => 0, RIGHT  => 7, TOP    => 5, BOTTOM => 0 );
.Ve
.PP
.Vb 11
\&    $id = $vrexx->VOpenWindow('To disconnect:', 'WHITE', 'POS');
\&    $vrexx->VForeColor($id, 'BLACK');
\&    $vrexx->VSetFont($id, 'TIME', '30');
\&    $tlim = time + 60;
\&    while ( ($r = $tlim - time) >= 0 ) {
\&      $vrexx->VClearWindow($id);
\&      $vrexx->VSay($id, 100, 50, (sprintf "%02i:%02i", int($r/60), $r % 60));
\&      sleep 1;
\&    }
\&    print "Close code = `$res'\en" if $res = $vrexx->VCloseWindow($id);
\&  };
.Ve
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
If \f(CW\*(C`PERL_REXX_DEBUG\*(C'\fR is set, prints trace info on calls to \s-1REXX\s0 runtime
environment.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andreas Kaiser ak@ananke.s.bawue.de, with additions by Ilya Zakharevich
ilya@math.ohio\-state.edu.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1OS2::DLL\s0.
