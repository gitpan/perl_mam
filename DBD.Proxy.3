.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::DBD::Proxy 3 "perl 5.007, patch 00" "21/Jan/102" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
DBD::Proxy \- A proxy driver for the DBI
.SH "SYNOPSIS"
.PP
.Vb 1
\&  use DBI;
.Ve
.Vb 2
\&  $dbh = DBI->connect("dbi:Proxy:hostname=$host;port=$port;dsn=$db",
\&                      $user, $passwd);
.Ve
.Vb 1
\&  # See the DBI module documentation for full details
.Ve
.SH "DESCRIPTION"
DBD::Proxy is a Perl module for connecting to a database via a remote
DBI driver.
.PP
This is of course not needed for DBI drivers which already
support connecting to a remote database, but there are engines which
don't offer network connectivity.
.PP
Another application is offering database access through a firewall, as
the driver offers query based restrictions. For example you can
restrict queries to exactly those that are used in a given CGI
application.
.PP
Speaking of CGI, another application is (or rather, will be) to reduce
the database connect/disconnect overhead from CGI scripts by using
proxying the connect_cached method. The proxy server will hold the
database connections open in a cache. The CGI script then trades the
database connect/disconnect overhead for the DBD::Proxy
connect/disconnect overhead which is typically much less.
\fINote that the connect_cached method is new and still experimental.\fR
.SH "CONNECTING TO THE DATABASE"
Before connecting to a remote database, you must ensure, that a Proxy
server is running on the remote machine. There's no default port, so
you have to ask your system administrator for the port number. See
the \fIDBI::ProxyServer(3)\fR manpage for details.
.PP
Say, your Proxy server is running on machine \*(L"alpha\*(R", port 3334, and
you'd like to connect to an ODBC database called \*(L"mydb\*(R" as user \*(L"joe\*(R"
with password \*(L"hello\*(R". When using DBD::ODBC directly, you'd do a
.PP
.Vb 1
\&  $dbh = DBI->connect("DBI:ODBC:mydb", "joe", "hello");
.Ve
With DBD::Proxy this becomes
.PP
.Vb 2
\&  $dsn = "DBI:Proxy:hostname=alpha;port=3334;dsn=DBI:ODBC:mydb";
\&  $dbh = DBI->connect($dsn, "joe", "hello");
.Ve
You see, this is mainly the same. The DBD::Proxy module will create a
connection to the Proxy server on \*(L"alpha\*(R" which in turn will connect
to the ODBC database.
.PP
Refer to the the \fIDBI(3)\fR manpage documentation on the \f(CWconnect\fR method for a way
to automatically use DBD::Proxy without having to change your code.
.PP
DBD::Proxy's DSN string has the format
.PP
.Vb 1
\&  $dsn = "DBI:Proxy:key1=val1; ... ;keyN=valN;dsn=valDSN";
.Ve
In other words, it is a collection of key/value pairs. The following
keys are recognized:
.Ip "hostname" 4
.Ip "port" 4
Hostname and port of the Proxy server; these keys must be present,
no defaults. Example:
.Sp
.Vb 1
\&    hostname=alpha;port=3334
.Ve
.Ip "dsn" 4
The value of this attribute will be used as a dsn name by the Proxy
server. Thus it must have the format \f(CWDBI:driver:...\fR, in particular
it will contain colons. The \fIdsn\fR value may contain semicolons, hence
this key *must* be the last and it's value will be the complete
remaining part of the dsn. Example:
.Sp
.Vb 1
\&    dsn=DBI:ODBC:mydb
.Ve
.Ip "cipher" 4
.Ip "key" 4
.Ip "usercipher" 4
.Ip "userkey" 4
By using these fields you can enable encryption. If you set,
for example,
.Sp
.Vb 1
\&    cipher=$class;key=$key
.Ve
(note the semicolon) then \s-1DBD::\s0Proxy will create a new cipher object
by executing
.Sp
.Vb 1
\&    $cipherRef = $class->new(pack("H*", $key));
.Ve
and pass this object to the \s-1RPC::\s0PlClient module when creating a
client. See the \fI\s-1RPC::\s0PlClient(3)\fR manpage. Example:
.Sp
.Vb 1
\&    cipher=IDEA;key=97cd2375efa329aceef2098babdc9721
.Ve
The usercipher/userkey attributes allow you to use two phase encryption:
The cipher/key encryption will be used in the login and authorisation
phase. Once the client is authorised, he will change to usercipher/userkey
encryption. Thus the cipher/key pair is a \fBhost\fR based secret, typically
less secure than the usercipher/userkey secret and readable by anyone.
The usercipher/userkey secret is \fByour\fR private secret.
.Sp
Of course encryption requires an appropriately configured server. See
<\fI\s-1DBD::\s0ProxyServer\fR\|(3)/\s-1CONFIGURATION\s0 \s-1FILE\s0>.
.Ip "debug" 4
Turn on debugging mode
.Ip "stderr" 4
This attribute will set the corresponding attribute of the \s-1RPC::\s0PlClient
object, thus logging will not use \fIsyslog()\fR, but redirected to stderr.
This is the default under Windows.
.Sp
.Vb 1
\&    stderr=1
.Ve
.Ip "logfile" 4
Similar to the stderr attribute, but output will be redirected to the
given file.
.Sp
.Vb 1
\&    logfile=/dev/null
.Ve
.Ip "RowCacheSize" 4
The \s-1DBD::\s0Proxy driver supports this attribute (which is \s-1DBI\s0 standard,
as of \s-1DBI\s0 1.02). It's used to reduce network round-trips by fetching
multiple rows in one go. The current default value is 20, but this may
change.
.Ip "proxy_no_finish" 4
This attribute can be used to reduce network traffic: If the
application is calling \f(CW$sth\fR\->\fIfinish()\fR then the proxy tells the server
to finish the remote statement handle. Of course this slows down things
quite a lot, but is prefectly good for reducing memory usage with
persistent connections.
.Sp
However, if you set the \fIproxy_no_finish\fR attribute to a \s-1TRUE\s0 value,
either in the database handle or in the statement handle, then \fIfinish()\fR
calls will be supressed. This is what you want, for example, in small
and fast \s-1CGI\s0 applications.
.Ip "proxy_quote" 4
This attribute can be used to reduce network traffic: By default calls
to \f(CW$dbh\fR\->\fIquote()\fR are passed to the remote driver.  Of course this slows
down things quite a lot, but is the safest default behaviour.
  
However, if you set the \fIproxy_quote\fR attribute to the value \*(L'\f(CWlocal\fR\*(R'
either in the database handle or in the statement handle, and the call
to quote has only one parameter, then the local default \s-1DBI\s0 quote
method will be used (which will be faster but may be wrong).
.SH "KNOWN ISSUES"
.Sh "Complex handle attributes"
Sometimes handles are having complex attributes like hash refs or
array refs and not simple strings or integers. For example, with
\s-1DBD::CSV\s0, you would like to write something like
.PP
.Vb 2
\&  $dbh->{"csv_tables"}->{"passwd"} =
\&        { "sep_char" => ":", "eol" => "\en";
.Ve
The above example would advice the \s-1CSV\s0 driver to assume the file
\*(L"passwd\*(R" to be in the format of the /etc/passwd file: Colons as
separators and a line feed without carriage return as line
terminator.
.PP
Surprisingly this example doesn't work with the proxy driver. To understand
the reasons, you should consider the following: The Perl compiler is
executing the above example in two steps:
.Ip "1.)   The first step is fetching the value of the key \*(N"csv_tables\*(T" in the handle $dbh. The value returned is complex, a hash ref.   =item 2.)   The second step is storing some value (the right hand side of the assignment) as the key \*(N"passwd\*(T" in the hash ref from step 1." 5
.PP
This becomes a little bit clearer, if we rewrite the above code:
.PP
.Vb 2
\&  $tables = $dbh->{"csv_tables"};
\&  $tables->{"passwd"} = { "sep_char" => ":", "eol" => "\en";
.Ve
While the examples work fine without the proxy, the fail due to a
subtile difference in step 1: By \s-1DBI\s0 magic, the hash ref
\f(CW$dbh\fR\->{'csv_tables'} is returned from the server to the client.
The client creates a local copy. This local copy is the result of
step 1. In other words, step 2 modifies a local copy of the hash ref,
but not the server's hash ref.
.PP
The workaround is storing the modified local copy back to the server:
.PP
.Vb 3
\&  $tables = $dbh->{"csv_tables"};
\&  $tables->{"passwd"} = { "sep_char" => ":", "eol" => "\en";
\&  $dbh->{"csv_tables"} = $tables;
.Ve
.SH "AUTHOR AND COPYRIGHT"
This module is Copyright (c) 1997, 1998
.PP
.Vb 4
\&    Jochen Wiedmann
\&    Am Eisteich 9
\&    72555 Metzingen
\&    Germany
.Ve
.Vb 2
\&    Email: joe@ispsoft.de
\&    Phone: +49 7123 14887
.Ve
The DBD::Proxy module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. In particular permission
is granted to Tim Bunce for distributing this as a part of the DBI.
.SH "SEE ALSO"
the \fIDBI(3)\fR manpage, the \fIRPC::PlClient(3)\fR manpage, the \fIStorable(3)\fR manpage

.rn }` ''
.IX Title "lib::DBD::Proxy 3"
.IX Name "DBD::Proxy - A proxy driver for the DBI"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "CONNECTING TO THE DATABASE"

.IX Item "hostname"

.IX Item "port"

.IX Item "dsn"

.IX Item "cipher"

.IX Item "key"

.IX Item "usercipher"

.IX Item "userkey"

.IX Item "debug"

.IX Item "stderr"

.IX Item "logfile"

.IX Item "RowCacheSize"

.IX Item "proxy_no_finish"

.IX Item "proxy_quote"

.IX Header "KNOWN ISSUES"

.IX Subsection "Complex handle attributes"

.IX Item "1.)   The first step is fetching the value of the key \*(N"csv_tables\*(T" in the handle $dbh. The value returned is complex, a hash ref.   =item 2.)   The second step is storing some value (the right hand side of the assignment) as the key \*(N"passwd\*(T" in the hash ref from step 1."

.IX Header "AUTHOR AND COPYRIGHT"

.IX Header "SEE ALSO"

