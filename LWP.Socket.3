.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::LWP::Socket 3 "perl 5.004, patch 01" "27/Jan/97" "User Contributed Perl Documentation"
.IX Title "lib::LWP::Socket 3"
.UC
.IX Name "LWP::Socket - TCP/IP socket interface"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
LWP::Socket \- TCP/IP socket interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 7
\& $socket = new LWP::Socket;
\& $socket->connect('localhost', 7); # echo
\& $quote = 'I dunno, I dream in Perl sometimes...';
\& $socket->write("$quote\en");
\& $socket->read_until("\en", \e$buffer);
\& $socket->read(\e$buffer);
\& $socket = undef;  # close
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements TCP/IP sockets.  It groups socket generation,
TCP address manipulation and buffered reading. Errors are handled by
dying (throws exceptions).
.PP
This class should really not be required, something like this should
be part of the standard Perl5 library.
.PP
Running this module standalone executes a self test which requires
localhost to serve chargen and echo protocols.
.SH "METHODS"
.IX Header "METHODS"
.Sh "\f(CW$sock\fR = new \fI\s-1LWP::\s0Socket()\fR"
.IX Subsection "\f(CW$sock\fR = new \fI\s-1LWP::\s0Socket()\fR"
Constructs a new socket object.
.Sh "\f(CW$sock\fR\->\fIconnect\fR\|($host, \f(CW$port\fR)"
.IX Subsection "\f(CW$sock\fR\->\fIconnect\fR\|($host, \f(CW$port\fR)"
Connect the socket to given host and port.
.Sh "\f(CW$sock\fR\->\fIshutdown()\fR"
.IX Subsection "\f(CW$sock\fR\->\fIshutdown()\fR"
Shuts down the connection.
.Sh "\f(CW$sock\fR\->\fIbind\fR\|($host, \f(CW$port\fR)"
.IX Subsection "\f(CW$sock\fR\->\fIbind\fR\|($host, \f(CW$port\fR)"
Binds a name to the socket.
.Sh "\f(CW$sock\fR\->\fIlisten\fR\|($queuesize)"
.IX Subsection "\f(CW$sock\fR\->\fIlisten\fR\|($queuesize)"
Set up listen queue for socket.
.Sh "\f(CW$sock\fR\->\fIaccept\fR\|($timeout)"
.IX Subsection "\f(CW$sock\fR\->\fIaccept\fR\|($timeout)"
Accepts a new connection.  Returns a new \s-1LWP::\s0Socket object if successful.
Timeout not implemented yet.
.Sh "\f(CW$sock\fR\->\fIgetsockname()\fR"
.IX Subsection "\f(CW$sock\fR\->\fIgetsockname()\fR"
Returns a 2 element array ($host, \f(CW$port\fR)
.Sh "\f(CW$sock\fR\->\fIread_until\fR\|($delim, \f(CW$data_ref\fR, \f(CW$size\fR, \f(CW$timeout\fR)"
.IX Subsection "\f(CW$sock\fR\->\fIread_until\fR\|($delim, \f(CW$data_ref\fR, \f(CW$size\fR, \f(CW$timeout\fR)"
Reads data from the socket, up to a delimiter specified by a regular
expression.  If \f(CW$delim\fR is undefined all data is read.  If \f(CW$size\fR is
defined, data will be read internally in chunks of \f(CW$size\fR bytes.  This
does not mean that we will return the data when size bytes are read.
.PP
Note that \f(CW$delim\fR is discarded from the data returned.
.Sh "\f(CW$sock\fR\->\fIread\fR\|($bufref, [$size, \f(CW$timeout\fR])"
.IX Subsection "\f(CW$sock\fR\->\fIread\fR\|($bufref, [$size, \f(CW$timeout\fR])"
Reads data of the socket.  Not more than \f(CW$size\fR bytes.  Might return
less if the data is available.  Dies on timeout.
.Sh "\f(CW$sock\fR\->\fIpushback\fR\|($data)"
.IX Subsection "\f(CW$sock\fR\->\fIpushback\fR\|($data)"
Put data back into the socket.  Data will returned next time you
\fIread()\fR.  Can be used if you find out that you have read too much.
.Sh "\f(CW$sock\fR\->\fIwrite\fR\|($data, [$timeout])"
.IX Subsection "\f(CW$sock\fR\->\fIwrite\fR\|($data, [$timeout])"
Write data to socket.  The \f(CW$data\fR argument might be a scalar or code.
.PP
If data is a reference to a subroutine, then we will call this routine
to obtain the data to be written.  The routine will be called until it
returns undef or empty data.  Data might be returned from the callback
as a scalar or as a reference to a scalar.
.PP
Write returns the number of bytes written to the socket.
.Sh "\fI_getaddress\fR\|($h, \f(CW$p\fR)"
.IX Subsection "\fI_getaddress\fR\|($h, \f(CW$p\fR)"
Given a host and a port, it will return the address (sockaddr_in)
suitable as the \f(CWname\fR argument for \fIconnect()\fR or \fIbind()\fR. Might return
several addresses in array context if the hostname is bound to several
\s-1IP\s0 addresses.
.SH "SELF TEST"
.IX Header "SELF TEST"
This self test is only executed when this file is run standalone. It
tests its functions against some standard TCP services implemented by
inetd. If you do not have them around the tests will fail.

.rn }` ''
