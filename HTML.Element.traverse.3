.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::HTML::Element::traverse 3 "perl 5.007, patch 00" "10/Mar/101" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
HTML::Element traverse \- discussion of HTML::Element's traverse method
.SH "SYNOPSIS"
.PP
.Vb 2
\&  # $element->traverse is unnecessary and obscure.
\&  #   Don't use it in new code.
.Ve
.SH "DESCRIPTION"
\f(CWHTML::Element\fR provides a method \f(CWtraverse\fR that traverses the tree
and calls user-specified callbacks for each node, in pre- or
post-order.  However, use of the method is quite superfluous: if you
want to recursively visit every node in the tree, it's almost always
simpler to write a subroutine does just that, than it is to bundle up
the pre- and/or post-order code in callbacks for the \f(CWtraverse\fR
method.
.SH "EXAMPLES"
Suppose you want to traverse at/under a node \f(CW$tree\fR and give elements
an \*(L'id\*(R' attribute unless they already have one.
.PP
You can use the \f(CWtraverse\fR method:
.PP
.Vb 16
\&  {
\&    my $counter = 'x0000';
\&    $start_node->traverse(
\&      [ # Callbacks;
\&        # pre-order callback:
\&        sub {
\&          my $x = $_[0];
\&          $x->attr('id', $counter++) unless defined $x->attr('id');
\&          return HTML::Element::OK; # keep traversing
\&        },
\&        # post-order callback:
\&        undef
\&      ],
\&      1, # don't call the callbacks for text nodes
\&    );
\&  }
.Ve
or you can just be simple and clear (and not have to understand the
calling format for \f(CWtraverse\fR) by writing a sub that traverses the
tree by just calling itself:
.PP
.Vb 11
\&  {
\&    my $counter = 'x0000';
\&    sub give_id {
\&      my $x = $_[0];
\&      $x->attr('id', $counter++) unless defined $x->attr('id');
\&      foreach my $c ($x->content_list) {
\&        give_id($c) if ref $c; # ignore text nodes
\&      }
\&    };
\&    give_id($start_node);
\&  }
.Ve
See, isn't that nice and clear?
.PP
But, if you really need to know:
.SH "THE TRAVERSE METHOD"
The \f(CWtraverse()\fR method is a general object-method for traversing a
tree or subtree and calling user-specified callbacks.  It accepts the
following syntaxes:
.Ip "$h->traverse(\e&callback)" 5
.Ip "or $h->traverse(\e&callback, $ignore_text)" 5
.Ip "or $h->traverse( [\e&pre_callback,\e&post_callback] , $ignore_text)" 5
.PP
These all mean to traverse the element and all of its children.  That
is, this method starts at node \f(CW$h\fR, \*(L"pre-order visits\*(R" \f(CW$h\fR, traverses its
children, and then will \*(L"post-order visit\*(R" \f(CW$h\fR.  \*(L"Visiting\*(R" means that
the callback routine is called, with these arguments:
.PP
.Vb 3
\&    $_[0] : the node (element or text segment),
\&    $_[1] : a startflag, and
\&    $_[2] : the depth
.Ve
If the \f(CW$ignore_text\fR parameter is given and true, then the pre-order
call \fIwill not\fR be happen for text content.
.PP
The startflag is 1 when we enter a node (i.e., in pre-order calls) and
0 when we leave the node (in post-order calls).
.PP
Note, however, that post-order calls don't happen for nodes that are
text segments or are elements that are prototypically empty (like \*(L"br\*(R",
\*(L"hr\*(R", etc.).
.PP
If we visit text nodes (i.e., unless \f(CW$ignore_text\fR is given and true),
then when text nodes are visited, we will also pass two extra
arguments to the callback:
.PP
.Vb 4
\&    $_[3] : the element that's the parent
\&             of this text node
\&    $_[4] : the index of this text node
\&             in its parent's content list
.Ve
Note that you can specify that the pre-order routine can
be a different routine from the post-order one:
.PP
.Vb 1
\&    $h->traverse( [\e&pre_callback,\e&post_callback], ...);
.Ve
You can also specify that no post-order calls are to be made,
by providing a false value as the post-order routine:
.PP
.Vb 1
\&    $h->traverse([ \e&pre_callback,0 ], ...);
.Ve
And similarly for suppressing pre-order callbacks:
.PP
.Vb 1
\&    $h->traverse([ 0,\e&post_callback ], ...);
.Ve
Note that these two syntaxes specify the same operation:
.PP
.Vb 2
\&    $h->traverse([\e&foo,\e&foo], ...);
\&    $h->traverse( \e&foo       , ...);
.Ve
The return values from calls to your pre- or post-order 
routines are significant, and are used to control recursion
into the tree.
.PP
These are the values you can return, listed in descending order
of my estimation of their usefulness:
.Ip "\s-1HTML::\s0Element::\s-1OK\s0, 1, or any other true value" 5
\&...to keep on traversing.
.Sp
Note that \f(CWHTML::Element::OK\fR et
al are constants.  So if you're running under \f(CWuse strict\fR
(as I hope you are), and you say:
\f(CWreturn HTML::Element::PRUEN\fR
the compiler will flag this as an error (an unallowable
bareword, specifically), whereas if you spell \s-1PRUNE\s0 correctly,
the compiler will not complain.
.Ip "undef, 0, \*(N'0\*(T', \*(N'\*(T', or \s-1HTML::\s0Element::\s-1PRUNE\s0" 5
\&...to block traversing under the current element's content.
(This is ignored if received from a post-order callback,
since by then the recursion has already happened.)
If this is returned by a pre-order callback, no
post-order callback for the current node will happen.
(Recall that if your callback exits with just \f(CWreturn;\fR,
it is returning undef -- at least in scalar context, and
\f(CWtraverse\fR always calls your callbacks in scalar context.)
.Ip "\s-1HTML::\s0Element::\s-1ABORT\s0" 5
\&...to abort the whole traversal immediately.
This is often useful when you're looking for just the first
node in the tree that meets some criterion of yours.
.Ip "\s-1HTML::\s0Element::\s-1PRUNE_UP\s0" 5
\&...to abort continued traversal into this node and its parent
node.  No post-order callback for the current or parent
node will happen.
.Ip "\s-1HTML::\s0Element::\s-1PRUNE_SOFTLY\s0" 5
Like \s-1PRUNE\s0, except that the post-order call for the current
node is not blocked.
.PP
Almost every task to do with extracting information from a tree can be
expressed in terms of traverse operations (usually in only one pass,
and usually paying attention to only pre-order, or to only
post-order), or operations based on traversing. (In fact, many of the
other methods in this class are basically calls to \fItraverse()\fR with
particular arguments.)
.PP
The source code for \s-1HTML::\s0Element and \s-1HTML::\s0TreeBuilder contain
several examples of the use of the \*(L"traverse\*(R" method to gather
information about the content of trees and subtrees.
.PP
(Note: you should not change the structure of a tree \fIwhile\fR you are
traversing it.)
.PP
[End of documentation for the \f(CWtraverse()\fR method]
.Sh "Traversing with Recursive Anonymous Routines"
Now, if you've been reading
\fIStructure and Interpretation of Computer Programs\fR too much, maybe
you even want a recursive lambda.  Go ahead:
.PP
.Vb 13
\&  {
\&    my $counter = 'x0000';
\&    my $give_id;
\&    $give_id = sub {
\&      my $x = $_[0];
\&      $x->attr('id', $counter++) unless defined $x->attr('id');
\&      foreach my $c ($x->content_list) {
\&        $give_id->($c) if ref $c; # ignore text nodes
\&      }
\&    };
\&    $give_id->($start_node);
\&    undef $give_id;
\&  }
.Ve
It's a bit nutty, and it's \fIstill\fR more concise than a call to the
\f(CWtraverse\fR method!
.PP
It is left as an exercise to the reader to figure out how to do the
same thing without using a \f(CW$give_id\fR symbol at all.
.PP
It is also left as an exercise to the reader to figure out why I
undefine \f(CW$give_id\fR, above; and why I could achieved the same effect
with any of:
.PP
.Vb 5
\&    $give_id = 'I like pie!';
\&   # or...
\&    $give_id = [];
\&   # or even;
\&    $give_id = sub { print "Mmmm pie!\en" };
.Ve
But not:
.PP
.Vb 5
\&    $give_id = sub { print "I'm $give_id and I like pie!\en" };
\&   # nor...
\&    $give_id = \e$give_id;
\&   # nor...
\&    $give_id = { 'pie' => \e$give_id, 'mode' => 'a la' };
.Ve
.Sh "Doing Recursive Things Iteratively"
Note that you may at times see an iterative implementation of
pre-order traversal, like so:
.PP
.Vb 13
\&   {
\&     my @to_do = ($tree); # start-node
\&     while(@to_do) {
\&       my $this = shift @to_do;
\&       
\&       # "Visit" the node:
\&       $this->attr('id', $counter++)
\&        unless defined $this->attr('id');
\&       
\&       unshift @to_do, grep ref $_, $this->content_list;
\&        # Put children on the stack -- they'll be visited next
\&     }
\&   }
.Ve
This can \fIunder certain circumstances\fR be more efficient than just a
normal recursive routine, but at the cost of being rather obscure.  It
gains efficiency by avoiding the overhead of function-calling, but
since there are several method dispatches however you do it (to
\f(CWattr\fR and \f(CWcontent_list\fR), the overhead for a simple function call
is insignificant.
.Sh "Pruning and Whatnot"
The \f(CWtraverse\fR method does have the fairly neat features of 
the \f(CWABORT\fR, \f(CWPRUNE_UP\fR and \f(CWPRUNE_SOFTLY\fR signals.  None of these
can be implemented \fItotally\fR straightforwardly with recursive
routines, but it is quite possible.  \f(CWABORT\fR\-like behavior can be
implemented either with using non-local returning with \f(CWeval\fR/\f(CWdie\fR:
.PP
.Vb 15
\&  my $died_on; # if you need to know where...
\&  sub thing {
\&    ... visits $_[0]...
\&    ... maybe set $died_on to $_[0] and die "ABORT_TRAV" ...
\&    ... else call thing($child) for each child...
\&    ...any post-order visiting $_[0]...
\&  }
\&  eval { thing($node) };
\&  if($@) {
\&    if($@ =~ m<^ABORT_TRAV>) {
\&      ...it died (aborted) on $died_on...
\&    } else {
\&      die $@; # some REAL error happened
\&    }
\&  }
.Ve
or you can just do it with flags:
.PP
.Vb 11
\&  my($abort_flag, $died_on);
\&  sub thing {
\&    ... visits $_[0]...
\&    ... maybe set $abort_flag = 1; $died_on = $_[0]; return;
\&    foreach my $c ($_[0]->content_list) {
\&      thing($c);
\&      return if $abort_flag;
\&    }
\&    ...any post-order visiting $_[0]...
\&    return;
\&  }
.Ve
.Vb 3
\&  $abort_flag = $died_on = undef;
\&  thing($node);
\&  ...if defined $abort_flag, it died on $died_on
.Ve
.SH "SEE ALSO"
the \fIHTML::Element\fR manpage
.SH "COPYRIGHT"
Copyright 2000,2001 Sean M. Burke
.SH "AUTHOR"
Sean M. Burke, <sburke@cpan.org>

.rn }` ''
.IX Title "lib::HTML::Element::traverse 3"
.IX Name "HTML::Element traverse - discussion of HTML::Element's traverse method"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "EXAMPLES"

.IX Header "THE TRAVERSE METHOD"

.IX Item "$h->traverse(\e&callback)"

.IX Item "or $h->traverse(\e&callback, $ignore_text)"

.IX Item "or $h->traverse( [\e&pre_callback,\e&post_callback] , $ignore_text)"

.IX Item "\s-1HTML::\s0Element::\s-1OK\s0, 1, or any other true value"

.IX Item "undef, 0, \*(N'0\*(T', \*(N'\*(T', or \s-1HTML::\s0Element::\s-1PRUNE\s0"

.IX Item "\s-1HTML::\s0Element::\s-1ABORT\s0"

.IX Item "\s-1HTML::\s0Element::\s-1PRUNE_UP\s0"

.IX Item "\s-1HTML::\s0Element::\s-1PRUNE_SOFTLY\s0"

.IX Subsection "Traversing with Recursive Anonymous Routines"

.IX Subsection "Doing Recursive Things Iteratively"

.IX Subsection "Pruning and Whatnot"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

.IX Header "AUTHOR"

