.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::MIME::Field::ContType 3 "perl 5.007, patch 00" "4/Nov/100" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
MIME::Field::ContType \- a \*(L"Content-type\*(R" field
.SH "DESCRIPTION"
A subclass of Mail::Field.
.PP
\fIDon't use this class directly... its name may change in the future!\fR
Instead, ask Mail::Field for new instances based on the field name!
.SH "SYNOPSIS"
.PP
.Vb 10
\&    use Mail::Field;
\&    use MIME::Head;
\&    
\&    # Create an instance from some text:
\&    $field = Mail::Field->new('Content-type', 
\&                              'text/HTML; charset="US-ASCII"');
\&    
\&    # Get the MIME type, like 'text/plain' or 'x-foobar'.
\&    # Returns 'text/plain' as default, as per RFC-1521:
\&    my ($type, $subtype) = split('/', $field->type);
.Ve
.Vb 20
\&    # Get generic information:
\&    print $field->name;
\&    
\&    # Get information related to "message" type:
\&    if ($type eq 'message') {
\&        print $field->id;
\&        print $field->number;
\&        print $field->total;
\&    }
\&    
\&    # Get information related to "multipart" type:
\&    if ($type eq 'multipart') {
\&        print $field->boundary;            # the basic value, fixed up
\&        print $field->multipart_boundary;  # empty if not a multipart message!
\&    }
\&    
\&    # Get information related to "text" type:
\&    if ($type eq 'text') {
\&        print $field->charset;      # returns 'us-ascii' as default
\&    }     
.Ve
.SH "PUBLIC INTERFACE"
.Ip "boundary" 4
Return the boundary field.  The boundary is returned exactly 
as given in the \f(CWContent-type:\fR field; that is, the leading 
double-hyphen (\f(CW--\fR) is \fInot\fR prepended.
.Sp
(Well, \fIalmost\fR exactly... from \s-1RFC\s0\-1521:
.Sp
.Vb 2
\&   (If a boundary appears to end with white space, the white space 
\&   must be presumed to have been added by a gateway, and must be deleted.)  
.Ve
so we oblige and remove any trailing spaces.)
.Sp
Returns the empty string if there is no boundary, or if the boundary is
illegal (e.g., if it is empty after all trailing whitespace has been
removed).
.Ip "multipart_boundary" 4
Like \f(CWboundary()\fR, except that this will also return the empty
string if the message is not a multipart message.  In other words,
there's an automatic sanity check.
.Ip "type" 4
Try real hard to determine the content type (e.g., \f(CW"text/plain"\fR,
\f(CW"image/gif"\fR, \f(CW"x-weird-type"\fR, which is returned 
in all-lowercase.  
.Sp
A happy thing: the following code will work just as you would want,
even if there's no subtype (as in \f(CW"x-weird-type"\fR)... in such a case,
the \f(CW$subtype\fR would simply be the empty string:
.Sp
.Vb 1
\&    ($type, $subtype) = split('/', $head->mime_type);
.Ve
If the content-type information is missing, it defaults to \f(CW"text/plain"\fR, 
as per \s-1RFC\s0\-1521:
.Sp
.Vb 4
\&    Default RFC-822 messages are typed by this protocol as plain text in
\&    the US-ASCII character set, which can be explicitly specified as
\&    "Content-type: text/plain; charset=us-ascii".  If no Content-Type is
\&    specified, this default is assumed.  
.Ve
\fBNote:\fR under the \*(L"be liberal in what we accept\*(R" principle, this routine
no longer syntax-checks the content type.  If it ain't empty,
just downcase and return it.
.SH "NOTES"
Since nearly all (if not all) parameters must have non-empty values
to be considered valid, we just return the empty string to signify 
missing fields.  If you need to get the \fIreal\fR underlying value,
use the inherited \f(CWparam()\fR method (which returns undef if the 
parameter is missing).
.SH "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).

.rn }` ''
.IX Title "lib::MIME::Field::ContType 3"
.IX Name "MIME::Field::ContType - a "Content-type" field"

.IX Header "NAME"

.IX Header "DESCRIPTION"

.IX Header "SYNOPSIS"

.IX Header "PUBLIC INTERFACE"

.IX Item "boundary"

.IX Item "multipart_boundary"

.IX Item "type"

.IX Header "NOTES"

.IX Header "AUTHOR"

