.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::IO::Scalar 3 "perl 5.007, patch 00" "9/Aug/101" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
IO::Scalar \- IO:: interface for reading/writing a scalar
.SH "SYNOPSIS"
Perform I/O on strings, using the basic OO interface...
.PP
.Vb 3
\&    use 5.005;
\&    use IO::Scalar;
\&    $data = "My message:\en";
.Ve
.Vb 5
\&    ### Open a handle on a string, and append to it:
\&    $SH = new IO::Scalar \e$data;
\&    $SH->print("Hello");       
\&    $SH->print(", world!\enBye now!\en");  
\&    print "The string is now: ", $data, "\en";
.Ve
.Vb 6
\&    ### Open a handle on a string, read it line-by-line, then close it:
\&    $SH = new IO::Scalar \e$data;
\&    while (defined($_ = $SH->getline)) { 
\&        print "Got line: $_";
\&    }
\&    $SH->close;
.Ve
.Vb 3
\&    ### Open a handle on a string, and slurp in all the lines:
\&    $SH = new IO::Scalar \e$data;
\&    print "All lines:\en", $SH->getlines; 
.Ve
.Vb 3
\&    ### Get the current position (either of two ways):
\&    $pos = $SH->getpos;         
\&    $offset = $SH->tell;  
.Ve
.Vb 3
\&    ### Set the current position (either of two ways):
\&    $SH->setpos($pos);        
\&    $SH->seek($offset, 0);
.Ve
.Vb 4
\&    ### Open an anonymous temporary scalar:
\&    $SH = new IO::Scalar;
\&    $SH->print("Hi there!");
\&    print "I printed: ", ${$SH->sref}, "\en";      ### get at value
.Ve
Don't like OO for your I/O?  No problem.  
Thanks to the magic of an invisible \fItie()\fR, the following now 
works out of the box, just as it does with IO::Handle:
.PP
.Vb 9
\&    use 5.005;
\&    use IO::Scalar;
\&    $data = "My message:\en";
\&     
\&    ### Open a handle on a string, and append to it:
\&    $SH = new IO::Scalar \e$data;
\&    print $SH "Hello";    
\&    print $SH ", world!\enBye now!\en";
\&    print "The string is now: ", $data, "\en";
.Ve
.Vb 6
\&    ### Open a handle on a string, read it line-by-line, then close it:
\&    $SH = new IO::Scalar \e$data;
\&    while (<$SH>) {
\&        print "Got line: $_";
\&    }
\&    close $SH;
.Ve
.Vb 3
\&    ### Open a handle on a string, and slurp in all the lines:
\&    $SH = new IO::Scalar \e$data;
\&    print "All lines:\en", <$SH>;
.Ve
.Vb 2
\&    ### Get the current position (WARNING: requires 5.6):
\&    $offset = tell $SH;
.Ve
.Vb 2
\&    ### Set the current position (WARNING: requires 5.6):
\&    seek $SH, $offset, 0;
.Ve
.Vb 4
\&    ### Open an anonymous temporary scalar:
\&    $SH = new IO::Scalar;
\&    print $SH "Hi there!";
\&    print "I printed: ", ${$SH->sref}, "\en";      ### get at value
.Ve
And for you folks with 1.x code out there: the old \fItie()\fR style still works,
though this is \fIunnecessary and deprecated\fR:
.PP
.Vb 1
\&    use IO::Scalar;
.Ve
.Vb 5
\&    ### Writing to a scalar...
\&    my $s; 
\&    tie *OUT, 'IO::Scalar', \e$s;
\&    print OUT "line 1\enline 2\en", "line 3\en";
\&    print "String is now: $s\en"
.Ve
.Vb 7
\&    ### Reading and writing an anonymous scalar... 
\&    tie *OUT, 'IO::Scalar';
\&    print OUT "line 1\enline 2\en", "line 3\en";
\&    tied(OUT)->seek(0,0);
\&    while (<OUT>) { 
\&        print "Got line: ", $_;
\&    }
.Ve
Stringification works, too!
.PP
.Vb 4
\&    my $SH = new IO::Scalar \e$data;
\&    print $SH "Hello, ";
\&    print $SH "world!";
\&    print "I printed: $SH\en";
.Ve
.SH "DESCRIPTION"
This class is part of the IO::Stringy distribution;
see the \fIIO::Stringy\fR manpage for change log and general information.
.PP
The IO::Scalar class implements objects which behave just like 
IO::Handle (or FileHandle) objects, except that you may use them 
to write to (or read from) scalars.  These handles are 
automatically tiehandle'd (though please see the section on \fIWARNINGS\fR
for information relevant to your Perl version).
.PP
Basically, this:
.PP
.Vb 4
\&    my $s;
\&    $SH = new IO::Scalar \e$s;
\&    $SH->print("Hel", "lo, ");         ### OO style
\&    $SH->print("world!\en");            ### ditto
.Ve
Or this:
.PP
.Vb 4
\&    my $s;
\&    $SH = tie *OUT, 'IO::Scalar', \e$s;
\&    print OUT "Hel", "lo, ";           ### non-OO style
\&    print OUT "world!\en";              ### ditto
.Ve
Causes \f(CW$s\fR to be set to:    
.PP
.Vb 1
\&    "Hello, world!\en" 
.Ve
.SH "PUBLIC INTERFACE"
.Sh "Construction "
.Ip "new [\s-1ARGS\s0...]" 4
\fIClass method.\fR
Return a new, unattached scalar handle.  
If any arguments are given, they're sent to \fIopen()\fR.
.Ip "open [\s-1SCALARREF\s0]" 4
\fIInstance method.\fR
Open the scalar handle on a new scalar, pointed to by \s-1SCALARREF\s0.
If no \s-1SCALARREF\s0 is given, a \*(L"private\*(R" scalar is created to hold
the file data.
.Sp
Returns the self object on success, undefined on error.
.Ip "opened" 4
\fIInstance method.\fR
Is the scalar handle opened on something?
.Ip "close" 4
\fIInstance method.\fR
Disassociate the scalar handle from its underlying scalar.
Done automatically on destroy.
.Sh "Input and output"
.Ip "flush " 4
\fIInstance method.\fR
No-op, provided for \s-1OO\s0 compatibility.
.Ip "getc" 4
\fIInstance method.\fR
Return the next character, or undef if none remain.
.Ip "getline" 4
\fIInstance method.\fR
Return the next line, or undef on end of string.  
Can safely be called in an array context.
Currently, lines are delimited by \*(L"\en\*(R".
.Ip "getlines" 4
\fIInstance method.\fR
Get all remaining lines.
It will \fIcroak()\fR if accidentally called in a scalar context.
.Ip "print \s-1ARGS\s0..." 4
\fIInstance method.\fR
Print \s-1ARGS\s0 to the underlying scalar.  
.Sp
\fBWarning:\fR this continues to always cause a seek to the end 
of the string, but if you perform \fIseek()\fRs and \fItell()\fRs, it is
still safer to explicitly seek-to-end before subsequent \fIprint()\fRs.
.Ip "read \s-1BUF\s0, \s-1NBYTES\s0, [\s-1OFFSET\s0]" 4
\fIInstance method.\fR
Read some bytes from the scalar.
Returns the number of bytes actually read, 0 on end-of-file, undef on error.
.Ip "write \s-1BUF\s0, \s-1NBYTES\s0, [\s-1OFFSET\s0]" 4
\fIInstance method.\fR
Write some bytes to the scalar.
.Ip "sysread \s-1BUF\s0, \s-1LEN\s0, [\s-1OFFSET\s0]" 4
\fIInstance method.\fR
Read some bytes from the scalar.
Returns the number of bytes actually read, 0 on end-of-file, undef on error.
.Ip "syswrite \s-1BUF\s0, \s-1NBYTES\s0, [\s-1OFFSET\s0]" 4
\fIInstance method.\fR
Write some bytes to the scalar.
.Sh "Seeking/telling and other attributes"
.Ip "autoflush " 4
\fIInstance method.\fR
No-op, provided for \s-1OO\s0 compatibility.
.Ip "binmode" 4
\fIInstance method.\fR
No-op, provided for \s-1OO\s0 compatibility.
.Ip "clearerr" 4
\fIInstance method.\fR  Clear the error and \s-1EOF\s0 flags.  A no-op.
.Ip "eof " 4
\fIInstance method.\fR  Are we at end of file?
.Ip "seek \s-1OFFSET\s0, \s-1WHENCE\s0" 4
\fIInstance method.\fR  Seek to a given position in the stream.
.Ip "sysseek \s-1OFFSET\s0, \s-1WHENCE\s0" 4
\fIInstance method.\fR Identical to \f(CWseek OFFSET, WHENCE\fR, \fIq.v.\fR
.Ip "tell" 4
\fIInstance method.\fR
Return the current position in the stream, as a numeric offset.
.Ip "setpos \s-1POS\s0" 4
\fIInstance method.\fR
Set the current position, using the opaque value returned by \f(CWgetpos()\fR.
.Ip "getpos " 4
\fIInstance method.\fR
Return the current position in the string, as an opaque object.
.Ip "sref" 4
\fIInstance method.\fR
Return a reference to the underlying scalar.
.SH "WARNINGS"
Perl's TIEHANDLE spec was incomplete prior to 5.005_57;
it was missing support for \f(CWseek()\fR, \f(CWtell()\fR, and \f(CWeof()\fR.
Attempting to use these functions with an IO::Scalar will not work
prior to 5.005_57. IO::Scalar will not have the relevant methods 
invoked; and even worse, this kind of bug can lie dormant for a while.
If you turn warnings on (via \f(CW$^W\fR or \f(CWperl -w\fR),
and you see something like this...
.PP
.Vb 1
\&    attempt to seek on unopened filehandle
.Ve
\&...then you are probably trying to use one of these functions
on an IO::Scalar with an old Perl.  The remedy is to simply
use the OO version; e.g.:
.PP
.Vb 2
\&    $SH->seek(0,0);    ### GOOD: will work on any 5.005
\&    seek($SH,0,0);     ### WARNING: will only work on 5.005_57 and beyond
.Ve
.SH "VERSION"
$Id: Scalar.pm,v 2.104 2001/08/09 08:04:44 eryq Exp $
.SH "AUTHORS"
.Sh "Principal author"
Eryq (\fIeryq@zeegee.com\fR).
President, ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
.Sh "Other contributors "
The full set of contributors always includes the folks mentioned
in the section on \fI\s-1CHANGE\s0 \s-1LOG\s0\fR in the \fI\s-1IO::\s0Stringy\fR manpage.  But just the same, special
thanks to the following individuals for their invaluable contributions
(if I've forgotten or misspelled your name, please email me!):
.PP
\fIAndy Glew,\fR
for contributing \f(CWgetc()\fR.
.PP
\fIBrandon Browning,\fR
for suggesting \f(CWopened()\fR.
.PP
\fIDavid Richter,\fR
for finding and fixing the bug in \f(CWPRINTF()\fR.
.PP
\fIEric L. Brine,\fR
for his offset-using \fIread()\fR and \fIwrite()\fR implementations. 
.PP
\fIRichard Jones,\fR
for his patches to massively improve the performance of \f(CWgetline()\fR
and add \f(CWsysread\fR and \f(CWsyswrite\fR.
.PP
\fIB. K. Oxley (binkley),\fR
for stringification and inheritance improvements,
and sundry good ideas.
.PP
\fIDoug Wilson,\fR
for the \s-1IO::\s0Handle inheritance and automatic tie-ing.
.SH "SEE ALSO"
the \fIIO::String\fR manpage, which is quite similar but which was designed
more-recently and with an IO::Handle-like interface in mind, 
so you could mix OO\- and native-filehandle usage without using \fItied()\fR.  
.PP
\fINote:\fR as of version 2.x, these classes all work like 
their IO::Handle counterparts, so we have comparable
functionality to IO::String.

.rn }` ''
.IX Title "lib::IO::Scalar 3"
.IX Name "IO::Scalar - IO:: interface for reading/writing a scalar"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "PUBLIC INTERFACE"

.IX Subsection "Construction "

.IX Item "new [\s-1ARGS\s0...]"

.IX Item "open [\s-1SCALARREF\s0]"

.IX Item "opened"

.IX Item "close"

.IX Subsection "Input and output"

.IX Item "flush "

.IX Item "getc"

.IX Item "getline"

.IX Item "getlines"

.IX Item "print \s-1ARGS\s0..."

.IX Item "read \s-1BUF\s0, \s-1NBYTES\s0, [\s-1OFFSET\s0]"

.IX Item "write \s-1BUF\s0, \s-1NBYTES\s0, [\s-1OFFSET\s0]"

.IX Item "sysread \s-1BUF\s0, \s-1LEN\s0, [\s-1OFFSET\s0]"

.IX Item "syswrite \s-1BUF\s0, \s-1NBYTES\s0, [\s-1OFFSET\s0]"

.IX Subsection "Seeking/telling and other attributes"

.IX Item "autoflush "

.IX Item "binmode"

.IX Item "clearerr"

.IX Item "eof "

.IX Item "seek \s-1OFFSET\s0, \s-1WHENCE\s0"

.IX Item "sysseek \s-1OFFSET\s0, \s-1WHENCE\s0"

.IX Item "tell"

.IX Item "setpos \s-1POS\s0"

.IX Item "getpos "

.IX Item "sref"

.IX Header "WARNINGS"

.IX Header "VERSION"

.IX Header "AUTHORS"

.IX Subsection "Principal author"

.IX Subsection "Other contributors "

.IX Header "SEE ALSO"

