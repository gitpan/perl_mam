.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::HTML::Element 3 "perl 5.004, patch 01" "25/Nov/96" "User Contributed Perl Documentation"
.IX Title "lib::HTML::Element 3"
.UC
.IX Name "HTML::Element - Class for objects that represent HTML elements"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
HTML::Element \- Class for objects that represent HTML elements
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 3
\& require HTML::Element;
\& $a = new HTML::Element 'a', href => 'http://www.oslonett.no/';
\& $a->push_content("Oslonett AS");
.Ve
.Vb 4
\& $tag = $a->tag;
\& $tag = $a->starttag;
\& $tag = $a->endtag;
\& $ref = $a->attr('href');
.Ve
.Vb 1
\& $links = $a->extract_links();
.Ve
.Vb 1
\& print $a->as_HTML;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Objects of the HTML::Element class can be used to represent elements
of HTML.  These objects have attributes and content.  The content is an
array of text segments and other HTML::Element objects.  Thus a
tree of HTML::Element objects as nodes can represent the syntax tree
for a HTML document.
.PP
The following methods are available:
.Sh "\f(CW$h\fR = \s-1HTML::\s0Element->\fInew\fR\|('tag\*(S', \*(M'attrname\*(S' => \*(M'value\*(S',...)"
.IX Subsection "\f(CW$h\fR = \s-1HTML::\s0Element->\fInew\fR\|('tag\*(S', \*(M'attrname\*(S' => \*(M'value\*(S',...)"
The object constructor.  Takes a tag name as argument. Optionally,
allows you to specify initial attributes at object creation time.
.Sh "\f(CW$h\fR\->\fItag()\fR"
.IX Subsection "\f(CW$h\fR\->\fItag()\fR"
Returns (optionally sets) the tag name for the element.  The tag is
always converted to lower case.
.Sh "\f(CW$h\fR\->\fIstarttag()\fR"
.IX Subsection "\f(CW$h\fR\->\fIstarttag()\fR"
Returns the complete start tag for the element.  Including leading
\*(L"<\*(R", trailing \*(L">\*(R" and attributes.
.Sh "\f(CW$h\fR\->\fIendtag()\fR"
.IX Subsection "\f(CW$h\fR\->\fIendtag()\fR"
Returns the complete end tag.  Includes leading \*(L"</\*(R" and the trailing
\*(L">\*(R".
.Sh "\f(CW$h\fR\->\fIparent\fR\|([$newparent])"
.IX Subsection "\f(CW$h\fR\->\fIparent\fR\|([$newparent])"
Returns (optionally sets) the parent for this element.
.Sh "\f(CW$h\fR\->\fIimplicit\fR\|([$bool])"
.IX Subsection "\f(CW$h\fR\->\fIimplicit\fR\|([$bool])"
Returns (optionally sets) the implicit attribute.  This attribute is
used to indicate that the element was not originally present in the
source, but was inserted in order to conform to \s-1HTML\s0 strucure.
.Sh "\f(CW$h\fR\->\fIis_inside\fR\|('tag\*(S',...)"
.IX Subsection "\f(CW$h\fR\->\fIis_inside\fR\|('tag\*(S',...)"
Returns true if this tag is contained inside one of the specified tags.
.Sh "\f(CW$h\fR\->\fIpos()\fR"
.IX Subsection "\f(CW$h\fR\->\fIpos()\fR"
Returns (and optionally sets) the current position.  The position is a
reference to a \s-1HTML::\s0Element object that is part of the tree that has
the current object as root.  This restriction is not enforced when
setting \fIpos()\fR, but unpredictable things will happen if this is not
true.
.Sh "\f(CW$h\fR\->\fIattr\fR\|('attr\*(S', [$value])"
.IX Subsection "\f(CW$h\fR\->\fIattr\fR\|('attr\*(S', [$value])"
Returns (and optionally sets) the value of some attribute.
.Sh "\f(CW$h\fR\->\fIcontent()\fR"
.IX Subsection "\f(CW$h\fR\->\fIcontent()\fR"
Returns the content of this element.  The content is represented as a
reference to an array of text segments and references to other
\s-1HTML::\s0Element objects.
.Sh "\f(CW$h\fR\->\fIis_empty()\fR"
.IX Subsection "\f(CW$h\fR\->\fIis_empty()\fR"
Returns true if there is no content.
.Sh "\f(CW$h\fR\->\fIinsert_element\fR\|($element, \f(CW$implicit\fR)"
.IX Subsection "\f(CW$h\fR\->\fIinsert_element\fR\|($element, \f(CW$implicit\fR)"
Inserts a new element at current position and updates \fIpos()\fR to point
to the inserted element.  Returns \f(CW$element\fR.
.Sh "\f(CW$h\fR\->\fIpush_content\fR\|($element_or_text,...)"
.IX Subsection "\f(CW$h\fR\->\fIpush_content\fR\|($element_or_text,...)"
Adds to the content of the element.  The content should be a text
segment (scalar) or a reference to a \s-1HTML::\s0Element object.
.Sh "\f(CW$h\fR\->\fIdelete_content()\fR"
.IX Subsection "\f(CW$h\fR\->\fIdelete_content()\fR"
Clears the content.
.Sh "\f(CW$h\fR\->\fIdelete()\fR"
.IX Subsection "\f(CW$h\fR\->\fIdelete()\fR"
Frees memory associated with the element and all children.  This is
needed because perl's reference counting does not work since we use
circular references.
.Sh "\f(CW$h\fR\->\fItraverse\fR\|(\e&callback, [$ignoretext])"
.IX Subsection "\f(CW$h\fR\->\fItraverse\fR\|(\e&callback, [$ignoretext])"
Traverse the element and all of its children.  For each node visited, the
callback routine is called with the node, a startflag and the depth as
arguments.  If the \f(CW$ignoretext\fR parameter is true, then the callback
will not be called for text content.  The flag is 1 when we enter a
node and 0 when we leave the node.
.PP
If the returned value from the callback is false then we will not
traverse the children.
.Sh "\f(CW$h\fR\->\fIextract_links\fR\|([@wantedTypes])"
.IX Subsection "\f(CW$h\fR\->\fIextract_links\fR\|([@wantedTypes])"
Returns links found by traversing the element and all of its children.
The return value is a reference to an array.  Each element of the
array is an array with 2 values; the link value and a reference to the
corresponding element.
.PP
You might specify that you just want to extract some types of links.
For instance if you only want to extract <a href=\*(R"..."> and <img
src=\*(R"..."> links you might code it like this:
.PP
.Vb 4
\&  for (@{ $e->extract_links(qw(a img)) }) {
\&      ($link, $linkelem) = @$_;
\&      ...
\&  }
.Ve
.Sh "\f(CW$h\fR\->\fIdump()\fR"
.IX Subsection "\f(CW$h\fR\->\fIdump()\fR"
Prints the element and all its children to \s-1STDOUT\s0.  Mainly useful for
debugging.  The structure of the document is shown by indentation (no
end tags).
.Sh "\f(CW$h\fR\->\fIas_HTML()\fR"
.IX Subsection "\f(CW$h\fR\->\fIas_HTML()\fR"
Returns a string (the \s-1HTML\s0 document) that represents the element and
its children.
.SH "BUGS"
.IX Header "BUGS"
If you want to free the memory assosiated with a tree built of
HTML::Element nodes then you will have to delete it explicitly.  The
reason for this is that perl currently has no proper garbage
collector, but depends on reference counts in the objects.  This
scheme fails because the parse tree contains circular references
(parents have references to their children and children have a
reference to their parent).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the \fIHTML::AsSubs\fR manpage
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995,1996 Gisle Aas.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gisle Aas <aas@sn.no>

.rn }` ''
