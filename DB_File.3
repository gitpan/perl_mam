.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH DB_File 3 "perl 5.005, patch 53" "10/Jun/98" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
DB_File \- Perl5 access to Berkeley DB version 1.x
.SH "SYNOPSIS"
.PP
.Vb 5
\& use DB_File ;
\& 
\& [$X =] tie %hash,  'DB_File', [$filename, $flags, $mode, $DB_HASH] ;
\& [$X =] tie %hash,  'DB_File', $filename, $flags, $mode, $DB_BTREE ;
\& [$X =] tie @array, 'DB_File', $filename, $flags, $mode, $DB_RECNO ;
.Ve
.Vb 6
\& $status = $X->del($key [, $flags]) ;
\& $status = $X->put($key, $value [, $flags]) ;
\& $status = $X->get($key, $value [, $flags]) ;
\& $status = $X->seq($key, $value, $flags) ;
\& $status = $X->sync([$flags]) ;
\& $status = $X->fd ;
.Ve
.Vb 4
\& # BTREE only
\& $count = $X->get_dup($key) ;
\& @list  = $X->get_dup($key) ;
\& %list  = $X->get_dup($key, 1) ;
.Ve
.Vb 6
\& # RECNO only
\& $a = $X->length;
\& $a = $X->pop ;
\& $X->push(list);
\& $a = $X->shift;
\& $X->unshift(list);
.Ve
.Vb 2
\& untie %hash ;
\& untie @array ;
.Ve
.SH "DESCRIPTION"
\fBDB_File\fR is a module which allows Perl programs to make use of the
facilities provided by Berkeley DB version 1.x (if you have a newer
version of DB, see the section on \fIUsing DB_File with Berkeley DB version 2\fR). It is
assumed that you have a copy of the Berkeley DB manual pages at hand
when reading this documentation. The interface defined here mirrors the
Berkeley DB interface closely.
.PP
Berkeley DB is a C library which provides a consistent interface to a
number of database formats.  \fBDB_File\fR provides an interface to all
three of the database types currently supported by Berkeley DB.
.PP
The file types are:
.Ip "\fB\s-1DB_HASH\s0\fR" 5
This database type allows arbitrary key/value pairs to be stored in data
files. This is equivalent to the functionality provided by other
hashing packages like \s-1DBM\s0, \s-1NDBM\s0, \s-1ODBM\s0, \s-1GDBM\s0, and \s-1SDBM\s0. Remember though,
the files created using \s-1DB_HASH\s0 are not compatible with any of the
other packages mentioned.
.Sp
A default hashing algorithm, which will be adequate for most
applications, is built into Berkeley \s-1DB\s0. If you do need to use your own
hashing algorithm it is possible to write your own in Perl and have
\fBDB_File\fR use it instead.
.Ip "\fB\s-1DB_BTREE\s0\fR" 5
The btree format allows arbitrary key/value pairs to be stored in a
sorted, balanced binary tree.
.Sp
As with the \s-1DB_HASH\s0 format, it is possible to provide a user defined
Perl routine to perform the comparison of keys. By default, though, the
keys are stored in lexical order.
.Ip "\fB\s-1DB_RECNO\s0\fR" 5
\s-1DB_RECNO\s0 allows both fixed-length and variable-length flat text files
to be manipulated using the same key/value pair interface as in \s-1DB_HASH\s0
and \s-1DB_BTREE\s0.  In this case the key will consist of a record (line)
number.
.Sh "Using DB_File with Berkeley \s-1DB\s0 version 2"
Although \fBDB_File\fR is intended to be used with Berkeley \s-1DB\s0 version 1,
it can also be used with version 2. In this case the interface is
limited to the functionality provided by Berkeley \s-1DB\s0 1.x. Anywhere the
version 2 interface differs, \fBDB_File\fR arranges for it to work like
version 1. This feature allows \fBDB_File\fR scripts that were built with
version 1 to be migrated to version 2 without any changes.
.PP
If you want to make use of the new features available in Berkeley \s-1DB\s0
2.x, use the Perl module \fBBerkeleyDB\fR instead.
.PP
At the time of writing this document the \fBBerkeleyDB\fR module is still
alpha quality (the version number is < 1.0), and so unsuitable for use
in any serious development work. Once its version number is >= 1.0, it
is considered stable enough for real work.
.PP
\fBNote:\fR The database file format has changed in Berkeley \s-1DB\s0 version 2.
If you cannot recreate your databases, you must dump any existing
databases with the \f(CWdb_dump185\fR utility that comes with Berkeley \s-1DB\s0.
Once you have upgraded DB_File to use Berkeley \s-1DB\s0 version 2, your
databases can be recreated using \f(CWdb_load\fR. Refer to the Berkeley \s-1DB\s0
documentation for further details.
.PP
Please read the \fI\s-1COPYRIGHT\s0\fR manpage before using version 2.x of Berkeley \s-1DB\s0 with
DB_File.
.Sh "Interface to Berkeley \s-1DB\s0"
\fBDB_File\fR allows access to Berkeley \s-1DB\s0 files using the \fItie()\fR mechanism
in Perl 5 (for full details, see the \f(CWtie()\fR entry in the \fIperlfunc\fR manpage). This facility
allows \fBDB_File\fR to access Berkeley \s-1DB\s0 files using either an
associative array (for \s-1DB_HASH\s0 & \s-1DB_BTREE\s0 file types) or an ordinary
array (for the \s-1DB_RECNO\s0 file type).
.PP
In addition to the \fItie()\fR interface, it is also possible to access most
of the functions provided in the Berkeley \s-1DB\s0 \s-1API\s0 directly.
See the section on \fI\s-1THE\s0 \s-1API\s0 \s-1INTERFACE\s0\fR.
.Sh "Opening a Berkeley \s-1DB\s0 Database File"
Berkeley \s-1DB\s0 uses the function \fIdbopen()\fR to open or create a database.
Here is the C prototype for \fIdbopen()\fR:
.PP
.Vb 3
\&      DB*
\&      dbopen (const char * file, int flags, int mode, 
\&              DBTYPE type, const void * openinfo)
.Ve
The parameter \f(CWtype\fR is an enumeration which specifies which of the 3
interface methods (\s-1DB_HASH\s0, \s-1DB_BTREE\s0 or \s-1DB_RECNO\s0) is to be used.
Depending on which of these is actually chosen, the final parameter,
\fIopeninfo\fR points to a data structure which allows tailoring of the
specific interface method.
.PP
This interface is handled slightly differently in \fBDB_File\fR. Here is
an equivalent call using \fBDB_File\fR:
.PP
.Vb 1
\&        tie %array, 'DB_File', $filename, $flags, $mode, $DB_HASH ;
.Ve
The \f(CWfilename\fR, \f(CWflags\fR and \f(CWmode\fR parameters are the direct
equivalent of their \fIdbopen()\fR counterparts. The final parameter \f(CW$DB_HASH\fR
performs the function of both the \f(CWtype\fR and \f(CWopeninfo\fR parameters in
\fIdbopen()\fR.
.PP
In the example above \f(CW$DB_HASH\fR is actually a pre-defined reference to a
hash object. \fBDB_File\fR has three of these pre-defined references.
Apart from \f(CW$DB_HASH\fR, there is also \f(CW$DB_BTREE\fR and \f(CW$DB_RECNO\fR.
.PP
The keys allowed in each of these pre-defined references is limited to
the names used in the equivalent C structure. So, for example, the
\f(CW$DB_HASH\fR reference will only allow keys called \f(CWbsize\fR, \f(CWcachesize\fR,
\f(CWffactor\fR, \f(CWhash\fR, \f(CWlorder\fR and \f(CWnelem\fR. 
.PP
To change one of these elements, just assign to it like this:
.PP
.Vb 1
\&        $DB_HASH->{'cachesize'} = 10000 ;
.Ve
The three predefined variables \f(CW$DB_HASH\fR, \f(CW$DB_BTREE\fR and \f(CW$DB_RECNO\fR are
usually adequate for most applications.  If you do need to create extra
instances of these objects, constructors are available for each file
type.
.PP
Here are examples of the constructors and the valid options available
for \s-1DB_HASH\s0, \s-1DB_BTREE\s0 and \s-1DB_RECNO\s0 respectively.
.PP
.Vb 7
\&     $a = new DB_File::HASHINFO ;
\&     $a->{'bsize'} ;
\&     $a->{'cachesize'} ;
\&     $a->{'ffactor'};
\&     $a->{'hash'} ;
\&     $a->{'lorder'} ;
\&     $a->{'nelem'} ;
.Ve
.Vb 9
\&     $b = new DB_File::BTREEINFO ;
\&     $b->{'flags'} ;
\&     $b->{'cachesize'} ;
\&     $b->{'maxkeypage'} ;
\&     $b->{'minkeypage'} ;
\&     $b->{'psize'} ;
\&     $b->{'compare'} ;
\&     $b->{'prefix'} ;
\&     $b->{'lorder'} ;
.Ve
.Vb 8
\&     $c = new DB_File::RECNOINFO ;
\&     $c->{'bval'} ;
\&     $c->{'cachesize'} ;
\&     $c->{'psize'} ;
\&     $c->{'flags'} ;
\&     $c->{'lorder'} ;
\&     $c->{'reclen'} ;
\&     $c->{'bfname'} ;
.Ve
The values stored in the hashes above are mostly the direct equivalent
of their C counterpart. Like their C counterparts, all are set to a
default values \- that means you don't have to set \fIall\fR of the
values when you only want to change one. Here is an example:
.PP
.Vb 3
\&     $a = new DB_File::HASHINFO ;
\&     $a->{'cachesize'} =  12345 ;
\&     tie %y, 'DB_File', "filename", $flags, 0777, $a ;
.Ve
A few of the options need extra discussion here. When used, the C
equivalent of the keys \f(CWhash\fR, \f(CWcompare\fR and \f(CWprefix\fR store pointers
to C functions. In \fBDB_File\fR these keys are used to store references
to Perl subs. Below are templates for each of the subs:
.PP
.Vb 7
\&    sub hash
\&    {
\&        my ($data) = @_ ;
\&        ...
\&        # return the hash value for $data
\&        return $hash ;
\&    }
.Ve
.Vb 9
\&    sub compare
\&    {
\&        my ($key, $key2) = @_ ;
\&        ...
\&        # return  0 if $key1 eq $key2
\&        #        -1 if $key1 lt $key2
\&        #         1 if $key1 gt $key2
\&        return (-1 , 0 or 1) ;
\&    }
.Ve
.Vb 8
\&    sub prefix
\&    {
\&        my ($key, $key2) = @_ ;
\&        ...
\&        # return number of bytes of $key2 which are 
\&        # necessary to determine that it is greater than $key1
\&        return $bytes ;
\&    }
.Ve
See the section on \fIChanging the \s-1BTREE\s0 sort order\fR for an example of using the
\f(CWcompare\fR template.
.PP
If you are using the \s-1DB_RECNO\s0 interface and you intend making use of
\f(CWbval\fR, you should check out the section on \fIThe \*(L'bval\*(R' Option\fR.
.Sh "Default Parameters"
It is possible to omit some or all of the final 4 parameters in the
call to \f(CWtie\fR and let them take default values. As \s-1DB_HASH\s0 is the most
common file format used, the call:
.PP
.Vb 1
\&    tie %A, "DB_File", "filename" ;
.Ve
is equivalent to:
.PP
.Vb 1
\&    tie %A, "DB_File", "filename", O_CREAT|O_RDWR, 0666, $DB_HASH ;
.Ve
It is also possible to omit the filename parameter as well, so the
call:
.PP
.Vb 1
\&    tie %A, "DB_File" ;
.Ve
is equivalent to:
.PP
.Vb 1
\&    tie %A, "DB_File", undef, O_CREAT|O_RDWR, 0666, $DB_HASH ;
.Ve
See the section on \fIIn Memory Databases\fR for a discussion on the use of \f(CWundef\fR
in place of a filename.
.Sh "In Memory Databases"
Berkeley \s-1DB\s0 allows the creation of in-memory databases by using \s-1NULL\s0
(that is, a \f(CW(char *)0\fR in C) in place of the filename.  \fBDB_File\fR
uses \f(CWundef\fR instead of \s-1NULL\s0 to provide this functionality.
.SH "DB_HASH"
The DB_HASH file format is probably the most commonly used of the three
file formats that \fBDB_File\fR supports. It is also very straightforward
to use.
.Sh "A Simple Example"
This example shows how to create a database, add key/value pairs to the
database, delete keys/value pairs and finally how to enumerate the
contents of the database.
.PP
.Vb 3
\&    use strict ;
\&    use DB_File ;
\&    use vars qw( %h $k $v ) ;
.Ve
.Vb 2
\&    tie %h, "DB_File", "fruit", O_RDWR|O_CREAT, 0640, $DB_HASH 
\&        or die "Cannot open file 'fruit': $!\en";
.Ve
.Vb 5
\&    # Add a few key/value pairs to the file
\&    $h{"apple"} = "red" ;
\&    $h{"orange"} = "orange" ;
\&    $h{"banana"} = "yellow" ;
\&    $h{"tomato"} = "red" ;
.Ve
.Vb 2
\&    # Check for existence of a key
\&    print "Banana Exists\en\en" if $h{"banana"} ;
.Ve
.Vb 2
\&    # Delete a key/value pair.
\&    delete $h{"apple"} ;
.Ve
.Vb 3
\&    # print the contents of the file
\&    while (($k, $v) = each %h)
\&      { print "$k -> $v\en" }
.Ve
.Vb 1
\&    untie %h ;
.Ve
here is the output:
.PP
.Vb 5
\&    Banana Exists
\& 
\&    orange -> orange
\&    tomato -> red
\&    banana -> yellow
.Ve
Note that the like ordinary associative arrays, the order of the keys
retrieved is in an apparently random order.
.SH "DB_BTREE"
The DB_BTREE format is useful when you want to store data in a given
order. By default the keys will be stored in lexical order, but as you
will see from the example shown in the next section, it is very easy to
define your own sorting function.
.Sh "Changing the \s-1BTREE\s0 sort order"
This script shows how to override the default sorting algorithm that
\s-1BTREE\s0 uses. Instead of using the normal lexical ordering, a case
insensitive compare function will be used.
.PP
.Vb 2
\&    use strict ;
\&    use DB_File ;
.Ve
.Vb 1
\&    my %h ;
.Ve
.Vb 5
\&    sub Compare
\&    {
\&        my ($key1, $key2) = @_ ;
\&        "\eL$key1" cmp "\eL$key2" ;
\&    }
.Ve
.Vb 2
\&    # specify the Perl sub that will do the comparison
\&    $DB_BTREE->{'compare'} = \e&Compare ;
.Ve
.Vb 2
\&    tie %h, "DB_File", "tree", O_RDWR|O_CREAT, 0640, $DB_BTREE 
\&        or die "Cannot open file 'tree': $!\en" ;
.Ve
.Vb 5
\&    # Add a key/value pair to the file
\&    $h{'Wall'} = 'Larry' ;
\&    $h{'Smith'} = 'John' ;
\&    $h{'mouse'} = 'mickey' ;
\&    $h{'duck'}  = 'donald' ;
.Ve
.Vb 2
\&    # Delete
\&    delete $h{"duck"} ;
.Ve
.Vb 5
\&    # Cycle through the keys printing them in order.
\&    # Note it is not necessary to sort the keys as
\&    # the btree will have kept them in order automatically.
\&    foreach (keys %h)
\&      { print "$_\en" }
.Ve
.Vb 1
\&    untie %h ;
.Ve
Here is the output from the code above.
.PP
.Vb 3
\&    mouse
\&    Smith
\&    Wall
.Ve
There are a few point to bear in mind if you want to change the
ordering in a \s-1BTREE\s0 database:
.Ip "1." 5
The new compare function must be specified when you create the database.
.Ip "2." 5
You cannot change the ordering once the database has been created. Thus
you must use the same compare function every time you access the
database.
.Sh "Handling Duplicate Keys "
The \s-1BTREE\s0 file type optionally allows a single key to be associated
with an arbitrary number of values. This option is enabled by setting
the flags element of \f(CW$DB_BTREE\fR to R_DUP when creating the database.
.PP
There are some difficulties in using the tied hash interface if you
want to manipulate a \s-1BTREE\s0 database with duplicate keys. Consider this
code:
.PP
.Vb 2
\&    use strict ;
\&    use DB_File ;
.Ve
.Vb 1
\&    use vars qw($filename %h ) ;
.Ve
.Vb 15
\&    $filename = "tree" ;
\&    unlink $filename ;
\& 
\&    # Enable duplicate records
\&    $DB_BTREE->{'flags'} = R_DUP ;
\& 
\&    tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
\&        or die "Cannot open $filename: $!\en";
\& 
\&    # Add some key/value pairs to the file
\&    $h{'Wall'} = 'Larry' ;
\&    $h{'Wall'} = 'Brick' ; # Note the duplicate key
\&    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
\&    $h{'Smith'} = 'John' ;
\&    $h{'mouse'} = 'mickey' ;
.Ve
.Vb 4
\&    # iterate through the associative array
\&    # and print each key/value pair.
\&    foreach (keys %h)
\&      { print "$_  -> $h{$_}\en" }
.Ve
.Vb 1
\&    untie %h ;
.Ve
Here is the output:
.PP
.Vb 5
\&    Smith   -> John
\&    Wall    -> Larry
\&    Wall    -> Larry
\&    Wall    -> Larry
\&    mouse   -> mickey
.Ve
As you can see 3 records have been successfully created with key \f(CWWall\fR
\- the only thing is, when they are retrieved from the database they
\fIseem\fR to have the same value, namely \f(CWLarry\fR. The problem is caused
by the way that the associative array interface works. Basically, when
the associative array interface is used to fetch the value associated
with a given key, it will only ever retrieve the first value.
.PP
Although it may not be immediately obvious from the code above, the
associative array interface can be used to write values with duplicate
keys, but it cannot be used to read them back from the database.
.PP
The way to get around this problem is to use the Berkeley \s-1DB\s0 \s-1API\s0 method
called \f(CWseq\fR.  This method allows sequential access to key/value
pairs. See the section on \fI\s-1THE\s0 \s-1API\s0 \s-1INTERFACE\s0\fR for details of both the \f(CWseq\fR method
and the \s-1API\s0 in general.
.PP
Here is the script above rewritten using the \f(CWseq\fR \s-1API\s0 method.
.PP
.Vb 4
\&    use strict ;
\&    use DB_File ;
\& 
\&    use vars qw($filename $x %h $status $key $value) ;
.Ve
.Vb 26
\&    $filename = "tree" ;
\&    unlink $filename ;
\& 
\&    # Enable duplicate records
\&    $DB_BTREE->{'flags'} = R_DUP ;
\& 
\&    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
\&        or die "Cannot open $filename: $!\en";
\& 
\&    # Add some key/value pairs to the file
\&    $h{'Wall'} = 'Larry' ;
\&    $h{'Wall'} = 'Brick' ; # Note the duplicate key
\&    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
\&    $h{'Smith'} = 'John' ;
\&    $h{'mouse'} = 'mickey' ;
\& 
\&    # iterate through the btree using seq
\&    # and print each key/value pair.
\&    $key = $value = 0 ;
\&    for ($status = $x->seq($key, $value, R_FIRST) ;
\&         $status == 0 ;
\&         $status = $x->seq($key, $value, R_NEXT) )
\&      {  print "$key -> $value\en" }
\& 
\&    undef $x ;
\&    untie %h ;
.Ve
that prints:
.PP
.Vb 5
\&    Smith   -> John
\&    Wall    -> Brick
\&    Wall    -> Brick
\&    Wall    -> Larry
\&    mouse   -> mickey
.Ve
This time we have got all the key/value pairs, including the multiple
values associated with the key \f(CWWall\fR.
.Sh "The \fIget_dup()\fR Method"
\fBDB_File\fR comes with a utility method, called \f(CWget_dup\fR, to assist in
reading duplicate values from \s-1BTREE\s0 databases. The method can take the
following forms:
.PP
.Vb 3
\&    $count = $x->get_dup($key) ;
\&    @list  = $x->get_dup($key) ;
\&    %list  = $x->get_dup($key, 1) ;
.Ve
In a scalar context the method returns the number of values associated
with the key, \f(CW$key\fR.
.PP
In list context, it returns all the values which match \f(CW$key\fR. Note
that the values will be returned in an apparently random order.
.PP
In list context, if the second parameter is present and evaluates
\s-1TRUE\s0, the method returns an associative array. The keys of the
associative array correspond to the values that matched in the \s-1BTREE\s0
and the values of the array are a count of the number of times that
particular value occurred in the \s-1BTREE\s0.
.PP
So assuming the database created above, we can use \f(CWget_dup\fR like
this:
.PP
.Vb 2
\&    my $cnt  = $x->get_dup("Wall") ;
\&    print "Wall occurred $cnt times\en" ;
.Ve
.Vb 3
\&    my %hash = $x->get_dup("Wall", 1) ;
\&    print "Larry is there\en" if $hash{'Larry'} ;
\&    print "There are $hash{'Brick'} Brick Walls\en" ;
.Ve
.Vb 2
\&    my @list = $x->get_dup("Wall") ;
\&    print "Wall =>      [@list]\en" ;
.Ve
.Vb 5
\&    @list = $x->get_dup("Smith") ;
\&    print "Smith =>     [@list]\en" ;
\& 
\&    @list = $x->get_dup("Dog") ;
\&    print "Dog =>       [@list]\en" ;
.Ve
and it will print:
.PP
.Vb 6
\&    Wall occurred 3 times
\&    Larry is there
\&    There are 2 Brick Walls
\&    Wall =>     [Brick Brick Larry]
\&    Smith =>    [John]
\&    Dog =>      []
.Ve
.Sh "Matching Partial Keys "
The \s-1BTREE\s0 interface has a feature which allows partial keys to be
matched. This functionality is \fIonly\fR available when the \f(CWseq\fR method
is used along with the R_CURSOR flag.
.PP
.Vb 1
\&    $x->seq($key, $value, R_CURSOR) ;
.Ve
Here is the relevant quote from the dbopen man page where it defines
the use of the R_CURSOR flag with seq:
.PP
.Vb 4
\&    Note, for the DB_BTREE access method, the returned key is not
\&    necessarily an exact match for the specified key. The returned key
\&    is the smallest key greater than or equal to the specified key,
\&    permitting partial key matches and range searches.
.Ve
In the example script below, the \f(CWmatch\fR sub uses this feature to find
and print the first matching key/value pair given a partial key.
.PP
.Vb 3
\&    use strict ;
\&    use DB_File ;
\&    use Fcntl ;
.Ve
.Vb 1
\&    use vars qw($filename $x %h $st $key $value) ;
.Ve
.Vb 8
\&    sub match
\&    {
\&        my $key = shift ;
\&        my $value = 0;
\&        my $orig_key = $key ;
\&        $x->seq($key, $value, R_CURSOR) ;
\&        print "$orig_key\et-> $key\et-> $value\en" ;
\&    }
.Ve
.Vb 2
\&    $filename = "tree" ;
\&    unlink $filename ;
.Ve
.Vb 9
\&    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE
\&        or die "Cannot open $filename: $!\en";
\& 
\&    # Add some key/value pairs to the file
\&    $h{'mouse'} = 'mickey' ;
\&    $h{'Wall'} = 'Larry' ;
\&    $h{'Walls'} = 'Brick' ; 
\&    $h{'Smith'} = 'John' ;
\& 
.Ve
.Vb 9
\&    $key = $value = 0 ;
\&    print "IN ORDER\en" ;
\&    for ($st = $x->seq($key, $value, R_FIRST) ;
\&         $st == 0 ;
\&         $st = $x->seq($key, $value, R_NEXT) )
\&        
\&      {  print "$key -> $value\en" }
\& 
\&    print "\enPARTIAL MATCH\en" ;
.Ve
.Vb 3
\&    match "Wa" ;
\&    match "A" ;
\&    match "a" ;
.Ve
.Vb 2
\&    undef $x ;
\&    untie %h ;
.Ve
Here is the output:
.PP
.Vb 5
\&    IN ORDER
\&    Smith -> John
\&    Wall  -> Larry
\&    Walls -> Brick
\&    mouse -> mickey
.Ve
.Vb 4
\&    PARTIAL MATCH
\&    Wa -> Wall  -> Larry
\&    A  -> Smith -> John
\&    a  -> mouse -> mickey
.Ve
.SH "DB_RECNO"
DB_RECNO provides an interface to flat text files. Both variable and
fixed length records are supported.
.PP
In order to make RECNO more compatible with Perl the array offset for
all RECNO arrays begins at 0 rather than 1 as in Berkeley DB.
.PP
As with normal Perl arrays, a RECNO array can be accessed using
negative indexes. The index \-1 refers to the last element of the array,
\-2 the second last, and so on. Attempting to access an element before
the start of the array will raise a fatal run-time error.
.Sh "The \*(M'bval\*(S' Option"
The operation of the bval option warrants some discussion. Here is the
definition of bval from the Berkeley \s-1DB\s0 1.85 recno manual page:
.PP
.Vb 6
\&    The delimiting byte to be used to mark  the  end  of  a
\&    record for variable-length records, and the pad charac-
\&    ter for fixed-length records.  If no  value  is  speci-
\&    fied,  newlines  (``\en'')  are  used to mark the end of
\&    variable-length records and  fixed-length  records  are
\&    padded with spaces.
.Ve
The second sentence is wrong. In actual fact bval will only default to
\f(CW"\en"\fR when the openinfo parameter in dbopen is \s-1NULL\s0. If a non-\s-1NULL\s0
openinfo parameter is used at all, the value that happens to be in bval
will be used. That means you always have to specify bval when making
use of any of the options in the openinfo parameter. This documentation
error will be fixed in the next release of Berkeley \s-1DB\s0.
.PP
That clarifies the situation with regards Berkeley \s-1DB\s0 itself. What
about \fBDB_File\fR? Well, the behavior defined in the quote above is
quite useful, so \fBDB_File\fR conforms it.
.PP
That means that you can specify other options (e.g. cachesize) and
still have bval default to \f(CW"\en"\fR for variable length records, and
space for fixed length records.
.Sh "A Simple Example"
Here is a simple example that uses \s-1RECNO\s0.
.PP
.Vb 2
\&    use strict ;
\&    use DB_File ;
.Ve
.Vb 3
\&    my @h ;
\&    tie @h, "DB_File", "text", O_RDWR|O_CREAT, 0640, $DB_RECNO 
\&        or die "Cannot open file 'text': $!\en" ;
.Ve
.Vb 4
\&    # Add a few key/value pairs to the file
\&    $h[0] = "orange" ;
\&    $h[1] = "blue" ;
\&    $h[2] = "yellow" ;
.Ve
.Vb 2
\&    # Check for existence of a key
\&    print "Element 1 Exists with value $h[1]\en" if $h[1] ;
.Ve
.Vb 3
\&    # use a negative index
\&    print "The last element is $h[-1]\en" ;
\&    print "The 2nd last element is $h[-2]\en" ;
.Ve
.Vb 1
\&    untie @h ;
.Ve
Here is the output from the script:
.PP
.Vb 3
\&    Element 1 Exists with value blue
\&    The last element is yellow
\&    The 2nd last element is blue
.Ve
.Sh "Extra Methods"
If you are using a version of Perl earlier than 5.004_57, the tied
array interface is quite limited. The example script above will work,
but you won't be able to use \f(CWpush\fR, \f(CWpop\fR, \f(CWshift\fR, \f(CWunshift\fR
etc. with the tied array.
.PP
To make the interface more useful for older versions of Perl, a number
of methods are supplied with \fBDB_File\fR to simulate the missing array
operations. All these methods are accessed via the object returned from
the tie call.
.PP
Here are the methods:
.Ip "\fB$X\->push(list) ;\fR" 5
Pushes the elements of \f(CWlist\fR to the end of the array.
.Ip "\fB$value = $X\->pop ;\fR" 5
Removes and returns the last element of the array.
.Ip "\fB$X\->shift\fR" 5
Removes and returns the first element of the array.
.Ip "\fB$X\->unshift(list) ;\fR" 5
Pushes the elements of \f(CWlist\fR to the start of the array.
.Ip "\fB$X\->length\fR" 5
Returns the number of elements in the array.
.Sh "Another Example"
Here is a more complete example that makes use of some of the methods
described above. It also makes use of the \s-1API\s0 interface directly (see 
the section on \fI\s-1THE\s0 \s-1API\s0 \s-1INTERFACE\s0\fR).
.PP
.Vb 6
\&    use strict ;
\&    use vars qw(@h $H $file $i) ;
\&    use DB_File ;
\&    use Fcntl ;
\&    
\&    $file = "text" ;
.Ve
.Vb 1
\&    unlink $file ;
.Ve
.Vb 9
\&    $H = tie @h, "DB_File", $file, O_RDWR|O_CREAT, 0640, $DB_RECNO 
\&        or die "Cannot open file $file: $!\en" ;
\&    
\&    # first create a text file to play with
\&    $h[0] = "zero" ;
\&    $h[1] = "one" ;
\&    $h[2] = "two" ;
\&    $h[3] = "three" ;
\&    $h[4] = "four" ;
.Ve
.Vb 6
\&    
\&    # Print the records in order.
\&    #
\&    # The length method is needed here because evaluating a tied
\&    # array in a scalar context does not return the number of
\&    # elements in the array.  
.Ve
.Vb 4
\&    print "\enORIGINAL\en" ;
\&    foreach $i (0 .. $H->length - 1) {
\&        print "$i: $h[$i]\en" ;
\&    }
.Ve
.Vb 4
\&    # use the push & pop methods
\&    $a = $H->pop ;
\&    $H->push("last") ;
\&    print "\enThe last record was [$a]\en" ;
.Ve
.Vb 4
\&    # and the shift & unshift methods
\&    $a = $H->shift ;
\&    $H->unshift("first") ;
\&    print "The first record was [$a]\en" ;
.Ve
.Vb 3
\&    # Use the API to add a new record after record 2.
\&    $i = 2 ;
\&    $H->put($i, "Newbie", R_IAFTER) ;
.Ve
.Vb 3
\&    # and a new record before record 1.
\&    $i = 1 ;
\&    $H->put($i, "New One", R_IBEFORE) ;
.Ve
.Vb 2
\&    # delete record 3
\&    $H->del(3) ;
.Ve
.Vb 4
\&    # now print the records in reverse order
\&    print "\enREVERSE\en" ;
\&    for ($i = $H->length - 1 ; $i >= 0 ; -- $i)
\&      { print "$i: $h[$i]\en" }
.Ve
.Vb 7
\&    # same again, but use the API functions instead
\&    print "\enREVERSE again\en" ;
\&    my ($s, $k, $v)  = (0, 0, 0) ;
\&    for ($s = $H->seq($k, $v, R_LAST) ; 
\&             $s == 0 ; 
\&             $s = $H->seq($k, $v, R_PREV))
\&      { print "$k: $v\en" }
.Ve
.Vb 2
\&    undef $H ;
\&    untie @h ;
.Ve
and this is what it outputs:
.PP
.Vb 6
\&    ORIGINAL
\&    0: zero
\&    1: one
\&    2: two
\&    3: three
\&    4: four
.Ve
.Vb 2
\&    The last record was [four]
\&    The first record was [zero]
.Ve
.Vb 7
\&    REVERSE
\&    5: last
\&    4: three
\&    3: Newbie
\&    2: one
\&    1: New One
\&    0: first
.Ve
.Vb 7
\&    REVERSE again
\&    5: last
\&    4: three
\&    3: Newbie
\&    2: one
\&    1: New One
\&    0: first
.Ve
Notes:
.Ip "1." 5
Rather than iterating through the array, \f(CW@h\fR like this:
.Sp
.Vb 1
\&    foreach $i (@h)
.Ve
it is necessary to use either this:
.Sp
.Vb 1
\&    foreach $i (0 .. $H->length - 1) 
.Ve
or this:
.Sp
.Vb 3
\&    for ($a = $H->get($k, $v, R_FIRST) ;
\&         $a == 0 ;
\&         $a = $H->get($k, $v, R_NEXT) )
.Ve
.Ip "2." 5
Notice that both times the \f(CWput\fR method was used the record index was
specified using a variable, \f(CW$i\fR, rather than the literal value
itself. This is because \f(CWput\fR will return the record number of the
inserted line via that parameter.
.SH "THE API INTERFACE"
As well as accessing Berkeley DB using a tied hash or array, it is also
possible to make direct use of most of the API functions defined in the
Berkeley DB documentation.
.PP
To do this you need to store a copy of the object returned from the tie.
.PP
.Vb 1
\&        $db = tie %hash, "DB_File", "filename" ;
.Ve
Once you have done that, you can access the Berkeley DB API functions
as \fBDB_File\fR methods directly like this:
.PP
.Vb 1
\&        $db->put($key, $value, R_NOOVERWRITE) ;
.Ve
\fBImportant:\fR If you have saved a copy of the object returned from
\f(CWtie\fR, the underlying database file will \fInot\fR be closed until both
the tied variable is untied and all copies of the saved object are
destroyed. 
.PP
.Vb 6
\&    use DB_File ;
\&    $db = tie %hash, "DB_File", "filename" 
\&        or die "Cannot tie filename: $!" ;
\&    ...
\&    undef $db ;
\&    untie %hash ;
.Ve
See the section on \fIThe untie() Gotcha\fR for more details.
.PP
All the functions defined in the \fIdbopen\fR manpage are available except for
\fIclose()\fR and \fIdbopen()\fR itself. The \fBDB_File\fR method interface to the
supported functions have been implemented to mirror the way Berkeley DB
works whenever possible. In particular note that:
.Ip "\(bu" 5
The methods return a status value. All return 0 on success.
All return \-1 to signify an error and set \f(CW$!\fR to the exact
error code. The return code 1 generally (but not always) means that the
key specified did not exist in the database.
.Sp
Other return codes are defined. See below and in the Berkeley \s-1DB\s0
documentation for details. The Berkeley \s-1DB\s0 documentation should be used
as the definitive source.
.Ip "\(bu" 5
Whenever a Berkeley \s-1DB\s0 function returns data via one of its parameters,
the equivalent \fBDB_File\fR method does exactly the same.
.Ip "\(bu" 5
If you are careful, it is possible to mix \s-1API\s0 calls with the tied
hash/array interface in the same piece of code. Although only a few of
the methods used to implement the tied interface currently make use of
the cursor, you should always assume that the cursor has been changed
any time the tied hash/array interface is used. As an example, this
code will probably not do what you expect:
.Sp
.Vb 2
\&    $X = tie %x, 'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE
\&        or die "Cannot tie $filename: $!" ;
.Ve
.Vb 2
\&    # Get the first key/value pair and set  the cursor
\&    $X->seq($key, $value, R_FIRST) ;
.Ve
.Vb 2
\&    # this line will modify the cursor
\&    $count = scalar keys %x ; 
.Ve
.Vb 3
\&    # Get the second key/value pair.
\&    # oops, it didn't, it got the last key/value pair!
\&    $X->seq($key, $value, R_NEXT) ;
.Ve
The code above can be rearranged to get around the problem, like this:
.Sp
.Vb 2
\&    $X = tie %x, 'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE
\&        or die "Cannot tie $filename: $!" ;
.Ve
.Vb 2
\&    # this line will modify the cursor
\&    $count = scalar keys %x ; 
.Ve
.Vb 2
\&    # Get the first key/value pair and set  the cursor
\&    $X->seq($key, $value, R_FIRST) ;
.Ve
.Vb 3
\&    # Get the second key/value pair.
\&    # worked this time.
\&    $X->seq($key, $value, R_NEXT) ;
.Ve
.PP
All the constants defined in the \fIdbopen\fR manpage for use in the flags parameters
in the methods defined below are also available. Refer to the Berkeley
\s-1DB\s0 documentation for the precise meaning of the flags values.
.PP
Below is a list of the methods available.
.Ip "\fB$status = $X\->get($key, $value [, $flags]) ;\fR" 5
Given a key (\f(CW$key\fR) this method reads the value associated with it
from the database. The value read from the database is returned in the
\f(CW$value\fR parameter.
.Sp
If the key does not exist the method returns 1.
.Sp
No flags are currently defined for this method.
.Ip "\fB$status = $X\->put($key, $value [, $flags]) ;\fR" 5
Stores the key/value pair in the database.
.Sp
If you use either the R_IAFTER or R_IBEFORE flags, the \f(CW$key\fR parameter
will have the record number of the inserted key/value pair set.
.Sp
Valid flags are R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE and
R_SETCURSOR.
.Ip "\fB$status = $X\->del($key [, $flags]) ;\fR" 5
Removes all key/value pairs with key \f(CW$key\fR from the database.
.Sp
A return code of 1 means that the requested key was not in the
database.
.Sp
R_CURSOR is the only valid flag at present.
.Ip "\fB$status = $X\->fd ;\fR" 5
Returns the file descriptor for the underlying database.
.Sp
See the section on \fILocking Databases\fR for an example of how to make use of the
\f(CWfd\fR method to lock your database.
.Ip "\fB$status = $X\->seq($key, $value, $flags) ;\fR" 5
This interface allows sequential retrieval from the database. See
the \fIdbopen\fR manpage for full details.
.Sp
Both the \f(CW$key\fR and \f(CW$value\fR parameters will be set to the key/value
pair read from the database.
.Sp
The flags parameter is mandatory. The valid flag values are R_CURSOR,
R_FIRST, R_LAST, R_NEXT and R_PREV.
.Ip "\fB$status = $X\->sync([$flags]) ;\fR" 5
Flushes any cached buffers to disk.
.Sp
R_RECNOSYNC is the only valid flag at present.
.SH "HINTS AND TIPS"
.Sh "Locking Databases"
Concurrent access of a read-write database by several parties requires
them all to use some kind of locking.  Here's an example of Tom's that
uses the \fIfd\fR method to get the file descriptor, and then a careful
\fIopen()\fR to give something Perl will \fIflock()\fR for you.  Run this repeatedly
in the background to watch the locks granted in proper order.
.PP
.Vb 1
\&    use DB_File;
.Ve
.Vb 1
\&    use strict;
.Ve
.Vb 4
\&    sub LOCK_SH { 1 }
\&    sub LOCK_EX { 2 }
\&    sub LOCK_NB { 4 }
\&    sub LOCK_UN { 8 }
.Ve
.Vb 1
\&    my($oldval, $fd, $db, %db, $value, $key);
.Ve
.Vb 2
\&    $key = shift || 'default';
\&    $value = shift || 'magic';
.Ve
.Vb 1
\&    $value .= " $$";
.Ve
.Vb 5
\&    $db = tie(%db, 'DB_File', '/tmp/foo.db', O_CREAT|O_RDWR, 0644) 
\&            || die "dbcreat /tmp/foo.db $!";
\&    $fd = $db->fd;
\&    print "$$: db fd is $fd\en";
\&    open(DB_FH, "+<&=$fd") || die "dup $!";
.Ve
.Vb 6
\&    unless (flock (DB_FH, LOCK_SH | LOCK_NB)) {
\&        print "$$: CONTENTION; can't read during write update!
\&                    Waiting for read lock ($!) ....";
\&        unless (flock (DB_FH, LOCK_SH)) { die "flock: $!" }
\&    } 
\&    print "$$: Read lock granted\en";
.Ve
.Vb 3
\&    $oldval = $db{$key};
\&    print "$$: Old value was $oldval\en";
\&    flock(DB_FH, LOCK_UN);
.Ve
.Vb 5
\&    unless (flock (DB_FH, LOCK_EX | LOCK_NB)) {
\&        print "$$: CONTENTION; must have exclusive lock!
\&                    Waiting for write lock ($!) ....";
\&        unless (flock (DB_FH, LOCK_EX)) { die "flock: $!" }
\&    } 
.Ve
.Vb 4
\&    print "$$: Write lock granted\en";
\&    $db{$key} = $value;
\&    $db->sync;  # to flush
\&    sleep 10;
.Ve
.Vb 5
\&    flock(DB_FH, LOCK_UN);
\&    undef $db;
\&    untie %db;
\&    close(DB_FH);
\&    print "$$: Updated db to $key=$value\en";
.Ve
.Sh "Sharing Databases With C Applications"
There is no technical reason why a Berkeley \s-1DB\s0 database cannot be
shared by both a Perl and a C application.
.PP
The vast majority of problems that are reported in this area boil down
to the fact that C strings are \s-1NULL\s0 terminated, whilst Perl strings are
not. 
.PP
Here is a real example. Netscape 2.0 keeps a record of the locations you
visit along with the time you last visited them in a \s-1DB_HASH\s0 database.
This is usually stored in the file \fI~/.netscape/history.db\fR. The key
field in the database is the location string and the value field is the
time the location was last visited stored as a 4 byte binary value.
.PP
If you haven't already guessed, the location string is stored with a
terminating \s-1NULL\s0. This means you need to be careful when accessing the
database.
.PP
Here is a snippet of code that is loosely based on Tom Christiansen's
\fIggh\fR script (available from your nearest \s-1CPAN\s0 archive in
\fIauthors/id/\s-1TOMC/\s0scripts/nshist.gz\fR).
.PP
.Vb 3
\&    use strict ;
\&    use DB_File ;
\&    use Fcntl ;
.Ve
.Vb 2
\&    use vars qw( $dotdir $HISTORY %hist_db $href $binary_time $date ) ;
\&    $dotdir = $ENV{HOME} || $ENV{LOGNAME};
.Ve
.Vb 1
\&    $HISTORY = "$dotdir/.netscape/history.db";
.Ve
.Vb 2
\&    tie %hist_db, 'DB_File', $HISTORY
\&        or die "Cannot open $HISTORY: $!\en" ;;
.Ve
.Vb 2
\&    # Dump the complete database
\&    while ( ($href, $binary_time) = each %hist_db ) {
.Ve
.Vb 2
\&        # remove the terminating NULL
\&        $href =~ s/\ex00$// ;
.Ve
.Vb 4
\&        # convert the binary time into a user friendly string
\&        $date = localtime unpack("V", $binary_time);
\&        print "$date $href\en" ;
\&    }
.Ve
.Vb 9
\&    # check for the existence of a specific key
\&    # remember to add the NULL
\&    if ( $binary_time = $hist_db{"http://mox.perl.com/\ex00"} ) {
\&        $date = localtime unpack("V", $binary_time) ;
\&        print "Last visited mox.perl.com on $date\en" ;
\&    }
\&    else {
\&        print "Never visited mox.perl.com\en"
\&    }
.Ve
.Vb 1
\&    untie %hist_db ;
.Ve
.Sh "The \fIuntie()\fR Gotcha"
If you make use of the Berkeley \s-1DB\s0 \s-1API\s0, it is \fIvery\fR strongly
recommended that you read the section on \fIThe untie Gotcha\fR in the \fIperltie\fR manpage. 
.PP
Even if you don't currently make use of the \s-1API\s0 interface, it is still
worth reading it.
.PP
Here is an example which illustrates the problem from a \fBDB_File\fR
perspective:
.PP
.Vb 2
\&    use DB_File ;
\&    use Fcntl ;
.Ve
.Vb 2
\&    my %x ;
\&    my $X ;
.Ve
.Vb 2
\&    $X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_TRUNC
\&        or die "Cannot tie first time: $!" ;
.Ve
.Vb 1
\&    $x{123} = 456 ;
.Ve
.Vb 1
\&    untie %x ;
.Ve
.Vb 2
\&    tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT
\&        or die "Cannot tie second time: $!" ;
.Ve
.Vb 1
\&    untie %x ;
.Ve
When run, the script will produce this error message:
.PP
.Vb 1
\&    Cannot tie second time: Invalid argument at bad.file line 14.
.Ve
Although the error message above refers to the second \fItie()\fR statement
in the script, the source of the problem is really with the \fIuntie()\fR
statement that precedes it.
.PP
Having read the \fIperltie\fR manpage you will probably have already guessed that the
error is caused by the extra copy of the tied object stored in \f(CW$X\fR.
If you haven't, then the problem boils down to the fact that the
\fBDB_File\fR destructor, \s-1DESTROY\s0, will not be called until \fIall\fR
references to the tied object are destroyed. Both the tied variable,
\f(CW%x\fR, and \f(CW$X\fR above hold a reference to the object. The call to
\fIuntie()\fR will destroy the first, but \f(CW$X\fR still holds a valid
reference, so the destructor will not get called and the database file
\fItst.fil\fR will remain open. The fact that Berkeley \s-1DB\s0 then reports the
attempt to open a database that is alreday open via the catch-all
\*(L"Invalid argument\*(R" doesn't help.
.PP
If you run the script with the \f(CW-w\fR flag the error message becomes:
.PP
.Vb 2
\&    untie attempted while 1 inner references still exist at bad.file line 12.
\&    Cannot tie second time: Invalid argument at bad.file line 14.
.Ve
which pinpoints the real problem. Finally the script can now be
modified to fix the original problem by destroying the \s-1API\s0 object
before the untie:
.PP
.Vb 2
\&    ...
\&    $x{123} = 456 ;
.Ve
.Vb 2
\&    undef $X ;
\&    untie %x ;
.Ve
.Vb 2
\&    $X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT
\&    ...
.Ve
.SH "COMMON QUESTIONS"
.Sh "Why is there Perl source in my database?"
If you look at the contents of a database file created by DB_File,
there can sometimes be part of a Perl script included in it.
.PP
This happens because Berkeley \s-1DB\s0 uses dynamic memory to allocate
buffers which will subsequently be written to the database file. Being
dynamic, the memory could have been used for anything before \s-1DB\s0
malloced it. As Berkeley \s-1DB\s0 doesn't clear the memory once it has been
allocated, the unused portions will contain random junk. In the case
where a Perl script gets written to the database, the random junk will
correspond to an area of dynamic memory that happened to be used during
the compilation of the script.
.PP
Unless you don't like the possibility of there being part of your Perl
scripts embedded in a database file, this is nothing to worry about.
.Sh "How do I store complex data structures with DB_File?"
Although \fBDB_File\fR cannot do this directly, there is a module which
can layer transparently over \fBDB_File\fR to accomplish this feat.
.PP
Check out the \s-1MLDBM\s0 module, available on \s-1CPAN\s0 in the directory
\fImodules/by-module/\s-1MLDBM\s0\fR.
.Sh "What does \*(M"Invalid Argument\*(S" mean?"
You will get this error message when one of the parameters in the
\f(CWtie\fR call is wrong. Unfortunately there are quite a few parameters to
get wrong, so it can be difficult to figure out which one it is.
.PP
Here are a couple of possibilities:
.Ip "1." 5
Attempting to reopen a database without closing it. 
.Ip "2." 5
Using the O_WRONLY flag.
.Sh "What does \*(M"Bareword \*(M'DB_File\*(S' not allowed\*(S" mean? "
You will encounter this particular error message when you have the
\f(CWstrict 'subs'\fR pragma (or the full strict pragma) in your script.
Consider this script:
.PP
.Vb 4
\&    use strict ;
\&    use DB_File ;
\&    use vars qw(%x) ;
\&    tie %x, DB_File, "filename" ;
.Ve
Running it produces the error in question:
.PP
.Vb 1
\&    Bareword "DB_File" not allowed while "strict subs" in use 
.Ve
To get around the error, place the word \f(CWDB_File\fR in either single or
double quotes, like this:
.PP
.Vb 1
\&    tie %x, "DB_File", "filename" ;
.Ve
Although it might seem like a real pain, it is really worth the effort
of having a \f(CWuse strict\fR in all your scripts.
.SH "HISTORY"
Moved to the Changes file.
.SH "BUGS"
Some older versions of Berkeley DB had problems with fixed length
records using the RECNO file format. This problem has been fixed since
version 1.85 of Berkeley DB.
.PP
I am sure there are bugs in the code. If you do find any, or can
suggest any enhancements, I would welcome your comments.
.SH "AVAILABILITY"
\fBDB_File\fR comes with the standard Perl source distribution. Look in
the directory \fIext/DB_File\fR. Given the amount of time between releases
of Perl the version that ships with Perl is quite likely to be out of
date, so the most recent version can always be found on CPAN (see
the \f(CWCPAN\fR entry in the \fIperlmod\fR manpage for details), in the directory
\fImodules/by-module/DB_File\fR.
.PP
This version of \fBDB_File\fR will work with either version 1.x or 2.x of
Berkeley DB, but is limited to the functionality provided by version 1.
.PP
The official web site for Berkeley DB is
\fIhttp://www.sleepycat.com/db\fR. The ftp equivalent is
\fIftp.sleepycat.com:/pub\fR. Both versions 1 and 2 of Berkeley DB are
available there.
.PP
Alternatively, Berkeley DB version 1 is available at your nearest CPAN
archive in \fIsrc/misc/db.1.85.tar.gz\fR.
.PP
If you are running IRIX, then get Berkeley DB version 1 from
\fIhttp://reality.sgi.com/ariel\fR. It has the patches necessary to
compile properly on IRIX 5.3.
.SH "COPYRIGHT"
Copyright (c) 1995-8 Paul Marquess. All rights reserved. This program
is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.
.PP
Although \fBDB_File\fR is covered by the Perl license, the library it
makes use of, namely Berkeley DB, is not. Berkeley DB has its own
copyright and its own license. Please take the time to read it.
.PP
Here are are few words taken from the Berkeley DB FAQ (at
http://www.sleepycat.com) regarding the license:
.PP
.Vb 1
\&    Do I have to license DB to use it in Perl scripts? 
.Ve
.Vb 6
\&    No. The Berkeley DB license requires that software that uses
\&    Berkeley DB be freely redistributable. In the case of Perl, that
\&    software is Perl, and not your scripts. Any Perl scripts that you
\&    write are your property, including scripts that make use of
\&    Berkeley DB. Neither the Perl license nor the Berkeley DB license
\&    place any restriction on what you may do with them.
.Ve
If you are in any doubt about the license situation, contact either the
Berkeley DB authors or the author of DB_File. See the section on \fIAUTHOR\fR for details.
.SH "SEE ALSO"
the \fIperl(1)\fR manpage, the \fIdbopen(3)\fR manpage, the \fIhash(3)\fR manpage, the \fIrecno(3)\fR manpage, the \fIbtree(3)\fR manpage 
.SH "AUTHOR"
The DB_File interface was written by Paul Marquess
<pmarquess@bfsec.bt.co.uk>.
Questions about the DB system itself may be addressed to
<db@sleepycat.com<gt>.

.rn }` ''
.IX Title "DB_File 3"
.IX Name "DB_File - Perl5 access to Berkeley DB version 1.x"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "\fB\s-1DB_HASH\s0\fR"

.IX Item "\fB\s-1DB_BTREE\s0\fR"

.IX Item "\fB\s-1DB_RECNO\s0\fR"

.IX Subsection "Using DB_File with Berkeley \s-1DB\s0 version 2"

.IX Subsection "Interface to Berkeley \s-1DB\s0"

.IX Subsection "Opening a Berkeley \s-1DB\s0 Database File"

.IX Subsection "Default Parameters"

.IX Subsection "In Memory Databases"

.IX Header "DB_HASH"

.IX Subsection "A Simple Example"

.IX Header "DB_BTREE"

.IX Subsection "Changing the \s-1BTREE\s0 sort order"

.IX Item "1."

.IX Item "2."

.IX Subsection "Handling Duplicate Keys "

.IX Subsection "The \fIget_dup()\fR Method"

.IX Subsection "Matching Partial Keys "

.IX Header "DB_RECNO"

.IX Subsection "The \*(M'bval\*(S' Option"

.IX Subsection "A Simple Example"

.IX Subsection "Extra Methods"

.IX Item "\fB$X\->push(list) ;\fR"

.IX Item "\fB$value = $X\->pop ;\fR"

.IX Item "\fB$X\->shift\fR"

.IX Item "\fB$X\->unshift(list) ;\fR"

.IX Item "\fB$X\->length\fR"

.IX Subsection "Another Example"

.IX Item "1."

.IX Item "2."

.IX Header "THE API INTERFACE"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\fB$status = $X\->get($key, $value [, $flags]) ;\fR"

.IX Item "\fB$status = $X\->put($key, $value [, $flags]) ;\fR"

.IX Item "\fB$status = $X\->del($key [, $flags]) ;\fR"

.IX Item "\fB$status = $X\->fd ;\fR"

.IX Item "\fB$status = $X\->seq($key, $value, $flags) ;\fR"

.IX Item "\fB$status = $X\->sync([$flags]) ;\fR"

.IX Header "HINTS AND TIPS"

.IX Subsection "Locking Databases"

.IX Subsection "Sharing Databases With C Applications"

.IX Subsection "The \fIuntie()\fR Gotcha"

.IX Header "COMMON QUESTIONS"

.IX Subsection "Why is there Perl source in my database?"

.IX Subsection "How do I store complex data structures with DB_File?"

.IX Subsection "What does \*(M"Invalid Argument\*(S" mean?"

.IX Item "1."

.IX Item "2."

.IX Subsection "What does \*(M"Bareword \*(M'DB_File\*(S' not allowed\*(S" mean? "

.IX Header "HISTORY"

.IX Header "BUGS"

.IX Header "AVAILABILITY"

.IX Header "COPYRIGHT"

.IX Header "SEE ALSO"

.IX Header "AUTHOR"

