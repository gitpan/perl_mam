.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::LWP::ConnCache 3 "libwww-perl-5.64" "7/Sep/101" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
LWP::ConnCache \- Connection cache manager
.SH "NOTE"
This module is experimental.  Details of its interface is likely to
change in the future.
.SH "SYNOPSIS"
.PP
.Vb 4
\& use LWP::ConnCache;
\& my $cache = LWP::ConnCache->new;
\& $cache->deposit($type, $key, $sock);
\& $sock = $cache->withdraw($type, $key);
.Ve
.SH "DESCRIPTION"
The \f(CWLWP::ConnCache\fR class is the standard connection cache manager
for LWP::UserAgent.
.PP
The following basic methods are provided:
.Ip "$cache = \s-1LWP::\s0ConnCache->new( %options )" 5
This method constructs a new \f(CWLWP::ConnCache\fR object.  The only
option currently accepted is \*(L'total_capacity\*(R'.  If specified it
initalize the total_capacity option.  It defaults to the value 1.
.Ip "$cache->total_capacity( [$num_connections] )" 5
Get/sets the number of connection that will be cached.  Connections
will start to be dropped when this limit is reached.  If set to \f(CW0\fR,
then all connections are immediately dropped.  If set to \f(CWundef\fR,
then there is no limit.
.Ip "$cache->capacity($type, [$num_connections] )" 5
Get/set a limit for the number of connections of the specifed type
that can be cached.  The \f(CW$type\fR will typically be a short string like
\*(L"http\*(R" or \*(L"ftp\*(R".
.Ip "$cache->drop( [$checker, [$reason]] )" 5
Drop connections by some criteria.  The \f(CW$checker\fR argument is a
subroutine that is called for each connection.  If the routine returns
a \s-1TRUE\s0 value then the connection is dropped.  The routine is called
with ($conn, \f(CW$type\fR, \f(CW$key\fR, \f(CW$deposit_time\fR) as arguments.
.Sp
Shortcuts: If the \f(CW$checker\fR argument is absent (or \f(CWundef\fR) all cached
connections are dropped.  If the \f(CW$checker\fR is a number then all
connections untouched that the given number of seconds or more are
dropped.  If \f(CW$checker\fR is a string then all connections of the given
type are dropped.
.Sp
The \f(CW$reason\fR argument is passed on to the \fIdropped()\fR method.
.Ip "$cache->prune" 5
Calling this method will drop all connections that are dead.  This is
tested by calling the \fIping()\fR method on the connections.  If the \fIping()\fR
method exists and returns a \s-1FALSE\s0 value, then the connection is
dropped.
.Ip "$cache->get_types" 5
This returns all the \*(L'type\*(R' fields used for the currently cached
connections.
.Ip "$cache->get_connections( [$type] )" 5
This returns all connection objects of the specified type.  If no type
is specified then all connections are returned.  In scalar context the
number of cached connections of the specified type is returned.
.PP
The following methods are called by low-level protocol modules to
try to save away connections and to get them back.
.Ip "$cache->deposit($type, $key, $conn)" 5
This method adds a new connection to the cache.  As a result other
already cached connections might be dropped.  Multiple connections with
the same \f(CW$type\fR/$key might added.
.Ip "$conn = $cache->withdraw($type, $key)" 5
This method tries to fetch back a connection that was previously
deposited.  If no cached connection with the specified \f(CW$type\fR/$key is
found, then \f(CWundef\fR is returned.  There is not guarantee that a
deposited connection can be withdrawn, as the cache manger is free to
drop connections at any time.
.PP
The following methods are called internally.  Subclasses might want to
override them.
.Ip "$conn->enforce_limits([$type])" 5
This method is called with after a new connection is added (deposited)
in the cache or capacity limits are adjusted.  The default
implementation drops connections until the specified capacity limits
are not exceeded.
.Ip "$conn->dropping($conn_record, $reason)" 5
This method is called when a connection is dropped.  The record
belonging to the dropped connection is passed as the first argument
and a string describing the reason for the drop is passed as the
second argument.  The default implementation makes some noise if the
\f(CW$LWP::ConnCache::DEBUG\fR variable is set and nothing more.
.SH "SUBCLASSING"
For specialized cache policy it makes sense to subclass
\f(CWLWP::ConnCache\fR and perhaps override the \fIdeposit()\fR, \fIenforce_limits()\fR
and \fIdropping()\fR methods.
.PP
The object itself is a hash.  Keys prefixed with \f(CWcc_\fR are reserved
for the base class.
.SH "SEE ALSO"
the \fILWP::UserAgent\fR manpage
.SH "COPYRIGHT"
Copyright 2001 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

.rn }` ''
.IX Title "lib::LWP::ConnCache 3"
.IX Name "LWP::ConnCache - Connection cache manager"

.IX Header "NAME"

.IX Header "NOTE"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "$cache = \s-1LWP::\s0ConnCache->new( %options )"

.IX Item "$cache->total_capacity( [$num_connections] )"

.IX Item "$cache->capacity($type, [$num_connections] )"

.IX Item "$cache->drop( [$checker, [$reason]] )"

.IX Item "$cache->prune"

.IX Item "$cache->get_types"

.IX Item "$cache->get_connections( [$type] )"

.IX Item "$cache->deposit($type, $key, $conn)"

.IX Item "$conn = $cache->withdraw($type, $key)"

.IX Item "$conn->enforce_limits([$type])"

.IX Item "$conn->dropping($conn_record, $reason)"

.IX Header "SUBCLASSING"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

