.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH LWP 1 "perl 5.003, patch 93" "25/Nov/96" "User Contributed Perl Documentation"
.IX Title "LWP 1"
.UC
.IX Name "LWP - Library for WWW access in Perl"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
LWP \- Library for WWW access in Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Libwww-perl is a collection of Perl modules which provides a simple
and consistent programming interface (API) to the World-Wide Web.  The
main focus of the library is to provide classes and functions that
allow you to write WWW clients, thus libwww-perl said to be a WWW
client library. The library also contain modules that are of more
general use.
.PP
The main architecture of the library is object oriented.  The user
agent, requests sent and responses received from the WWW server are
all represented by objects.  This makes a simple and powerful
interface to these services.  The interface should be easy to extend
and customize for your needs.
.PP
The main features of the library are:
.Ip "\(bu" 3
.IX Item "\(bu"
Contains various reusable components (modules) that can be
used separately or together.
.Ip "\(bu" 3
.IX Item "\(bu"
Provides an object oriented model of \s-1HTTP\s0\-style communication.  Within
this framework we currently support access to http, gopher, ftp, news,
file, and mailto resources.
.Ip "\(bu" 3
.IX Item "\(bu"
The library be used through the full object oriented interface or
through a very simple procedural interface.
.Ip "\(bu" 3
.IX Item "\(bu"
Support the basic and digest authorization schemes.
.Ip "\(bu" 3
.IX Item "\(bu"
Transparent redirect handling.
.Ip "\(bu" 3
.IX Item "\(bu"
Supports access through proxy servers.
.Ip "\(bu" 3
.IX Item "\(bu"
\s-1URL\s0 handling (both absolute and relative URLs are supported).
.Ip "\(bu" 3
.IX Item "\(bu"
A parser for \fIrobots.txt\fR files and a framework for constructing robots.
.Ip "\(bu" 3
.IX Item "\(bu"
An experimental \s-1HTML\s0 parser and formatters (for PostScript and plain
text).
.Ip "\(bu" 3
.IX Item "\(bu"
The library can cooperate with Tk.  A simple Tk-based \s-1GUI\s0 browser
called \*(L'tkweb\*(R' is distributed with the Tk extension for perl.
.Ip "\(bu" 3
.IX Item "\(bu"
An implementation of the \s-1HTTP\s0 content negotiation algorithm that can
be used both in protocol modules and in server scripts (like \s-1CGI\s0
scripts).
.Ip "\(bu" 3
.IX Item "\(bu"
A simple command line client application called \f(CWlwp-request\fR.
.SH "HTTP STYLE COMMUNICATION"
.IX Header "HTTP STYLE COMMUNICATION"
The libwww-perl library is based on HTTP style communication. This
section try to describe what that means.
.PP
Let us start with this quote from the HTTP specification document
<URL:http://www.w3.org/pub/WWW/Protocols/>:
.Ip "" 3
.IX Item ""
The \s-1HTTP\s0 protocol is based on a request/response paradigm. A client
establishes a connection with a server and sends a request to the
server in the form of a request method, \s-1URI\s0, and protocol version,
followed by a \s-1MIME\s0\-like message containing request modifiers, client
information, and possible body content. The server responds with a
status line, including the message's protocol version and a success or
error code, followed by a \s-1MIME\s0\-like message containing server
information, entity meta-information, and possible body content.
.PP
What this means to libwww-perl is that communication always take place
through these steps: First a \fIrequest\fR object is created and
configured. This object is then passed to a server and we get a
\fIresponse\fR object in return that we can examine. A request is always
independent of any previous requests, i.e. the service is stateless.
The same simple model is used for any kind of service we want to
access.
.PP
For example, if we want to fetch a document from a remote file server,
then we send it a request that contains a name for that document and
the response will contain the document itself.  If we access a search
engine, then the content of the request will contain the query
parameters and the response will contain the query result.  If we want
to send a mail message to somebody then we send a request object which
contains our message to the mail server and the response object will
contain an acknowledgment that tells us that the message has been
accepted and will be forwarded to the \fIrecipient\fR\|(s).
.PP
It is as simple as that!
.Sh "The Request Object"
.IX Subsection "The Request Object"
The request object has the class name \f(CWHTTP::Request\fR in
libwww-perl. The fact that the class name use \f(CWHTTP::\fR as a name
prefix only implies that we use the \s-1HTTP\s0 model of communication. It
does not limit the kind of services we can try to pass this \fIrequest\fR
to.  For instance, we will send \f(CWHTTP::Request\fRs both to ftp and
gopher servers, as well as to the local file system.
.PP
The main attributes of the request objects are:
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBmethod\fR is a short string that tells what kind of
request this is.  The most used methods are \fB\s-1GET\s0\fR, \fB\s-1PUT\s0\fR,
\fB\s-1POST\s0\fR and \fB\s-1HEAD\s0\fR.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBurl\fR is a string denoting the protocol, server and
the name of the \*(L"document\*(R" we want to access.  The \fBurl\fR might
also encode various other parameters.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBheaders\fR contain additional information about the
request and can also used to describe the content.  The headers
is a set of keyword/value pairs.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBcontent\fR is an arbitrary amount of data.
.Sh "The Response Object"
.IX Subsection "The Response Object"
The request object has the class name \f(CWHTTP::Response\fR in
libwww-perl.  The main attributes of objects of this class are:
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBcode\fR is a numerical value that encode the overall
outcome of the request.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBmessage\fR is a short (human readable) string that
corresponds to the \fIcode\fR.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBheaders\fR contain additional information about the
response and they also describe the content.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBcontent\fR is an arbitrary amount of data.
.PP
Since we don't want to handle all possible \fIcode\fR values directly in
our programs, the libwww-perl response object have methods that can be
used to query what kind of response this is.  The most commonly used
response classification methods are:
.Ip "is_success()" 3
.IX Item "is_success()"
The request was was successfully received, understood or accepted.
.Ip "is_error()" 3
.IX Item "is_error()"
The request failed.  The server or the resource might not be
available, access to the resource might be denied or other things might
have failed for some reason.
.Sh "The User Agent"
.IX Subsection "The User Agent"
Let us assume that we have created a \fIrequest\fR object. What do we
actually do with it in order to receive a \fIresponse\fR?
.PP
The answer is that you pass it on to a \fIuser agent\fR object and this
object will take care of all the things that need to be done
(low-level communication and error handling). The user agent will give
you back a \fIresponse\fR object. The user agent represents your
application on the network and it provides you with an interface that
can accept \fIrequests\fR and will return \fIresponses\fR.
.PP
You should think about the user agent as an interface layer between
your application code and the network.  Through this interface you are
able to access the various servers on the network.
.PP
The libwww-perl class name for the user agent is
\f(CWLWP::UserAgent\fR. Every libwww-perl application that wants to
communicate should create at least one object of this kind. The main
method provided by this object is \fIrequest()\fR. This method takes an
\f(CWHTTP::Request\fR object as argument and will (eventually) return a
\f(CWHTTP::Response\fR object.
.PP
The user agent has many other attributes that lets you
configure how it will interact with the network and with your
application code.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBtimeout\fR specify how much time we give remote servers in
creating responses before the library disconnect and creates an
internal \fItimeout\fR response.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBagent\fR specify the name that your application should use when it
presents itself on the network.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBfrom\fR attribute can be set to the e-mail address of the person
responsible for running the application.  If this is set, then the
address will be sent to the servers with every request.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBuse_alarm\fR specify if it is \s-1OK\s0 for the user agent to use the
\fIalarm\fR\|(2) system to implement timeouts.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBuse_eval\fR specify if the agent should raise an
exception (\f(CWdie\fR in perl) if an error condition occur.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBparse_head\fR specify whether we should initialize response
headers from the <head> section of \s-1HTML\s0 documents.
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBproxy\fR and \fBno_proxy\fR specify if and when communication should
go through a proxy server. <\s-1URL:\s0http://www.w3.org/pub/\s-1WWW/\s0Proxies/>
.Ip "\(bu" 3
.IX Item "\(bu"
The \fBcredentials\fR provide a way to set up user names and
passwords that is needed to access certain services.
.PP
Many applications would want even more control over how they interact
with the network and they get this by specializing the
\f(CWLWP::UserAgent\fR by sub-classing.  The library provide a
specialization called \f(CWLWP::RobotUA\fR that is used by robot
applications.
.Sh "An Example"
.IX Subsection "An Example"
This example shows how the user agent, a request and a response are
represented in actual perl code:
.PP
.Vb 4
\&  # Create a user agent object
\&  use LWP::UserAgent;
\&  $ua = new LWP::UserAgent;
\&  $ua->agent("AgentName/0.1 " . $ua->agent);
.Ve
.Vb 4
\&  # Create a request
\&  my $req = new HTTP::Request POST => 'http://www.perl.com/cgi-bin/BugGlimpse';
\&  $req->content_type('application/x-www-form-urlencoded');
\&  $req->content('match=www&errors=0');
.Ve
.Vb 2
\&  # Pass request to the user agent and get a response back
\&  my $res = $ua->request($req);
.Ve
.Vb 6
\&  # Check the outcome of the response
\&  if ($res->is_success) {
\&      print $res->content;
\&  } else {
\&      print "Bad luck this time\en";
\&  }
.Ve
The \f(CW$ua\fR is created once when the application starts up.  New request
objects are normally created for each request sent.
.SH "NETWORK SUPPORT"
.IX Header "NETWORK SUPPORT"
This section goes through the various protocol schemes and describe
the HTTP style methods that are supported and the headers that might
have any effect.
.PP
For all requests, a \*(L"User-Agent\*(R" header is added and initialized from
the \f(CW$ua\fR\->agent value before the request is handed to the network
layer.  In the same way, a \*(L"From\*(R" header is initialized from the
\f(CW$ua\fR\->from value.
.PP
For all responses, the library will add a header called \*(L"Client-Date\*(R".
This header will recode the time when the response was received by
your application.  This format and semantics of the header is just
like the server created \*(L"Date\*(R" header.
.Sh "\s-1HTTP\s0 Requests"
.IX Subsection "\s-1HTTP\s0 Requests"
\s-1HTTP\s0 request are really just handed off to an \s-1HTTP\s0 server and it will
decide what happens.  Few servers implement methods beside the usual
\*(L"\s-1GET\s0\*(R", \*(L"\s-1HEAD\s0\*(R", \*(L"\s-1POST\s0\*(R" and \*(L"\s-1PUT\s0\*(R" but \s-1CGI\s0\-scripts can really implement
any method they like.
.PP
If the server is not available then the library will generate an
internal error response.
.PP
The library automatically adds a \*(L"Host\*(R" and a \*(L"Content-Length\*(R" header
to the \s-1HTTP\s0 request before it is sent over the network.
.PP
For \s-1GET\s0 request you might want to add the \*(L"If-Modified-Since\*(R" header
to make the request conditional.
.PP
For \s-1POST\s0 request you should add the \*(L"Content-Type\*(R" header.  When you
try to emulate \s-1HTML\s0 <\s-1FORM\s0> handling you should usually let the value
of the \*(L"Content-Type\*(R" header be \*(L"application/x-www-form-urlencoded\*(R".
See the \fIlwpcook\fR manpage for examples of this.
.PP
The libwww-perl \s-1HTTP\s0 implementation currently support the \s-1HTTP/1\s0.0
protocol.  \s-1HTTP/0\s0.9 servers are also handled correctly.
.PP
The library allows you to access proxy server through \s-1HTTP\s0.  This
means that you can set up the library to forward all types of request
through the \s-1HTTP\s0 protocol module.  See the \fI\s-1LWP::\s0UserAgent\fR manpage for
documentation of this.
.Sh "\s-1FTP\s0 Requests"
.IX Subsection "\s-1FTP\s0 Requests"
The library currently support \s-1GET\s0, \s-1HEAD\s0 and \s-1PUT\s0 requests.  \s-1GET\s0 will
retrieve a file or a directory listing from an \s-1FTP\s0 server.  \s-1PUT\s0 will
store a file on a ftp server.
.PP
You can specify a ftp account for servers that want this in addition
user name and password.  This is specified by passing an \*(L"Account\*(R"
header in the request.
.PP
User name/password can be specified using basic authorization or be
encoded in the \s-1URL\s0.  Bad logins return an \s-1UNAUTHORIZED\s0 response with
\*(L"\s-1WWW\s0\-Authenticate: Basic\*(R" and can be treated as basic authorization
for \s-1HTTP\s0.
.PP
The library support ftp \s-1ASCII\s0 transfer mode by specifying the \*(L"type=a\*(R"
parameter in the \s-1URL\s0.
.PP
Directory listings are by default returned unprocessed (as returned
from the ftp server) with the content media type reported to be
\*(L"text/ftp-dir-listing\*(R". The \f(CWFile::Listing\fR module provide functionality
for parsing of these directory listing.
.PP
The ftp module is also able to convert directory listings to \s-1HTML\s0 and
this can be requested via the standard \s-1HTTP\s0 content negotiation
mechanisms (add an \*(L"Accept: text/html\*(R" header in the request if you
want this).
.PP
The normal file retrievals, the \*(L"Content-Type\*(R" is guessed based on the
file name suffix. See the \fI\s-1LWP::\s0MediaTypes\fR manpage.
.PP
The \*(L"If-Modified-Since\*(R" header is not honored yet.
.PP
Example:
.PP
.Vb 2
\&  $req = HTTP::Request->new(GET => 'ftp://me:passwd@ftp.some.where.com/');
\&  $req->header(Accept => "text/html, */*;q=0.1");
.Ve
.Sh "News Requests"
.IX Subsection "News Requests"
Access to the \s-1USENET\s0 News system is implemented through the \s-1NNTP\s0
protocol.  The name of the news server is obtained from the
\s-1NNTP_SERVER\s0 environment variable and defaults to \*(L"news\*(R".  It is not
possible to specify the hostname of the \s-1NNTP\s0 server in the news:\-URLs.
.PP
The library support \s-1GET\s0 and \s-1HEAD\s0 to retrieve news articles through the
\s-1NNTP\s0 protocol.  You can also post articles to newsgroups by using
(surprise!) the \s-1POST\s0 method.
.PP
\s-1GET\s0 on newsgroups is not implemented yet.
.PP
Examples:
.PP
.Vb 1
\&  $req = HTTP::Request->new(GET => 'news:abc1234@a.sn.no');
.Ve
.Vb 7
\&  $req = HTTP::Request->new(POST => 'news:comp.lang.perl.test');
\&  $req->header(Subject => 'This is a test',
\&               From    => 'me@some.where.org');
\&  $req->content(<<EOT);
\&  This is the content of the message that we are sending to
\&  the world.
\&  EOT
.Ve
.Sh "Gopher Request"
.IX Subsection "Gopher Request"
The library supports the \s-1GET\s0 and \s-1HEAD\s0 method for gopher request.  All
request header values are ignored.  \s-1HEAD\s0 cheats and will return a
response without even talking to server.
.PP
Gopher menus are always converted to \s-1HTML\s0.
.PP
The response \*(L"Content-Type\*(R" is generated from the document type
encoded (as the first letter) in the request \s-1URL\s0 path itself.
.PP
Example:
.PP
.Vb 1
\&  $req = HTTP::Request->new('GET', 'gopher://gopher.sn.no/');
.Ve
.Sh "File Request"
.IX Subsection "File Request"
The library supports \s-1GET\s0 and \s-1HEAD\s0 methods for file requests.  The
\*(L"If-Modified-Since\*(R" header is supported.  All other headers are
ignored.  The \fIhost\fR component of the file \s-1URL\s0 must be empty or set
to \*(L"localhost\*(R".  Any other \fIhost\fR value will be treated as an error.
.PP
Directories are always converted to an \s-1HTML\s0 document.  For normal
files, the \*(L"Content-Type\*(R" and \*(L"Content-Encoding\*(R" in the response are
guessed based on the file suffix.
.PP
Example:
.PP
.Vb 1
\&  $req = HTTP::Request->new(GET => 'file:/etc/passwd');
.Ve
.Sh "Mailto Request"
.IX Subsection "Mailto Request"
You can send (aka \*(L"\s-1POST\s0") mail messages using the library.  All
headers specified for the request are passed on to the mail system.
The \*(L"To\*(R" header is initialized from the mail address in the \s-1URL\s0.
.PP
Example:
.PP
.Vb 3
\&  $req = HTTP::Request->new(POST => 'mailto:libwww-perl-request@ics.uci.edu');
\&  $req->header("Subject", "subscribe");
\&  $req->content("Please subscribe me to the libwww-perl mailing list!\en");
.Ve
.SH "OVERVIEW OF CLASSES AND PACKAGES"
.IX Header "OVERVIEW OF CLASSES AND PACKAGES"
This table should give you a quick overview of the classes provided by the
library. Indentation shows class inheritance.
.PP
.Vb 8
\& LWP::MemberMixin   -- Access to member variables of Perl5 classes
\&   LWP::UserAgent   -- WWW user agent class
\&     LWP::RobotUA   -- When developing a robot applications
\&   LWP::Protocol          -- Interface to various protocol schemes
\&     LWP::Protocol::http  -- http:// access
\&     LWP::Protocol::file  -- file:// access
\&     LWP::Protocol::ftp   -- ftp:// access
\&     ...
.Ve
.Vb 1
\& LWP::Socket        -- Socket creation and IO
.Ve
.Vb 5
\& HTTP::Headers      -- MIME/RFC822 style header (used by HTTP::Message)
\& HTTP::Message      -- HTTP style message
\&   HTTP::Request    -- HTTP request
\&   HTTP::Response   -- HTTP response
\& HTTP::Daemon       -- A HTTP server class
.Ve
.Vb 1
\& URI::URL           -- Uniform Resource Locators
.Ve
.Vb 2
\& WWW::RobotRules    -- Parse robots.txt files
\&   WWW::RobotRules::AnyDBM_File -- Persistent RobotRules
.Ve
.Vb 8
\& HTML::Parser       -- Parse HTML documents
\&   HTML::TreeBuilder-- Build a HTML syntax tree
\&   HTML::HeadParser -- Parse the <HEAD> section of a HTML document
\&   HTML::LinkExtor  -- Extract links from a HTML document
\& HTML::Element      -- Building block for the HTML::TreeBuilder
\& HTML::Formatter    -- Convert HTML syntax trees to readable formats
\&   HTML::FormatText -- Output is plain text
\&   HTML::FormatPS   -- Output is PostScript
.Ve
The following modules provide various functions and definitions.
.PP
.Vb 9
\& LWP                -- This file.  Library version number and documentation.
\& LWP::MediaTypes    -- MIME types configuration (text/html etc.)
\& LWP::Debug         -- Debug logging module
\& LWP::Simple        -- Simplified procedural interface for common functions
\& HTTP::Status       -- HTTP status code (200 OK etc)
\& HTTP::Date         -- Date parsing module for HTTP date formats
\& HTTP::Negotiate    -- HTTP content negotiation calculation
\& HTML::Entities     -- Expand or unexpand entities in HTML text
\& File::Listing      -- Parse directory listings
.Ve
HTTP use the Base64 encoding at some places.  The QuotedPrint module
is just included to make the MIME:: collection more complete.
.PP
.Vb 2
\& MIME::Base64       -- Base64 encoding/decoding routines
\& MIME::QuotedPrint  -- Quoted Printable encoding/decoding routines
.Ve
The following modules does not have much to do with the World Wide
Web, but are included just because I am lazy and did not bother to
make separate distributions for them.  Regard them as bonus, provided
free for your pleasure.
.PP
.Vb 2
\& Font::AFM          -- Parse Adobe Font Metric files
\& File::CounterFile  -- Persistent counter class
.Ve
.SH "MORE DOCUMENTATION"
.IX Header "MORE DOCUMENTATION"
All modules contain detailed information on the interfaces they
provide.  The the \fIlwpcook\fR manpage is the libwww-perl cookbook that contain
examples of typical usage of the library.  You might want to take a
look at how the scripts \f(CWlwp-request\fR, \f(CWlwp-rget\fR and \f(CWlwp-mirror\fR
are implemented.
.SH "BUGS"
.IX Header "BUGS"
The library can not handle multiple simultaneous requests yet.  The
HTML:: modules are still experimental.  Also, check out what's left in
the TODO file.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
This package owes a lot in motivation, design, and code, to the
libwww-perl library for Perl 4, maintained by Roy Fielding
<fielding@ics.uci.edu>.
.PP
That package used work from Alberto Accomazzi, James Casey, Brooks
Cutter, Martijn Koster, Oscar Nierstrasz, Mel Melchner, Gertjan van
Oosten, Jared Rhine, Jack Shirazi, Gene Spafford, Marc VanHeyningen,
Steven E. Brenner, Marion Hakanson, Waldemar Kebsch, Tony Sanders, and
Larry Wall; see the libwww-perl-0.40 library for details.
.PP
The primary architect for this Perl 5 library is Martijn Koster and
Gisle Aas, with lots of help from Graham Barr, Tim Bunce, Andreas
Koenig, Jared Rhine, and Jack Shirazi.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.PP
.Vb 2
\&  Copyright 1995-1996, Gisle Aas
\&  Copyright 1995, Martijn Koster
.Ve
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
The latest version of this library is likely to be available from:
.PP
.Vb 1
\& http://www.sn.no/libwww-perl/
.Ve
The best place to discuss this code is on the
<libwww-perl@ics.uci.edu> mailing list.

.rn }` ''
