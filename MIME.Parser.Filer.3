.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::MIME::Parser::Filer 3 "perl 5.007, patch 00" "22/Nov/100" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
MIME::Parser::Filer \- manage file-output of the parser
.SH "SYNOPSIS"
Before reading further, you should see the \fIMIME::Parser\fR manpage to make sure that 
you understand where this module fits into the grand scheme of things.
Go on, do it now.  I'll wait.
.PP
Ready?  Ok... now read the section on \fIDESCRIPTION\fR below, and everything else
should make sense.
.Sh "Public interface"
.PP
.Vb 13
\&    ### Create a "filer" of the desired class:
\&    my $filer = MIME::Parser::FileInto->new($dir);
\&    my $filer = MIME::Parser::FileUnder->new($basedir);
\&    ...
\&     
\&    ### Want added security?  Don't let outsiders name your files:
\&    $filer->ignore_filename(1); 
\&     
\&    ### Prepare for the parsing of a new top-level message:     
\&    $filer->init_parse;
\&     
\&    ### Return the path where this message's data should be placed:
\&    $path = $filer->output_path($head);
.Ve
.Sh "Semi-public interface"
These methods might be overriden or ignored in some subclasses, 
so they don't all make sense in all circumstances:
.PP
.Vb 3
\&    ### Tweak the mapping from content-type to extension:
\&    $emap = $filer->output_extension_map;
\&    $emap->{"text/html"} = ".htm";
.Ve
.SH "DESCRIPTION"
.Sh "How this class is used when parsing"
When a \s-1MIME::\s0Parser decides that it wants to output a file to disk,
it uses its \*(L"Filer\*(R" object -- an instance of a \s-1MIME::\s0Parser::Filer 
subclass -- to determine where to put the file.  
.PP
Every parser has a single Filer object, which it uses for all
parsing.  You can get the Filer for a given \f(CW$parser\fR like this:
.PP
.Vb 1
\&    $filer = $parser->filer;
.Ve
At the beginning of each \f(CWparse()\fR, the filer's internal state
is reset by the parser: 
.PP
.Vb 1
\&    $parser->filer->init_parse;
.Ve
The parser can then get a path for each entity in the message
by handing that entity's header (a \s-1MIME::\s0Head) to the filer 
and having it do the work, like this:
.PP
.Vb 1
\&    $new_file = $parser->filer->output_path($head);
.Ve
Since it's nice to be able to clean up after a parse (especially
a failed parse), the parser tells the filer when it has actually 
used a path:
.PP
.Vb 1
\&    $parser->filer->purgeable($new_file);
.Ve
Then, if you want to clean up the files which were created for a
particular parse (and also any directories that the Filer created),
you would do this:
.PP
.Vb 1
\&    $parser->filer->purge;
.Ve
.Sh "Writing your own subclasses"
There are two standard \*(L"Filer\*(R" subclasses (see below): 
\fB\s-1MIME::\s0Parser::FileInto\fR, which throws all files from all parses
into the same directory, and \fB\s-1MIME::\s0Parser::FileUnder\fR (preferred), which 
creates a subdirectory for each message.  Hopefully, these will be 
sufficient for most uses, but just in case...
.PP
The only method you have to override is output_path():
.PP
.Vb 1
\&    $filer->output_path($head);
.Ve
This method is invoked by \s-1MIME::\s0Parser when it wants to put a 
decoded message body in an output file.  The method should return a 
path to the file to create.  Failure is indicated by throwing an 
exception.
.PP
The path returned by \f(CWoutput_path()\fR should be \*(L"ready for \fIopen()\fR":
any necessary parent directories need to exist at that point.
These directories can be created by the Filer, if course, and they
should be marked as \fBpurgeable()\fR if a purge should delete them.
.PP
Actually, if your issue is more \fIwhere\fR the files go than
what they're named, you can use the default output_path()
method and just override one of its components:
.PP
.Vb 3
\&    $dir  = $filer->output_dir($head);
\&    $name = $filer->output_filename($head);
\&    ...
.Ve
.SH "PUBLIC INTERFACE"
.Sh "\s-1MIME::\s0Parser::Filer"
This is the abstract superclass of all \*(L"filer\*(R" objects.
.Ip "new \s-1INITARGS\s0..." 4
\fIClass method, constructor.\fR
Create a new outputter for the given parser.
Any subsequent arguments are given to \fIinit()\fR, which subclasses should
override for their own use (the default init does nothing).
.Ip "results \s-1RESULTS\s0" 4
\fIInstance method.\fR
Link this filer to a \s-1MIME::\s0Parser::Results object which will 
tally the messages.  Notice that we avoid linking it to the 
parser to avoid circular reference!
.Ip "init_parse" 4
\fIInstance method.\fR
Prepare to start parsing a new message.
Subclasses should always be sure to invoke the inherited method.
.Ip "evil_filename \s-1FILENAME\s0" 4
\fIInstance method.\fR
Is this an evil filename; i.e., one which should not be used
in generating a disk file name?  It is if any of these are true:
.Sp
.Vb 4
\&    * it is empty
\&    * it is a string of dots: ".", "..", etc.
\&    * it contains a known "path" character: '/' '\e' ':' '[' ']'
\&    * it is too long
.Ve
If you just want to change this behavior, you should override 
this method in the subclass of \s-1MIME::\s0Parser::Filer that you use.
.Sp
\fBWarning:\fR at the time this method is invoked, the \s-1FILENAME\s0 has 
already been unmime'd into the local character set.  
If you're using any character set other than \s-1ASCII\s0, \s-1ISO\s0\-8859-*, 
or \s-1UTF\s0\-8, the interpretation of the \*(L"path\*(R" characters might be 
very different, and you will probably need to override this method.
See the \f(CWunmime\fR entry in the \fI\s-1MIME::\s0WordDecoder\fR manpage for more details.
.Sp
\fBNote:\fR subclasses of \s-1MIME::\s0Parser::Filer which override 
\fIoutput_path()\fR might not consult this method; note, however, that
the built-in subclasses do consult it.
.Sp
\fIThanks to Andrew Pimlott for finding a real dumb bug in the original
version.  Thanks to Nickolay Saukh for noting that evil is in the 
eye of the beholder.\fR
.Ip "exorcise_filename \s-1FILENAME\s0" 4
\fIInstance method.\fR
If a given filename is evil (see the \f(CWevil_filename\fR entry elsewhere in this document) we try to
rescue it by performing some basic operations: shortening it,
removing bad characters, etc., and checking each against
\fIevil_filename()\fR.
.Sp
Returns the exorcised filename (which is guaranteed to not
be evil), or undef if it could not be salvaged.
.Sp
\fBWarning:\fR at the time this method is invoked, the \s-1FILENAME\s0 has 
already been unmime'd into the local character set.  
If you're using anything character set other than \s-1ASCII\s0, \s-1ISO\s0\-8859-*, 
or \s-1UTF\s0\-8, the interpretation of the \*(L"path\*(R" characters might be very 
very different, and you will probably need to override this method.
See the \f(CWunmime\fR entry in the \fI\s-1MIME::\s0WordDecoder\fR manpage for more details.
.Ip "find_unused_path \s-1DIR\s0, \s-1FILENAME\s0" 4
\fIInstance method, subclasses only.\fR
We have decided on an output directory and tentative filename,
but there is a chance that it might already exist.  Keep
adding a numeric suffix \*(L"\-1\*(R", \*(L"\-2\*(R", etc. to the filename
until an unused path is found, and then return that path.
.Sp
The suffix is actually added before the first \*(L".\*(R" in the filename
is there is one; for example:
.Sp
.Vb 6
\&    picture.gif       archive.tar.gz      readme
\&    picture-1.gif     archive-1.tar.gz    readme-1
\&    picture-2.gif     archive-2.tar.gz    readme-2
\&    ...               ...                 ...
\&    picture-10.gif
\&    ...
.Ve
This can be a costly operation, and risky if you don't want files
renamed, so it is in your best interest to minimize situations
where these kinds of collisions occur.  Unfortunately, if
a multipart message gives all of its parts the same recommended
filename, and you are placing them all in the same directory,
this method might be unavoidable.
.Ip "ignore_filename [\s-1YESNO\s0]" 4
\fIInstance method.\fR
Return true if we should always ignore recommended filenames in
messages, choosing instead to always generate our own filenames.  
With argument, sets this value.
.Sp
\fBNote:\fR subclasses of \s-1MIME::\s0Parser::Filer which override 
\fIoutput_path()\fR might not honor this setting; note, however, that
the built-in subclasses honor it.
.Ip "output_dir \s-1HEAD\s0" 4
\fIInstance method.\fR
Return the output directory for the given header.
The default method returns \*(L".\*(R".
.Ip "output_filename \s-1HEAD\s0" 4
\fIInstance method, subclasses only.\fR
A given recommended filename was either not given, or it was judged
to be evil.  Return a fake name, possibly using information in the 
message HEADer.  Note that this is just the filename, not the full path.
.Sp
Used by output_path().
If you're using the default \f(CWoutput_path()\fR, you probably don't 
need to worry about avoiding collisions with existing files; 
we take care of that in find_unused_path().
.Ip "output_prefix [\s-1PREFIX\s0]" 4
\fIInstance method.\fR
Get the short string that all filenames for extracted body-parts 
will begin with (assuming that there is no better \*(L"recommended filename").  
The default is \fI"msg\*(R"\fR.
.Sp
If \s-1PREFIX\s0 \fIis not\fR given, the current output prefix is returned.
If \s-1PREFIX\s0 \fIis\fR given, the output prefix is set to the new value,
and the previous value is returned.
.Sp
Used by output_filename().
.Sp
\fBNote:\fR subclasses of \s-1MIME::\s0Parser::Filer which override 
\fIoutput_path()\fR or \fIoutput_filename()\fR might not honor this setting; 
note, however, that the built-in subclasses honor it.
.Ip "output_type_ext " 4
\fIInstance method.\fR
Return a reference to the hash used by the default 
output_filename() for mapping from content-types 
to extensions when there is no default extension to use.
.Sp
.Vb 5
\&    $emap = $filer->output_typemap;
\&    $emap->{'text/plain'} = '.txt';
\&    $emap->{'text/html'}  = '.html';
\&    $emap->{'text/*'}     = '.txt';
\&    $emap->{'*/*'}        = '.dat';
.Ve
\fBNote:\fR subclasses of \s-1MIME::\s0Parser::Filer which override 
\fIoutput_path()\fR or \fIoutput_filename()\fR might not consult this hash; 
note, however, that the built-in subclasses consult it.
.Ip "output_path \s-1HEAD\s0" 4
\fIInstance method, subclasses only.\fR
Given a \s-1MIME\s0 head for a file to be extracted, come up with a good
output pathname for the extracted file.  This is the only method
you need to worry about if you are building a custom filer.
.Sp
The default implementation does a lot of work; subclass 
implementers \fIreally\fR should try to just override its components 
instead of the whole thing.  It works basically as follows:
.Sp
.Vb 10
\&    $directory = $self->output_dir($head);   
\&     
\&    $filename = $head->recommended_filename();
\&    if (!$filename or 
\&         $self->ignore_filename() or 
\&         $self->evil_filename($filename)) {
\&        $filename = $self->output_filename($head);
\&    }
\&    
\&    return $self->find_unused_path($directory, $filename);
.Ve
\fBNote:\fR There are many, many, many ways you might want to control
the naming of files, based on your application.  If you don't like 
the behavior of this function, you can easily define your own subclass 
of \s-1MIME::\s0Parser::Filer and override it there.
.Sp
\fBNote:\fR Nickolay Saukh pointed out that, given the subjective nature of
what is \*(L"evil\*(R", this function really shouldn't \fIwarn\fR about an evil
filename, but maybe just issue a \fIdebug\fR message.  I considered that, 
but then I thought: if debugging were off, people wouldn't know why 
(or even if) a given filename had been ignored.  In mail robots
that depend on externally-provided filenames, this could cause 
hard-to-diagnose problems.  So, the message is still a warning.
.Sp
\fIThanks to Laurent Amon for pointing out problems with the original
implementation, and for making some good suggestions.  Thanks also to
Achim Bohnet for pointing out that there should be a hookless, \s-1OO\s0 way of 
overriding the output path.\fR
.Ip "purge" 4
\fIInstance method, final.\fR
Purge all files/directories created by the last parse.
This method simply goes through the purgeable list in reverse order 
(see the \f(CWpurgeable\fR entry elsewhere in this document) and removes all existing files/directories in it.
You should not need to override this method.
.Ip "purgeable [\s-1FILE\s0]" 4
\fIInstance method, final.\fR
Add \s-1FILE\s0 to the list of \*(L"purgeable\*(R" files/directories (those which
will be removed if you do a \f(CWpurge()\fR).
You should not need to override this method.
.Sp
If \s-1FILE\s0 is not given, the \*(L"purgeable\*(R" list is returned.
This may be used for more-sophisticated purging.
.Sp
As a special case, invoking this method with a \s-1FILE\s0 that is an
arrayref will replace the purgeable list with a copy of the
array's contents, so [] may be used to clear the list.
.Sp
Note that the \*(L"purgeable\*(R" list is cleared when a parser begins a 
new parse; therefore, if you want to use \fIpurge()\fR to do cleanup,
you \fImust\fR do so \fIbefore\fR starting a new parse!
.Sh "\s-1MIME::\s0Parser::FileInto"
This concrete subclass of \s-1MIME::\s0Parser::Filer supports filing 
into a given directory.
.Ip "init \s-1DIRECTORY\s0" 4
\fIInstance method, initiallizer.\fR
Set the directory where all files will go.
.Sh "\s-1MIME::\s0Parser::FileUnder"
This concrete subclass of \s-1MIME::\s0Parser::Filer supports filing under 
a given directory, using one subdirectory per message, but with
all message parts in the same directory.
.Ip "init \s-1BASEDIR\s0, \s-1OPTSHASH\s0..." 4
\fIInstance method, initiallizer.\fR
Set the base directory which will contain the message directories.
If used, then each parse of begins by creating a new subdirectory
of \s-1BASEDIR\s0 where the actual parts of the message are placed.  
\s-1OPTSHASH\s0 can contain the following:
.Ip "DirName" 8
Explicitly set the name of the subdirectory which is created.
The default is to use the time, process id, and a sequence number,
but you might want a predictable directory.  
.Ip "Purge" 8
Automatically purge the contents of the directory (including all
subdirectories) before each parse.  This is really only needed if
using an explicit DirName, and is provided as a convenience only.
Currently we use the 1-arg form of File::Path::rmtree; you should
familiarize yourself with the caveats therein.
.Sp
The \fIoutput_dir()\fR will return the path to this message-specific directory 
until the next parse is begun, so you can do this:
.Sp
.Vb 11
\&    use File::Path;
\&     
\&    $parser->output_under("/tmp");
\&    $ent = eval { $parser->parse_open($msg); };   ### parse
\&    if (!$ent) {         ### parse failed
\&        rmtree($parser->output_dir);
\&        die "parse failed: $@";
\&    } 
\&    else {               ### parse succeeded
\&        ...do stuff...
\&    }
.Ve
.SH "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
.PP
All rights reserved.  This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.SH "VERSION"
$Revision: 5.406 $

.rn }` ''
.IX Title "lib::MIME::Parser::Filer 3"
.IX Name "MIME::Parser::Filer - manage file-output of the parser"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Subsection "Public interface"

.IX Subsection "Semi-public interface"

.IX Header "DESCRIPTION"

.IX Subsection "How this class is used when parsing"

.IX Subsection "Writing your own subclasses"

.IX Header "PUBLIC INTERFACE"

.IX Subsection "\s-1MIME::\s0Parser::Filer"

.IX Item "new \s-1INITARGS\s0..."

.IX Item "results \s-1RESULTS\s0"

.IX Item "init_parse"

.IX Item "evil_filename \s-1FILENAME\s0"

.IX Item "exorcise_filename \s-1FILENAME\s0"

.IX Item "find_unused_path \s-1DIR\s0, \s-1FILENAME\s0"

.IX Item "ignore_filename [\s-1YESNO\s0]"

.IX Item "output_dir \s-1HEAD\s0"

.IX Item "output_filename \s-1HEAD\s0"

.IX Item "output_prefix [\s-1PREFIX\s0]"

.IX Item "output_type_ext "

.IX Item "output_path \s-1HEAD\s0"

.IX Item "purge"

.IX Item "purgeable [\s-1FILE\s0]"

.IX Subsection "\s-1MIME::\s0Parser::FileInto"

.IX Item "init \s-1DIRECTORY\s0"

.IX Subsection "\s-1MIME::\s0Parser::FileUnder"

.IX Item "init \s-1BASEDIR\s0, \s-1OPTSHASH\s0..."

.IX Item "DirName"

.IX Item "Purge"

.IX Header "AUTHOR"

.IX Header "VERSION"

