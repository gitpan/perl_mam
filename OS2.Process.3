.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OS2::Process 3"
.TH OS2::Process 3 "2003-09-30" "perl v5.8.2" "Perl Programmers Reference Guide"
.SH "NAME"
OS2::Process \- exports constants for system() call, and process control on OS2.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use OS2::Process;
\&    $pid = system(P_PM | P_BACKGROUND, "epm.exe");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Optional argument to \fIsystem()\fP"
.IX Subsection "Optional argument to system()"
the builtin function \fIsystem()\fR under \s-1OS/2\s0 allows an optional first
argument which denotes the mode of the process. Note that this argument is
recognized only if it is strictly numerical.
.PP
You can use either one of the process modes:
.PP
.Vb 5
\&        P_WAIT (0)      = wait until child terminates (default)
\&        P_NOWAIT        = do not wait until child terminates
\&        P_SESSION       = new session
\&        P_DETACH        = detached
\&        P_PM            = PM program
.Ve
.PP
and optionally add \s-1PM\s0 and session option bits:
.PP
.Vb 5
\&        P_DEFAULT (0)   = default
\&        P_MINIMIZE      = minimized
\&        P_MAXIMIZE      = maximized
\&        P_FULLSCREEN    = fullscreen (session only)
\&        P_WINDOWED      = windowed (session only)
.Ve
.PP
.Vb 2
\&        P_FOREGROUND    = foreground (if running in foreground)
\&        P_BACKGROUND    = background
.Ve
.PP
.Vb 1
\&        P_NOCLOSE       = don't close window on exit (session only)
.Ve
.PP
.Vb 3
\&        P_QUOTE         = quote all arguments
\&        P_TILDE         = MKS argument passing convention
\&        P_UNRELATED     = do not kill child when father terminates
.Ve
.Sh "Access to process properties"
.IX Subsection "Access to process properties"
On \s-1OS/2\s0 processes have the usual \fIparent/child\fR semantic;
additionally, there is a hierarchy of sessions with their own
\&\fIparent/child\fR tree.  A session is either a \s-1FS\s0 session, or a windowed
pseudo-session created by \s-1PM\s0.  A session is a \*(L"unit of user
interaction\*(R", a change to in/out settings in one of them does not
affect other sessions.
.IP "\fImy_type()\fR" 4
.IX Item "my_type()"
returns the type of the current process (one of
\&\*(L"\s-1FS\s0\*(R", \*(L"\s-1DOS\s0\*(R", \*(L"\s-1VIO\s0\*(R", \*(L"\s-1PM\s0\*(R", \*(L"\s-1DETACH\s0\*(R" and \*(L"\s-1UNKNOWN\s0\*(R"), or \f(CW\*(C`undef\*(C'\fR on error.
.ie n .IP """file_type(file)""" 4
.el .IP "\f(CWfile_type(file)\fR" 4
.IX Item "file_type(file)"
returns the type of the executable file \f(CW\*(C`file\*(C'\fR, or
dies on error.  The bits 0\-2 of the result contain one of the values
.RS 4
.ie n .IP """T_NOTSPEC"" (0)" 4
.el .IP "\f(CWT_NOTSPEC\fR (0)" 4
.IX Item "T_NOTSPEC (0)"
Application type is not specified in the executable header.
.ie n .IP """T_NOTWINDOWCOMPAT"" (1)" 4
.el .IP "\f(CWT_NOTWINDOWCOMPAT\fR (1)" 4
.IX Item "T_NOTWINDOWCOMPAT (1)"
Application type is not\-window\-compatible.
.ie n .IP """T_WINDOWCOMPAT"" (2)" 4
.el .IP "\f(CWT_WINDOWCOMPAT\fR (2)" 4
.IX Item "T_WINDOWCOMPAT (2)"
Application type is window\-compatible.
.ie n .IP """T_WINDOWAPI"" (3)" 4
.el .IP "\f(CWT_WINDOWAPI\fR (3)" 4
.IX Item "T_WINDOWAPI (3)"
Application type is window\-API.
.RE
.RS 4
.Sp
The remaining bits should be masked with the following values to
determine the type of the executable:
.ie n .IP """T_BOUND"" (8)" 4
.el .IP "\f(CWT_BOUND\fR (8)" 4
.IX Item "T_BOUND (8)"
Set to 1 if the executable file has been \*(L"bound\*(R" (by the \s-1BIND\s0 command)
as a Family \s-1API\s0 application. Bits 0, 1, and 2 still apply.
.ie n .IP """T_DLL"" (0x10)" 4
.el .IP "\f(CWT_DLL\fR (0x10)" 4
.IX Item "T_DLL (0x10)"
Set to 1 if the executable file is a dynamic link library (\s-1DLL\s0)
module. Bits 0, 1, 2, 3, and 5 will be set to 0.
.ie n .IP """T_DOS"" (0x20)" 4
.el .IP "\f(CWT_DOS\fR (0x20)" 4
.IX Item "T_DOS (0x20)"
Set to 1 if the executable file is in \s-1PC/DOS\s0 format. Bits 0, 1, 2, 3,
and 4 will be set to 0.
.ie n .IP """T_PHYSDRV"" (0x40)" 4
.el .IP "\f(CWT_PHYSDRV\fR (0x40)" 4
.IX Item "T_PHYSDRV (0x40)"
Set to 1 if the executable file is a physical device driver.
.ie n .IP """T_VIRTDRV"" (0x80)" 4
.el .IP "\f(CWT_VIRTDRV\fR (0x80)" 4
.IX Item "T_VIRTDRV (0x80)"
Set to 1 if the executable file is a virtual device driver.
.ie n .IP """T_PROTDLL"" (0x100)" 4
.el .IP "\f(CWT_PROTDLL\fR (0x100)" 4
.IX Item "T_PROTDLL (0x100)"
Set to 1 if the executable file is a protected-memory dynamic link
library module.
.ie n .IP """T_32BIT"" (0x4000)" 4
.el .IP "\f(CWT_32BIT\fR (0x4000)" 4
.IX Item "T_32BIT (0x4000)"
Set to 1 for 32\-bit executable files.
.RE
.RS 4
.Sp
\&\fIfile_type()\fR may croak with one of the strings \f(CW\*(C`"Invalid EXE
signature"\*(C'\fR or \f(CW"EXE marked invalid"\fR to indicate typical error
conditions.  If given non-absolute path, will look on \f(CW\*(C`PATH\*(C'\fR, will
add extention \fI.exe\fR if no extension is present (add extension \fI.\fR
to suppress).
.RE
.ie n .IP """@list = process_codepages()""" 4
.el .IP "\f(CW@list = process_codepages()\fR" 4
.IX Item "@list = process_codepages()"
the first element is the currently active codepage, up to 2 additional
entries specify the system's \*(L"prepared codepages\*(R": the codepages the
user can switch to.  The active codepage of a process is one of the
prepared codepages of the system (if present).
.ie n .IP """process_codepage_set($cp)""" 4
.el .IP "\f(CWprocess_codepage_set($cp)\fR" 4
.IX Item "process_codepage_set($cp)"
sets the currently active codepage.  [Affects printer output, in/out
codepages of sessions started by this process, and the default
codepage for drawing in \s-1PM\s0; is inherited by kids.  Does not affect the
out\- and in-codepages of the session.]
.IP "\fIppid()\fR" 4
.IX Item "ppid()"
returns the \s-1PID\s0 of the parent process.
.ie n .IP """ppidOf($pid = $$)""" 4
.el .IP "\f(CWppidOf($pid = $$)\fR" 4
.IX Item "ppidOf($pid = $$)"
returns the \s-1PID\s0 of the parent process of \f(CW$pid\fR.  \-1 on error.
.ie n .IP """sidOf($pid = $$)""" 4
.el .IP "\f(CWsidOf($pid = $$)\fR" 4
.IX Item "sidOf($pid = $$)"
returns the session id of the process id \f(CW$pid\fR.  \-1 on error.
.Sh "Control of \s-1VIO\s0 sessions"
.IX Subsection "Control of VIO sessions"
\&\s-1VIO\s0 applications are applications running in a text-mode session.
.IP "\fIout_codepage()\fR" 4
.IX Item "out_codepage()"
gets code page used for screen output (glyphs).  \-1 means that a user font
was loaded.
.ie n .IP """out_codepage_set($cp)""" 4
.el .IP "\f(CWout_codepage_set($cp)\fR" 4
.IX Item "out_codepage_set($cp)"
sets code page used for screen output (glyphs).  \-1 switches to a preloaded
user font.  \-2 switches off the preloaded user font.
.IP "\fIin_codepage()\fR" 4
.IX Item "in_codepage()"
gets code page used for keyboard input.  0 means that a hardware codepage
is used.
.ie n .IP """in_codepage_set($cp)""" 4
.el .IP "\f(CWin_codepage_set($cp)\fR" 4
.IX Item "in_codepage_set($cp)"
sets code page used for keyboard input.
.ie n .IP """($w, $h) = scrsize()""" 4
.el .IP "\f(CW($w, $h) = scrsize()\fR" 4
.IX Item "($w, $h) = scrsize()"
width and height of the given console window in character cells.
.ie n .IP """scrsize_set([$w, ] $h)""" 4
.el .IP "\f(CWscrsize_set([$w, ] $h)\fR" 4
.IX Item "scrsize_set([$w, ] $h)"
set height (and optionally width) of the given console window in
character cells.  Use 0 size to keep the old size.
.ie n .IP """($s, $e, $w, $a) = cursor()""" 4
.el .IP "\f(CW($s, $e, $w, $a) = cursor()\fR" 4
.IX Item "($s, $e, $w, $a) = cursor()"
gets start/end lines of the blinking cursor in the charcell, its width
(1 on text modes) and attribute (\-1 for hidden, in text modes other
values mean visible, in graphic modes color).
.ie n .IP """cursor_set($s, $e, [$w [, $a]])""" 4
.el .IP "\f(CWcursor_set($s, $e, [$w [, $a]])\fR" 4
.IX Item "cursor_set($s, $e, [$w [, $a]])"
sets start/end lines of the blinking cursor in the charcell.  Negative
values mean percents of the character cell height.
.IP "\fIscreen()\fR" 4
.IX Item "screen()"
gets a buffer with characters and attributes of the screen.
.ie n .IP """screen_set($buffer)""" 4
.el .IP "\f(CWscreen_set($buffer)\fR" 4
.IX Item "screen_set($buffer)"
restores the screen given the result of \fIscreen()\fR.  E.g., if the file
\&\f(CW$file\fR contains the sceen contents, then
.Sp
.Vb 7
\&  open IN, $file or die;
\&  binmode IN;
\&  read IN, $in, -s IN;
\&  $s = screen;
\&  $in .= qq(\e0) x (length($s) - length $in);
\&  substr($in, length $s) = '';
\&  screen_set $in;
.Ve
.Sp
will restore the screen content even if the height of the window
changed (if the width changed, more manipulation is needed).
.Sh "Control of the process list"
.IX Subsection "Control of the process list"
With the exception of \fITitle_set()\fR, all these calls require that \s-1PM\s0 is
running, they would not work under alternative Session Managers.
.IP "\fIprocess_entry()\fR" 4
.IX Item "process_entry()"
returns a list of the following data:
.RS 4
.IP "*" 4
Title of the process (in the \f(CW\*(C`Ctrl\-Esc\*(C'\fR list);
.IP "*" 4
window handle of switch entry of the process (in the \f(CW\*(C`Ctrl\-Esc\*(C'\fR list);
.IP "*" 4
window handle of the icon of the process;
.IP "*" 4
process handle of the owner of the entry in \f(CW\*(C`Ctrl\-Esc\*(C'\fR list;
.IP "*" 4
process id of the owner of the entry in \f(CW\*(C`Ctrl\-Esc\*(C'\fR list;
.IP "*" 4
session id of the owner of the entry in \f(CW\*(C`Ctrl\-Esc\*(C'\fR list;
.IP "*" 4
whether visible in \f(CW\*(C`Ctrl\-Esc\*(C'\fR list;
.IP "*" 4
whether item cannot be switched to (note that it is not actually
grayed in the \f(CW\*(C`Ctrl\-Esc\*(C'\fR list));
.IP "*" 4
whether participates in jump sequence;
.IP "*" 4
program type.  Possible values are:
.Sp
.Vb 6
\&     PROG_DEFAULT                       0
\&     PROG_FULLSCREEN                    1
\&     PROG_WINDOWABLEVIO                 2
\&     PROG_PM                            3
\&     PROG_VDM                           4
\&     PROG_WINDOWEDVDM                   7
.Ve
.Sp
Although there are several other program types for \s-1WIN\-OS/2\s0 programs,
these do not show up in this field. Instead, the \s-1PROG_VDM\s0 or
\&\s-1PROG_WINDOWEDVDM\s0 program types are used. For instance, for
\&\s-1PROG_31_STDSEAMLESSVDM\s0, \s-1PROG_WINDOWEDVDM\s0 is used. This is because all
the \s-1WIN\-OS/2\s0 programs run in \s-1DOS\s0 sessions. For example, if a program
is a windowed \s-1WIN\-OS/2\s0 program, it runs in a \s-1PROG_WINDOWEDVDM\s0
session. Likewise, if it's a full-screen \s-1WIN\-OS/2\s0 program, it runs in
a \s-1PROG_VDM\s0 session.
.IP "*" 4
switch-entry handle.
.RE
.RS 4
.Sp
Optional arguments: the pid and the window-handle of the application running
in the \s-1OS/2\s0 session to query.
.RE
.IP "\fIprocess_hentry()\fR" 4
.IX Item "process_hentry()"
similar to \fIprocess_entry()\fR, but returns a hash reference, the keys being
.Sp
.Vb 2
\&  title owner_hwnd icon_hwnd owner_phandle owner_pid owner_sid
\&  visible nonswitchable jumpable ptype sw_entry
.Ve
.Sp
(a copy of the list of keys is in \f(CW@hentry_fields\fR).
.IP "\fIprocess_entries()\fR" 4
.IX Item "process_entries()"
similar to \fIprocess_entry()\fR, but returns a list of array reference for all
the elements in the switch list (one controlling \f(CW\*(C`Ctrl\-Esc\*(C'\fR window).
.IP "\fIprocess_hentries()\fR" 4
.IX Item "process_hentries()"
similar to \fIprocess_hentry()\fR, but returns a list of hash reference for all
the elements in the switch list (one controlling \f(CW\*(C`Ctrl\-Esc\*(C'\fR window).
.IP "\fIchange_entry()\fR" 4
.IX Item "change_entry()"
changes a process entry, arguments are the same as \fIprocess_entry()\fR returns.
.IP "\fIchange_entryh()\fR" 4
.IX Item "change_entryh()"
Similar to \fIchange_entry()\fR, but takes a hash reference as an argument.
.IP "\fIprocess_hwnd()\fR" 4
.IX Item "process_hwnd()"
returns the \f(CW\*(C`owner_hwnd\*(C'\fR of the process entry (for \s-1VIO\s0 windowed processes
this is the frame window of the session).
.IP "\fITitle()\fR" 4
.IX Item "Title()"
returns the text of the task switch menu entry of the current session.
(There is no way to get this info in non-standard Session Managers.  This
implementation is a shortcut via \fIprocess_entry()\fR.)
.ie n .IP """Title_set(newtitle)""" 4
.el .IP "\f(CWTitle_set(newtitle)\fR" 4
.IX Item "Title_set(newtitle)"
tries two different interfaces.  The Session Manager one does not work
with some windows (if the title is set from the start).
This is a limitation of \s-1OS/2\s0, in such a case $^E is set to 372 (type
.Sp
.Vb 1
\&  help 372
.Ve
.Sp
for a funny \- and wrong  \- explanation ;\-).  In such cases a
direct-manipulation of low-level entries is used (same as \fIbothTitle_set()\fR).
Keep in mind that some versions of \s-1OS/2\s0 leak memory with such a manipulation.
.IP "\fIwinTitle()\fR" 4
.IX Item "winTitle()"
returns text of the titlebar of the current process' window.
.ie n .IP """winTitle_set(newtitle)""" 4
.el .IP "\f(CWwinTitle_set(newtitle)\fR" 4
.IX Item "winTitle_set(newtitle)"
sets text of the titlebar of the current process' window.  The change does not
affect the text of the switch entry of the current window.
.ie n .IP """swTitle_set(newtitle)""" 4
.el .IP "\f(CWswTitle_set(newtitle)\fR" 4
.IX Item "swTitle_set(newtitle)"
sets text of the task switch menu entry of the current process' window.  [There
is no \s-1API\s0 to query this title.]  Does it via SwitchEntry interface,
not Session manager interface.  The change does not affect the text of the
titlebar of the current window.
.ie n .IP """bothTitle_set(newtitle)""" 4
.el .IP "\f(CWbothTitle_set(newtitle)\fR" 4
.IX Item "bothTitle_set(newtitle)"
sets text of the titlebar and task switch menu of the current process' window
via direct manipulation of the windows' texts.
.ie n .IP """SwitchToProgram([$sw_entry])""" 4
.el .IP "\f(CWSwitchToProgram([$sw_entry])\fR" 4
.IX Item "SwitchToProgram([$sw_entry])"
switch to session given by a switch list handle (defaults to the entry of our process).
.Sp
Use of this function causes another window (and its related windows)
of a \s-1PM\s0 session to appear on the front of the screen, or a switch to
another session in the case of a non-PM program. In either case,
the keyboard (and mouse for the non-PM case) input is directed to
the new program.
.Sh "Control of the \s-1PM\s0 windows"
.IX Subsection "Control of the PM windows"
Some of these \s-1API\s0's require sending a message to the specified window.
In such a case the process needs to be a \s-1PM\s0 process, or to be morphed
to a \s-1PM\s0 process via \fIOS2::MorphPM()\fR.
.PP
For a temporary morphing to \s-1PM\s0 use \*(L"OS2::localMorphPM class\*(R".
.PP
Keep in mind that \s-1PM\s0 windows are engaged in 2 \*(L"orthogonal\*(R" window
trees, as well as in the z\-order list.
.PP
One tree is given by the \fIparent/child\fR relationship.  This
relationship affects drawing (child is drawn relative to its parent
(lower\-left corner), and the drawing is clipped by the parent's
boundary; parent may request that \fIit's\fR drawing is clipped to be
confined to the outsize of the childs and/or siblings' windows);
hiding; minimizing/restoring; and destroying windows.
.PP
Another tree (not necessarily connected?) is given by \fIownership\fR
relationship.  Ownership relationship assumes cooperation of the
engaged windows via passing messages on \*(L"important events\*(R"; e.g.,
scrollbars send information messages when the \*(L"bar\*(R" is moved, menus
send messages when an item is selected; frames
move/hide/unhide/minimize/restore/change\-z\-order\-of owned frames when
the owner is moved/etc., and destroy the owned frames (even when these
frames are not descendants) when the owner is destroyed; etc.  [An
important restriction on ownership is that owner should be created by
the same thread as the owned thread, so they engage in the same
message queue.]
.PP
Windows may be in many different state: Focused (take keyboard events) or not,
Activated (=Frame windows in the \fIparent/child\fR tree between the root and
the window with the focus; usually indicate such \*(L"active state\*(R" by titlebar
highlights, and take mouse events) or not, Enabled/Disabled (this influences
the ability to update the graphic, and may change appearance, as for 
enabled/disabled buttons), Visible/Hidden, Minimized/Maximized/Restored, Modal
or not, etc.
.PP
The APIs below all \fIdie()\fR on error with the message being $^E.
.ie n .IP """WindowText($hwnd)""" 4
.el .IP "\f(CWWindowText($hwnd)\fR" 4
.IX Item "WindowText($hwnd)"
gets \*(L"a text content\*(R" of a window.  Requires (morphing to) \s-1PM\s0.
.ie n .IP """WindowText_set($hwnd, $text)""" 4
.el .IP "\f(CWWindowText_set($hwnd, $text)\fR" 4
.IX Item "WindowText_set($hwnd, $text)"
sets \*(L"a text content\*(R" of a window.  Requires (morphing to) \s-1PM\s0.
.ie n .IP """($x, $y, $flags, $width, $height, $behind, @rest) = WindowPos($hwnd)""" 4
.el .IP "\f(CW($x, $y, $flags, $width, $height, $behind, @rest) = WindowPos($hwnd)\fR" 4
.IX Item "($x, $y, $flags, $width, $height, $behind, @rest) = WindowPos($hwnd)"
gets window position info as 8 integers (of \f(CW\*(C`SWP\*(C'\fR), in the order suitable
for \fIWindowPos_set()\fR.  \f(CW@rest\fR is marked as \*(L"reserved\*(R" in \s-1PM\s0 docs.  \f(CW$flags\fR
is a combination of \f(CW\*(C`SWP_*\*(C'\fR constants.
.ie n .IP """$hash = hWindowPos($hwnd)""" 4
.el .IP "\f(CW$hash = hWindowPos($hwnd)\fR" 4
.IX Item "$hash = hWindowPos($hwnd)"
gets window position info as a hash reference; the keys are \f(CW\*(C`flags width
height x y behind hwnd reserved1 reserved2\*(C'\fR.
.Sp
Example:
.Sp
.Vb 1
\&  exit unless $hash->{flags} & SWP_MAXIMIZE;    # Maximized
.Ve
.ie n .IP """WindowPos_set($hwnd, $x, $y, $flags = SWP_MOVE, $width = 0, $height = 0, $behind = HWND_TOP)""" 4
.el .IP "\f(CWWindowPos_set($hwnd, $x, $y, $flags = SWP_MOVE, $width = 0, $height = 0, $behind = HWND_TOP)\fR" 4
.IX Item "WindowPos_set($hwnd, $x, $y, $flags = SWP_MOVE, $width = 0, $height = 0, $behind = HWND_TOP)"
Set state of the window: position, size, zorder, show/hide, activation,
minimize/maximize/restore etc.  Which of these operations to perform
is governed by \f(CW$flags\fR.
.ie n .IP """hWindowPos_set($hash, [$hwnd])""" 4
.el .IP "\f(CWhWindowPos_set($hash, [$hwnd])\fR" 4
.IX Item "hWindowPos_set($hash, [$hwnd])"
Same as \f(CW\*(C`WindowPos_set\*(C'\fR, but takes the position from keys \f(CW\*(C`fl width height
x y behind hwnd\*(C'\fR of the hash referenced by \f(CW$hash\fR.  If \f(CW$hwnd\fR is explicitly
specified, it overrides \f(CW\*(C`$hash\-\*(C'\fR{hwnd}>.  If \f(CW$hash\fR\->{flags} is not specified,
it is calculated basing on the existing keys of \f(CW$hash\fR.  Requires (morphing to) \s-1PM\s0.
.Sp
Example:
.Sp
.Vb 1
\&  hWindowPos_set {flags => SWP_MAXIMIZE}, $hwnd; # Maximize
.Ve
.ie n .IP """($pid, $tid) = WindowProcess($hwnd)""" 4
.el .IP "\f(CW($pid, $tid) = WindowProcess($hwnd)\fR" 4
.IX Item "($pid, $tid) = WindowProcess($hwnd)"
gets \fI\s-1PID\s0\fR and \fI\s-1TID\s0\fR of the process associated to the window.
.ie n .IP """ClassName($hwnd)""" 4
.el .IP "\f(CWClassName($hwnd)\fR" 4
.IX Item "ClassName($hwnd)"
returns the class name of the window.
.Sp
If this window is of any of the preregistered WC_* classes the class
name returned is in the form \*(L"#nnnnn\*(R", where \*(L"nnnnn\*(R" is a group
of up to five digits that corresponds to the value of the WC_* class name
constant.
.IP "\fIFocusWindow()\fR" 4
.IX Item "FocusWindow()"
returns the handle of the focus window.  Optional argument for specifying
the desktop to use.
.ie n .IP """FocusWindow_set($hwnd)""" 4
.el .IP "\f(CWFocusWindow_set($hwnd)\fR" 4
.IX Item "FocusWindow_set($hwnd)"
set the focus window by handle.  Optional argument for specifying the desktop
to use.  E.g, the first entry in \fIprogram_entries()\fR is the \f(CW\*(C`Ctrl\-Esc\*(C'\fR list.
To show an application, use either one of
.Sp
.Vb 3
\&       WinShowWindow( $hwnd, 1 );
\&       FocusWindow_set( $hwnd );
\&       SwitchToProgram($switch_handle);
.Ve
.Sp
(Which work with alternative focus-to-front policies?)  Requires
(morphing to) \s-1PM\s0.
.Sp
Switching focus to currently-unfocused window moves the window to the
front in Z\-order; use \fIFocusWindow_set_keep_Zorder()\fR to avoid this.
.ie n .IP """FocusWindow_set_keep_Zorder($hwnd)""" 4
.el .IP "\f(CWFocusWindow_set_keep_Zorder($hwnd)\fR" 4
.IX Item "FocusWindow_set_keep_Zorder($hwnd)"
same as \fIFocusWindow_set()\fR, but preserves the Z\-order of windows.
.ie n .IP """ActiveWindow([$parentHwnd])""" 4
.el .IP "\f(CWActiveWindow([$parentHwnd])\fR" 4
.IX Item "ActiveWindow([$parentHwnd])"
gets the active subwindow's handle for \f(CW$parentHwnd\fR or desktop.
Returns \s-1FALSE\s0 if none.
.ie n .IP """ActiveWindow_set($hwnd, [$parentHwnd])""" 4
.el .IP "\f(CWActiveWindow_set($hwnd, [$parentHwnd])\fR" 4
.IX Item "ActiveWindow_set($hwnd, [$parentHwnd])"
sets the active subwindow's handle for \f(CW$parentHwnd\fR or desktop.  Requires (morphing to) \s-1PM\s0.
.ie n .IP """ShowWindow($hwnd [, $show])""" 4
.el .IP "\f(CWShowWindow($hwnd [, $show])\fR" 4
.IX Item "ShowWindow($hwnd [, $show])"
Set visible/hidden flag of the window.  Default: \f(CW$show\fR is \s-1TRUE\s0.
.ie n .IP """EnableWindowUpdate($hwnd [, $update])""" 4
.el .IP "\f(CWEnableWindowUpdate($hwnd [, $update])\fR" 4
.IX Item "EnableWindowUpdate($hwnd [, $update])"
Set window visibility state flag for the window for subsequent drawing.
No actual drawing is done at this moment.  Use \f(CW\*(C`ShowWindow($hwnd, $state)\*(C'\fR
when redrawing is needed.  While update is disabled, changes to the \*(L"window
state\*(R" do not change the appearence of the window.  Default: \f(CW$update\fR is \s-1TRUE\s0.
.Sp
(What is manipulated is the bit \f(CW\*(C`WS_VISIBLE\*(C'\fR of the window style.)
.ie n .IP """EnableWindow($hwnd [, $enable])""" 4
.el .IP "\f(CWEnableWindow($hwnd [, $enable])\fR" 4
.IX Item "EnableWindow($hwnd [, $enable])"
Set the window enabled state.  Default: \f(CW$enable\fR is \s-1TRUE\s0.
.Sp
Results in \f(CW\*(C`WM_ENABLED\*(C'\fR message sent to the window.  Typically, this
would change the appearence of the window.  If at the moment of disabling
focus is in the window (or a descendant), focus is lost (no focus anywhere).
If focus is needed, it can be reassigned explicitly later.
.IP "\fIIsWindowEnabled()\fR, \fIIsWindowVisible()\fR, \fIIsWindowShowing()\fR" 4
.IX Item "IsWindowEnabled(), IsWindowVisible(), IsWindowShowing()"
these functions take \f(CW$hwnd\fR as an argument.  \fIIsWindowEnabled()\fR queries
the state changed by \fIEnableWindow()\fR, \fIIsWindowVisible()\fR the state changed
by \fIShowWindow()\fR, \fIIsWindowShowing()\fR is true if there is a part of the window
visible on the screen.
.ie n .IP """PostMsg($hwnd, $msg, $mp1, $mp2)""" 4
.el .IP "\f(CWPostMsg($hwnd, $msg, $mp1, $mp2)\fR" 4
.IX Item "PostMsg($hwnd, $msg, $mp1, $mp2)"
post message to a window.  The meaning of \f(CW$mp1\fR, \f(CW$mp2\fR is specific for each
message id \f(CW$msg\fR, they default to 0.  E.g.,
.Sp
.Vb 6
\&  use OS2::Process qw(:DEFAULT WM_SYSCOMMAND WM_CONTEXTMENU
\&                      WM_SAVEAPPLICATION WM_QUIT WM_CLOSE
\&                      SC_MAXIMIZE SC_RESTORE);
\&  $hwnd = process_hentry()->{owner_hwnd};
\&  # Emulate choosing `Restore' from the window menu:
\&  PostMsg $hwnd, WM_SYSCOMMAND, MPFROMSHORT(SC_RESTORE); # Not immediate
.Ve
.Sp
.Vb 3
\&  # Emulate `Show-Contextmenu' (Double-Click-2), two ways:
\&  PostMsg ActiveWindow, WM_CONTEXTMENU;
\&  PostMsg FocusWindow, WM_CONTEXTMENU;
.Ve
.Sp
.Vb 2
\&  /* Emulate `Close' */
\&  PostMsg ActiveWindow, WM_CLOSE;
.Ve
.Sp
.Vb 5
\&  /* Same but with some "warnings" to the application */
\&  $hwnd = ActiveWindow;
\&  PostMsg $hwnd, WM_SAVEAPPLICATION;
\&  PostMsg $hwnd, WM_CLOSE;
\&  PostMsg $hwnd, WM_QUIT;
.Ve
.Sp
In fact, \s-1\fIMPFROMSHORT\s0()\fR may be omited above.
.Sp
For messages to other processes, messages which take/return a pointer are
not supported.
.ie n .IP """MP*()""" 4
.el .IP "\f(CWMP*()\fR" 4
.IX Item "MP*()"
The functions \s-1\fIMPFROMSHORT\s0()\fR, \s-1\fIMPVOID\s0()\fR, \s-1\fIMPFROMCHAR\s0()\fR, \s-1\fIMPFROM2SHORT\s0()\fR,
\&\s-1\fIMPFROMSH2CH\s0()\fR, \s-1\fIMPFROMLONG\s0()\fR can be used the same way as from C.  Use them
to construct parameters \f(CW$m1\fR, \f(CW$m2\fR to \fIPostMsg()\fR.
.Sp
These functions are not exported by default.
.ie n .IP """$eh = BeginEnumWindows($hwnd)""" 4
.el .IP "\f(CW$eh = BeginEnumWindows($hwnd)\fR" 4
.IX Item "$eh = BeginEnumWindows($hwnd)"
starts enumerating immediate child windows of \f(CW$hwnd\fR in z\-order.  The
enumeration reflects the state at the moment of \fIBeginEnumWindows()\fR calls;
use \fIIsWindow()\fR to be sure.  All the functions in this group require (morphing to) \s-1PM\s0.
.ie n .IP """$kid_hwnd = GetNextWindow($eh)""" 4
.el .IP "\f(CW$kid_hwnd = GetNextWindow($eh)\fR" 4
.IX Item "$kid_hwnd = GetNextWindow($eh)"
gets the next kid in the list.  Gets 0 on error or when the list ends.
.ie n .IP """EndEnumWindows($eh)""" 4
.el .IP "\f(CWEndEnumWindows($eh)\fR" 4
.IX Item "EndEnumWindows($eh)"
End enumeration and release the list.
.ie n .IP """@list = ChildWindows([$hwnd])""" 4
.el .IP "\f(CW@list = ChildWindows([$hwnd])\fR" 4
.IX Item "@list = ChildWindows([$hwnd])"
returns the list of child windows at the moment of the call.  Same remark
as for enumeration interface applies.  Defaults to \s-1HWND_DESKTOP\s0.
Example of usage:
.Sp
.Vb 6
\&  sub l {
\&    my ($o,$h) = @_;
\&    printf ' ' x $o . "%#x\en", $h;
\&    l($o+2,$_) for ChildWindows $h;
\&  }
\&  l 0, $HWND_DESKTOP
.Ve
.ie n .IP """IsWindow($hwnd)""" 4
.el .IP "\f(CWIsWindow($hwnd)\fR" 4
.IX Item "IsWindow($hwnd)"
true if the window handle is still valid.
.ie n .IP """QueryWindow($hwnd, $type)""" 4
.el .IP "\f(CWQueryWindow($hwnd, $type)\fR" 4
.IX Item "QueryWindow($hwnd, $type)"
gets the handle of a related window.  \f(CW$type\fR should be one of \f(CW\*(C`QW_*\*(C'\fR constants.
.ie n .IP """IsChild($hwnd, $parent)""" 4
.el .IP "\f(CWIsChild($hwnd, $parent)\fR" 4
.IX Item "IsChild($hwnd, $parent)"
return \s-1TRUE\s0 if \f(CW$hwnd\fR is a descendant of \f(CW$parent\fR.
.ie n .IP """WindowFromId($hwnd, $id)""" 4
.el .IP "\f(CWWindowFromId($hwnd, $id)\fR" 4
.IX Item "WindowFromId($hwnd, $id)"
return a window handle of a child of \f(CW$hwnd\fR with the given \f(CW$id\fR.
.Sp
.Vb 4
\&  hwndSysMenu = WinWindowFromID(hwndDlg, FID_SYSMENU);
\&  WinSendMsg(hwndSysMenu, MM_SETITEMATTR,
\&      MPFROM2SHORT(SC_CLOSE, TRUE),
\&      MPFROM2SHORT(MIA_DISABLED, MIA_DISABLED));
.Ve
.ie n .IP """WindowFromPoint($x, $y [, $hwndParent [, $descedantsToo]])""" 4
.el .IP "\f(CWWindowFromPoint($x, $y [, $hwndParent [, $descedantsToo]])\fR" 4
.IX Item "WindowFromPoint($x, $y [, $hwndParent [, $descedantsToo]])"
gets a handle of a child of \f(CW$hwndParent\fR at \f(CW\*(C`($x,$y)\*(C'\fR.  If \f(CW$descedantsToo\fR
(defaulting to 1) then children of children may be returned too.  May return
\&\f(CW$hwndParent\fR (defaults to desktop) if no suitable children are found,
or 0 if the point is outside the parent.
.Sp
$x and \f(CW$y\fR are relative to \f(CW$hwndParent\fR.
.ie n .IP """EnumDlgItem($dlgHwnd, $type [, $relativeHwnd])""" 4
.el .IP "\f(CWEnumDlgItem($dlgHwnd, $type [, $relativeHwnd])\fR" 4
.IX Item "EnumDlgItem($dlgHwnd, $type [, $relativeHwnd])"
gets a dialog item window handle for an item of type \f(CW$type\fR of \f(CW$dlgHwnd\fR
relative to \f(CW$relativeHwnd\fR, which is descendant of \f(CW$dlgHwnd\fR.
\&\f(CW$relativeHwnd\fR may be specified if \f(CW$type\fR is \s-1EDI_FIRSTTABITEM\s0 or
\&\s-1EDI_LASTTABITEM\s0.
.Sp
The return is always an immediate child of hwndDlg, even if hwnd is
not an immediate child window.  \f(CW$type\fR may be
.RS 4
.IP "\s-1EDI_FIRSTGROUPITEM\s0" 4
.IX Item "EDI_FIRSTGROUPITEM"
First item in the same group.
.IP "\s-1EDI_FIRSTTABITEM\s0" 4
.IX Item "EDI_FIRSTTABITEM"
First item in dialog with style \s-1WS_TABSTOP\s0. hwnd is ignored.
.IP "\s-1EDI_LASTGROUPITEM\s0" 4
.IX Item "EDI_LASTGROUPITEM"
Last item in the same group.
.IP "\s-1EDI_LASTTABITEM\s0" 4
.IX Item "EDI_LASTTABITEM"
Last item in dialog with style \s-1WS_TABSTOP\s0. hwnd is ignored.
.IP "\s-1EDI_NEXTGROUPITEM\s0" 4
.IX Item "EDI_NEXTGROUPITEM"
Next item in the same group. Wraps around to beginning of group when
the end of the group is reached.
.IP "\s-1EDI_NEXTTABITEM\s0" 4
.IX Item "EDI_NEXTTABITEM"
Next item with style \s-1WS_TABSTOP\s0. Wraps around to beginning of dialog
item list when end is reached.
.IP "\s-1EDI_PREVGROUPITEM\s0" 4
.IX Item "EDI_PREVGROUPITEM"
Previous item in the same group. Wraps around to end of group when the
start of the group is reached. For information on the \s-1WS_GROUP\s0 style,
see Window Styles.
.IP "\s-1EDI_PREVTABITEM\s0" 4
.IX Item "EDI_PREVTABITEM"
Previous item with style \s-1WS_TABSTOP\s0. Wraps around to end of dialog
item list when beginning is reached.
.RE
.RS 4
.RE
.IP "\fIDesktopWindow()\fR" 4
.IX Item "DesktopWindow()"
gets the actual window handle of the \s-1PM\s0 desktop; most APIs accept the
pseudo-handle \f(CW\*(C`HWND_DESKTOP\*(C'\fR instead.  Keep in mind that the \s-1WPS\s0
desktop (one with \fIWindowText()\fR being \f(CW"Desktop"\fR) is a different beast?!
.IP "TopLevel($hwnd)" 4
.IX Item "TopLevel($hwnd)"
gets the toplevel window of \f(CW$hwnd\fR.
.IP "\fIResetWinError()\fR" 4
.IX Item "ResetWinError()"
Resets $^E.  One may need to call it before the \f(CW\*(C`Win*\*(C'\fR\-class APIs which may
return 0 during normal operation.  In such a case one should check both
for return value being zero and $^E being non\-zero.  The following APIs
do \fIResetWinError()\fR themselves, thus do not need an explicit one:
.Sp
.Vb 6
\&  WindowPtr
\&  WindowULong
\&  WindowUShort
\&  WindowTextLength
\&  ActiveWindow
\&  PostMsg
.Ve
.Sp
This function is normally not needed.  Not exported by default.
.Sh "Control of the \s-1PM\s0 data"
.IX Subsection "Control of the PM data"
.IP "\fIActiveDesktopPathname()\fR" 4
.IX Item "ActiveDesktopPathname()"
gets the path of the directory which corresponds to Desktop.
.IP "\fIClipbrdText()\fR" 4
.IX Item "ClipbrdText()"
gets the content of the clipboard.  An optional argument is the format
of the data in the clipboard (defaults to \f(CW\*(C`CF_TEXT\*(C'\fR).
.Sp
Note that the usual convention is to have clipboard data with
\&\f(CW"\er\en"\fR as line separators.
.IP "ClipbrdText_set($txt)" 4
.IX Item "ClipbrdText_set($txt)"
sets the text content of the clipboard.  Unless the optional argument
is \s-1TRUE\s0, will convert newlines to \f(CW"\er\en"\fR.  Another optional
argument is the format of the data in the clipboard (defaults to
\&\f(CW\*(C`CF_TEXT\*(C'\fR).
.IP "InvalidateRect" 4
.IX Item "InvalidateRect"
.PD 0
.IP "CreateFrameControl" 4
.IX Item "CreateFrameControl"
.IP "ClipbrdFmtInfo" 4
.IX Item "ClipbrdFmtInfo"
.IP "ClipbrdOwner" 4
.IX Item "ClipbrdOwner"
.IP "ClipbrdViewer" 4
.IX Item "ClipbrdViewer"
.IP "ClipbrdData" 4
.IX Item "ClipbrdData"
.IP "OpenClipbrd" 4
.IX Item "OpenClipbrd"
.IP "CloseClipbrd" 4
.IX Item "CloseClipbrd"
.IP "ClipbrdData_set" 4
.IX Item "ClipbrdData_set"
.IP "ClipbrdOwner_set" 4
.IX Item "ClipbrdOwner_set"
.IP "ClipbrdViewer_set" 4
.IX Item "ClipbrdViewer_set"
.IP "EnumClipbrdFmts" 4
.IX Item "EnumClipbrdFmts"
.IP "EmptyClipbrd" 4
.IX Item "EmptyClipbrd"
.IP "AddAtom" 4
.IX Item "AddAtom"
.IP "FindAtom" 4
.IX Item "FindAtom"
.IP "DeleteAtom" 4
.IX Item "DeleteAtom"
.IP "AtomUsage" 4
.IX Item "AtomUsage"
.IP "AtomName" 4
.IX Item "AtomName"
.IP "AtomLength" 4
.IX Item "AtomLength"
.IP "SystemAtomTable" 4
.IX Item "SystemAtomTable"
.IP "CreateAtomTable" 4
.IX Item "CreateAtomTable"
.IP "DestroyAtomTable" 4
.IX Item "DestroyAtomTable"
.PD
Low-level methods to access clipboard and the atom table(s).
.SH "OS2::localMorphPM class"
.IX Header "OS2::localMorphPM class"
This class morphs the process to \s-1PM\s0 for the duration of the given scope.
.PP
.Vb 4
\&  {
\&    my $h = OS2::localMorphPM->new(0);
\&    # Do something
\&  }
.Ve
.PP
The argument has the same meaning as one to \fIOS2::MorphPM()\fR.  Calls can
nest with internal ones being NOPs.
.SH "TODO"
.IX Header "TODO"
Add tests for:
.PP
.Vb 24
\&        SwitchToProgram
\&        ClassName
\&        out_codepage
\&        out_codepage_set
\&        in_codepage
\&        in_codepage_set
\&        cursor
\&        cursor_set
\&        screen
\&        screen_set
\&        process_codepages
\&        QueryWindow
\&        EnumDlgItem
\&        WindowPtr
\&        WindowULong
\&        WindowUShort
\&        SetWindowBits
\&        SetWindowPtr
\&        SetWindowULong
\&        SetWindowUShort
\&        my_type
\&        file_type
\&        scrsize
\&        scrsize_set
.Ve
.PP
Document and test: Query/SetWindowULong/Short/Ptr, SetWindowBits.
InvalidateRect, CreateFrameControl, ClipbrdFmtInfo ClipbrdOwner
ClipbrdViewer ClipbrdData OpenClipbrd CloseClipbrd ClipbrdData_set
ClipbrdOwner_set ClipbrdViewer_set EnumClipbrdFmts EmptyClipbrd
AddAtom FindAtom DeleteAtom AtomUsage AtomName AtomLength
SystemAtomTable CreateAtomTable DestroyAtomTable
.PP
Implement \s-1SOMETHINGFROMMR\s0.
.PP
.Vb 5
\&  >But I wish to change the default button if the user enters some
\&  >text into an entryfield.  I can detect the entry ok, but can't
\&  >seem to get the button to change to default.
\&  >
\&  >No matter what message I send it, it's being ignored.
.Ve
.PP
.Vb 12
\&  You need to get the style of the buttons using WinQueryWindowULong/QWL_STYLE,
\&  set and reset the BS_DEFAULT bits as appropriate and then use
\&  WinSetWindowULong/QWL_STYLE to set the button style.
\&  Something like this:
\&    hwnd1 = WinWindowFromID (hwnd, id1);
\&    hwnd2 = WinWindowFromID (hwnd, id2);
\&    style1 = WinQueryWindowULong (hwnd1, QWL_STYLE);
\&    style2 = WinQueryWindowULong (hwnd2, QWL_STYLE);
\&    style1 |= style2 & BS_DEFAULT;
\&    style2 &= ~BS_DEFAULT;
\&    WinSetWindowULong (hwnd1, QWL_STYLE, style1);
\&    WinSetWindowULong (hwnd2, QWL_STYLE, style2);
.Ve
.PP
.Vb 1
\& > How to do query and change a frame creation flags for existing window?
.Ve
.PP
.Vb 3
\& Set the style bits that correspond to the FCF_* flag for the frame
\& window and then send a WM_UPDATEFRAME message with the appropriate FCF_*
\& flag in mp1.
.Ve
.PP
.Vb 11
\& ULONG ulFrameStyle;
\& ulFrameStyle = WinQueryWindowULong( WinQueryWindow(hwnd, QW_PARENT),
\& QWL_STYLE );
\& ulFrameStyle = (ulFrameStyle & ~FS_SIZEBORDER) | FS_BORDER;
\& WinSetWindowULong(   WinQueryWindow(hwnd, QW_PARENT),
\&                      QWL_STYLE,
\&                      ulFrameStyle );
\& WinSendMsg( WinQueryWindow(hwnd, QW_PARENT),
\&             WM_UPDATEFRAME,
\&             MPFROMP(FCF_SIZEBORDER),
\&             MPVOID );
.Ve
.PP
.Vb 6
\& If the FCF_* flags you want to change does not have a corresponding FS_*
\& style (i.e. the FCF_* flag corresponds to the presence/lack of a frame
\& control rather than a property of the frame itself) then you create or
\& destroy the appropriate control window using the correct FID_* window
\& identifier and then send the WM_UPDATEFRAME message with the appropriate
\& FCF_* flag in mp1.
.Ve
.PP
.Vb 15
\& /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
\&  |  SetFrameBorder()                                                          |
\&  |    Changes a frame window's border to the requested type.                  |
\&  |                                                                            |
\&  |  Parameters on entry:                                                      |
\&  |    hwndFrame     -> Frame window whose border is to be changed.            |
\&  |    ulBorderStyle -> Type of border to change to.                           |
\&  |                                                                            |
\&  |  Returns:                                                                  |
\&  |    BOOL          -> Success indicator.                                     |
\&  |                                                                            |
\&  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
\& BOOL SetFrameBorder( HWND hwndFrame, ULONG ulBorderType )  {
\&   ULONG  ulFrameStyle;
\&   BOOL   fSuccess = TRUE;
.Ve
.PP
.Vb 1
\&   ulFrameStyle = WinQueryWindowULong( hwndFrame, QWL_STYLE );
.Ve
.PP
.Vb 5
\&   switch ( ulBorderType )  {
\&     case FS_SIZEBORDER :
\&       ulFrameStyle = (ulFrameStyle & ~(FS_DLGBORDER | FS_BORDER))
\&                      | FS_SIZEBORDER;
\&       break;
.Ve
.PP
.Vb 4
\&     case FS_DLGBORDER :
\&       ulFrameStyle = (ulFrameStyle & ~(FS_SIZEBORDER | FS_BORDER))
\&                      | FS_DLGBORDER;
\&       break;
.Ve
.PP
.Vb 4
\&     case FS_BORDER :
\&       ulFrameStyle = (ulFrameStyle & ~(FS_SIZEBORDER | FS_DLGBORDER))
\&                      | FS_BORDER;
\&       break;
.Ve
.PP
.Vb 4
\&     default :
\&       fSuccess = FALSE;
\&       break;
\&   }  // end switch
.Ve
.PP
.Vb 2
\&   if ( fSuccess )  {
\&     fSuccess = WinSetWindowULong( hwndFrame, QWL_STYLE, ulFrameStyle );
.Ve
.PP
.Vb 6
\&     if ( fSuccess )  {
\&       fSuccess = (BOOL)WinSendMsg( hwndFrame, WM_UPDATEFRAME, 0, 0 );
\&       if ( fSuccess )
\&         fSuccess = WinInvalidateRect( hwndFrame, NULL, TRUE );
\&     }
\&   }
.Ve
.PP
.Vb 1
\&   return ( fSuccess );
.Ve
.PP
.Vb 1
\& }  // End SetFrameBorder()
.Ve
.PP
.Vb 5
\&         hwndMenu=WinLoadMenu(hwndParent,NULL,WND_IMAGE);
\&         WinSetWindowUShort(hwndMenu,QWS_ID,FID_MENU);
\&         ulStyle=WinQueryWindowULong(hwndMenu,QWL_STYLE);
\&         WinSetWindowULong(hwndMenu,QWL_STYLE,ulStyle|MS_ACTIONBAR);
\&         WinSendMsg(hwndParent,WM_UPDATEFRAME,MPFROMSHORT(FCF_MENU),0L);
.Ve
.PP
.Vb 2
\&  OS/2-windows have another "parent" called the *owner*,
\&  which must be set separately - to get a close relationship:
.Ve
.PP
.Vb 1
\&    WinSetOwner (hwndFrameChild, hwndFrameMain);
.Ve
.PP
.Vb 2
\&  Now your child should move with your main window!
\&  And always stays on top of it....
.Ve
.PP
.Vb 2
\&  To avoid this, for example for dialogwindows, you can
\&  also "disconnect" this relationship with:
.Ve
.PP
.Vb 3
\&    WinSetWindowBits (hwndFrameChild, QWL_STYLE
\&                      , FS_NOMOVEWITHOWNER
\&                      , FS_NOMOVEWITHOWNER);
.Ve
.PP
.Vb 1
\& Adding a button icon later:
.Ve
.PP
.Vb 2
\& /* switch the button style to BS_MINIICON */
\& WinSetWindowBits(hwndBtn, QWL_STYLE, BS_MINIICON, BS_MINIICON) ;
.Ve
.PP
.Vb 5
\& /* set up button control data */
\& BTNCDATA    bcd;
\& bcd.cb = sizeof(BTNCDATA);
\& bcd.hImage = WinLoadPointer(HWND_DESKTOP, dllHandle, ID_ICON_BUTTON1) ;
\& bcd.fsCheckState = bcd.fsHiliteState = 0 ;
.Ve
.PP
.Vb 3
\& WNDPARAMS   wp;
\& wp.fsStatus = WPM_CTLDATA;
\& wp.pCtlData = &bcd;
.Ve
.PP
.Vb 2
\& /* add the icon on the button */
\& WinSendMsg(hwndBtn, WM_SETWINDOWPARAMS, (MPARAM)&wp, NULL);
.Ve
.PP
.Vb 6
\& MO> Can anyone tell what OS/2 expects of an application to be properly
\& MO> minimized to the desktop?
\& case WM MINMAXFRAME :
\& {
\&   BOOL  fShow = ! (((PSWP) mp1)->fl & SWP MINIMIZE);
\&   HENUM henum;
.Ve
.PP
.Vb 1
\&   HWND  hwndChild;
.Ve
.PP
.Vb 1
\&   WinEnableWindowUpdate ( hwnd, FALSE );
.Ve
.PP
.Vb 3
\&   for (henum=WinBeginEnumWindows(hwnd);
\&        (hwndChild = WinGetNextWindow (henum)) != 0; )
\&   WinShowWindow ( hwndChild, fShow );
.Ve
.PP
.Vb 4
\&   WinEndEnumWindows ( henum );
\&   WinEnableWindowUpdate ( hwnd, TRUE );
\& }
\& break;
.Ve
.PP
Why \f(CW\*(C`hWindowPos DesktopWindow\*(C'\fR gives \f(CW\*(C`behind => HWND_TOP\*(C'\fR?
.SH "$^E"
.IX Header "$^E"
the majority of the APIs of this module set $^E on failure (no matter
whether they \fIdie()\fR on failure or not).  By the semantic of \s-1PM\s0 \s-1API\s0
which returns something other than a boolean, it is impossible to
distinguish failure from a \*(L"normal\*(R" 0\-return.  In such cases \f(CW\*(C`$^E ==
0\*(C'\fR indicates an absence of error.
.SH "EXPORTS"
.IX Header "EXPORTS"
In addition to symbols described above, the following constants (available
also via module \f(CW\*(C`OS2::Process::Const\*(C'\fR) are exportable.  Note that these
symbols live in package \f(CW\*(C`OS2::Process::Const\*(C'\fR, they are not available
by full name through \f(CW\*(C`OS2::Process\*(C'\fR!
.PP
.Vb 23
\&  HWND_*                Standard (abstract) window handles
\&  WM_*                  Message ids
\&  SC_*                  WM_SYSCOMMAND flavor
\&  SWP_*                 Size/move etc flag
\&  WC_*                  Standard window classes
\&  PROG_*                Program category (PM, VIO etc)
\&  QW_*                  Query-Window flag
\&  EDI_*                 Enumerate-Dialog-Item code
\&  WS_*                  Window Style flag
\&  QWS_*                 Query-window-UShort offsets
\&  QWP_*                 Query-window-pointer offsets
\&  QWL_*                 Query-window-ULong offsets
\&  FF_*                  Frame-window state flags
\&  FI_*                  Frame-window information flags
\&  LS_*                  List box styles
\&  FS_*                  Frame style
\&  FCF_*                 Frame creation flags
\&  BS_*                  Button style
\&  MS_*                  Menu style
\&  TBM_*                 Title bar messages?
\&  CF_*                  Clipboard formats
\&  CFI_*                 Clipboard storage type
\&  FID_*                 ids of subwindows of frames
.Ve
.SH "BUGS"
.IX Header "BUGS"
whether a given \s-1API\s0 dies or returns FALSE/empty\-list on error may be
confusing.  This may change in the future.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andreas Kaiser <ak@ananke.s.bawue.de>,
Ilya Zakharevich <ilya@math.ohio\-state.edu>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\f(CW\*(C`spawn*\*(C'\fR() system calls, OS2::Proc and OS2::WinObject modules.
