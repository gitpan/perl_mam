.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH CGI::Push 3 "perl 5.004, patch 55" "25/Nov/97" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
CGI::Push \- Simple Interface to Server Push
.SH "SYNOPSIS"
.PP
.Vb 1
\&    use CGI::Push qw(:standard);
.Ve
.Vb 3
\&    do_push(-next_page=>\e&next_page,
\&            -last_page=>\e&last_page,
\&            -delay=>0.5);
.Ve
.Vb 8
\&    sub next_page {
\&        my($q,$counter) = @_;
\&        return undef if $counter >= 10;
\&        return start_html('Test'),
\&               h1('Visible'),"\en",
\&               "This page has been called ", strong($counter)," times",
\&               end_html();
\&      }
.Ve
.Vb 7
\&     sub last_page {
\&         my($q,$counter) = @_;
\&         return start_html('Done'),
\&                h1('Finished'),
\&                strong($counter),' iterations.',
\&                end_html;
\&     }
.Ve
.SH "DESCRIPTION"
CGI::Push is a subclass of the CGI object created by CGI.pm.  It is
specialized for server push operations, which allow you to create
animated pages whose content changes at regular intervals.
.PP
You provide CGI::Push with a pointer to a subroutine that will draw
one page.  Every time your subroutine is called, it generates a new
page.  The contents of the page will be transmitted to the browser
in such a way that it will replace what was there beforehand.  The
technique will work with HTML pages as well as with graphics files, 
allowing you to create animated GIFs.
.SH "USING CGI::Push"
CGI::Push adds one new method to the standard CGI suite, \fIdo_push()\fR.
When you call this method, you pass it a reference to a subroutine
that is responsible for drawing each new page, an interval delay, and
an optional subroutine for drawing the last page.  Other optional
parameters include most of those recognized by the CGI \fIheader()\fR
method.
.PP
You may call \fIdo_push()\fR in the object oriented manner or not, as you
prefer:
.PP
.Vb 3
\&    use CGI::Push;
\&    $q = new CGI::Push;
\&    $q->do_push(-next_page=>\e&draw_a_page);
.Ve
.Vb 1
\&        -or-
.Ve
.Vb 2
\&    use CGI::Push qw(:standard);
\&    do_push(-next_page=>\e&draw_a_page);
.Ve
Parameters are as follows:
.Ip "-next_page" 4
.Sp
.Vb 1
\&    do_push(-next_page=>\e&my_draw_routine);
.Ve
This required parameter points to a reference to a subroutine responsible for
drawing each new page.  The subroutine should expect two parameters
consisting of the \s-1CGI\s0 object and a counter indicating the number
of times the subroutine has been called.  It should return the
contents of the page as an \fBarray\fR of one or more items to print.  
It can return a false value (or an empty array) in order to abort the
redrawing loop and print out the final page (if any)
.Sp
.Vb 7
\&    sub my_draw_routine {
\&        my($q,$counter) = @_;
\&        return undef if $counter > 100;
\&        return start_html('testing'),
\&               h1('testing'),
\&               "This page called $counter times";
\&    }
.Ve
.Ip "-last_page" 4
This optional parameter points to a reference to the subroutine
responsible for drawing the last page of the series.  It is called
after the \-next_page routine returns a false value.  The subroutine
itself should have exactly the same calling conventions as the
\-next_page routine.
.Ip "-type" 4
This optional parameter indicates the content type of each page.  It
defaults to \*(L"text/html\*(R".  Currently, server push of heterogeneous
document types is not supported.
.Ip "-delay" 4
This indicates the delay, in seconds, between frames.  Smaller delays
refresh the page faster.  Fractional values are allowed.
.Sp
\fBIf not specified, \-delay will default to 1 second\fR
.Ip "-cookie, \-target, \-expires" 4
These have the same meaning as the like-named parameters in
\fI\s-1CGI::\s0header()\fR.
.SH "INSTALLING CGI::Push SCRIPTS"
Server push scripts \fBmust\fR be installed as no-parsed-header (NPH)
scripts in order to work correctly.  On Unix systems, this is most
often accomplished by prefixing the script's name with \*(L"nph-\*(R".  
Recognition of NPH scripts happens automatically with WebSTAR and 
Microsoft IIS.  Users of other servers should see their documentation
for help.
.SH "CAVEATS"
This is a new module.  It hasn't been extensively tested.
.SH "AUTHOR INFORMATION"
be used and modified freely, but I do request that this copyright
notice remain attached to the file.  You may modify this module as you
wish, but if you redistribute a modified version, please attach a note
listing the modifications you have made.
.PP
Address bug reports and comments to:
lstein@genome.wi.mit.edu
.SH "BUGS"
This section intentionally left blank.
.SH "SEE ALSO"
the \fICGI::Carp\fR manpage, the \fICGI\fR manpage

.rn }` ''
.IX Title "CGI::Push 3"
.IX Name "CGI::Push - Simple Interface to Server Push"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "USING CGI::Push"

.IX Item "-next_page"

.IX Item "-last_page"

.IX Item "-type"

.IX Item "-delay"

.IX Item "-cookie, \-target, \-expires"

.IX Header "INSTALLING CGI::Push SCRIPTS"

.IX Header "CAVEATS"

.IX Header "AUTHOR INFORMATION"

.IX Header "BUGS"

.IX Header "SEE ALSO"

