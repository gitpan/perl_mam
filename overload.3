.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH overload 3 "perl 5.003, patch 93" "19/Feb/97" "Perl Programmers Reference Guide"
.IX Title "overload 3"
.UC
.IX Name "overload - Package for overloading perl operations"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
overload \- Package for overloading perl operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 1
\&    package SomeThing;
.Ve
.Vb 5
\&    use overload 
\&        '+' => \e&myadd,
\&        '-' => \e&mysub;
\&        # etc
\&    ...
.Ve
.Vb 7
\&    package main;
\&    $a = new SomeThing 57;
\&    $b=5+$a;
\&    ...
\&    if (overload::Overloaded $b) {...}
\&    ...
\&    $strval = overload::StrVal $b;
.Ve
.SH "CAVEAT SCRIPTOR"
.IX Header "CAVEAT SCRIPTOR"
Overloading of operators is a subject not to be taken lightly.
Neither its precise implementation, syntax, nor semantics are
100% endorsed by Larry Wall.  So any of these may be changed 
at some point in the future.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Declaration of overloaded functions"
.IX Subsection "Declaration of overloaded functions"
The compilation directive
.PP
.Vb 4
\&    package Number;
\&    use overload
\&        "+" => \e&add, 
\&        "*=" => "muas";
.Ve
declares function \fINumber::add()\fR for addition, and method \fImuas()\fR in
the \*(L"class\*(R" \f(CWNumber\fR (or one of its base classes)
for the assignment form \f(CW*=\fR of multiplication.  
.PP
Arguments of this directive come in (key, value) pairs.  Legal values
are values legal inside a \f(CW&{ ... }\fR call, so the name of a
subroutine, a reference to a subroutine, or an anonymous subroutine
will all work.  Note that values specified as strings are
interpreted as methods, not subroutines.  Legal keys are listed below.
.PP
The subroutine \f(CWadd\fR will be called to execute \f(CW$a+$b\fR if \f(CW$a\fR
is a reference to an object blessed into the package \f(CWNumber\fR, or if \f(CW$a\fR is
not an object from a package with defined mathemagic addition, but \f(CW$b\fR is a
reference to a \f(CWNumber\fR.  It can also be called in other situations, like
\f(CW$a+=7\fR, or \f(CW$a++\fR.  See the section on \fI\s-1MAGIC\s0 \s-1AUTOGENERATION\s0\fR.  (Mathemagical
methods refer to methods triggered by an overloaded mathematical
operator.)
.PP
Since overloading respects inheritance via the \f(CW@ISA\fR hierarchy, the
above declaration would also trigger overloading of \f(CW+\fR and \f(CW*=\fR in
all the packages which inherit from \f(CWNumber\fR.
.Sh "Calling Conventions for Binary Operations"
.IX Subsection "Calling Conventions for Binary Operations"
The functions specified in the \f(CWuse overload ...\fR directive are called
with three (in one particular case with four, see the section on \fILast Resort\fR)
arguments.  If the corresponding operation is binary, then the first
two arguments are the two arguments of the operation.  However, due to
general object calling conventions, the first argument should always be
an object in the package, so in the situation of \f(CW7+$a\fR, the
order of the arguments is interchanged.  It probably does not matter
when implementing the addition method, but whether the arguments
are reversed is vital to the subtraction method.  The method can
query this information by examining the third argument, which can take
three different values:
.Ip "\s-1FALSE\s0" 7
.IX Item "\s-1FALSE\s0"
the order of arguments is as in the current operation.
.Ip "\s-1TRUE\s0" 7
.IX Item "\s-1TRUE\s0"
the arguments are reversed.
.Ip "\f(CWundef\fR" 7
.IX Item "\f(CWundef\fR"
the current operation is an assignment variant (as in
\f(CW$a+=7\fR), but the usual function is called instead.  This additional
information can be used to generate some optimizations.
.Sh "Calling Conventions for Unary Operations"
.IX Subsection "Calling Conventions for Unary Operations"
Unary operation are considered binary operations with the second
argument being \f(CWundef\fR.  Thus the functions that overloads \f(CW{"++"}\fR
is called with arguments \f(CW($a,undef,'')\fR when \f(CW$a\fR++ is executed.
.Sh "Overloadable Operations"
.IX Subsection "Overloadable Operations"
The following symbols can be specified in \f(CWuse overload\fR:
.Ip "\(bu \fIArithmetic operations\fR" 5
.IX Item "\(bu \fIArithmetic operations\fR"
.Sp
.Vb 2
\&    "+", "+=", "-", "-=", "*", "*=", "/", "/=", "%", "%=",
\&    "**", "**=", "<<", "<<=", ">>", ">>=", "x", "x=", ".", ".=",
.Ve
For these operations a substituted non-assignment variant can be called if
the assignment variant is not available.  Methods for operations \*(L"\f(CW+\fR\*(R",
\*(L"\f(CW-\fR\*(R", \*(L"\f(CW+=\fR\*(R", and \*(L"\f(CW-=\fR\*(R" can be called to automatically generate
increment and decrement methods.  The operation \*(L"\f(CW-\fR\*(R" can be used to
autogenerate missing methods for unary minus or \f(CWabs\fR.
.Ip "\(bu \fIComparison operations\fR" 5
.IX Item "\(bu \fIComparison operations\fR"
.Sp
.Vb 2
\&    "<",  "<=", ">",  ">=", "==", "!=", "<=>",
\&    "lt", "le", "gt", "ge", "eq", "ne", "cmp",
.Ve
If the corresponding \*(L"spaceship\*(R" variant is available, it can be
used to substitute for the missing operation.  During \f(CWsort\fRing
arrays, \f(CWcmp\fR is used to compare values subject to \f(CWuse overload\fR.
.Ip "\(bu \fIBit operations\fR" 5
.IX Item "\(bu \fIBit operations\fR"
.Sp
.Vb 1
\&    "&", "^", "|", "neg", "!", "~",
.Ve
\*(L"\f(CWneg\fR\*(R" stands for unary minus.  If the method for \f(CWneg\fR is not
specified, it can be autogenerated using the method for
subtraction. If the method for \*(L"\f(CW!\fR\*(R" is not specified, it can be
autogenerated using the methods for \*(L"\f(CWbool\fR\*(R", or \*(L"\f(CW\e"\e"\fR\*(R", or \*(L"\f(CW0+\fR\*(R".
.Ip "\(bu \fIIncrement and decrement\fR" 5
.IX Item "\(bu \fIIncrement and decrement\fR"
.Sp
.Vb 1
\&    "++", "--",
.Ve
If undefined, addition and subtraction methods can be
used instead.  These operations are called both in prefix and
postfix form.
.Ip "\(bu \fITranscendental functions\fR" 5
.IX Item "\(bu \fITranscendental functions\fR"
.Sp
.Vb 1
\&    "atan2", "cos", "sin", "exp", "abs", "log", "sqrt",
.Ve
If \f(CWabs\fR is unavailable, it can be autogenerated using methods
for \*(L"<\*(R" or \*(L"<=>\*(R" combined with either unary minus or subtraction.
.Ip "\(bu \fIBoolean, string and numeric conversion\fR" 5
.IX Item "\(bu \fIBoolean, string and numeric conversion\fR"
.Sp
.Vb 1
\&    "bool", "\e"\e"", "0+",
.Ve
If one or two of these operations are unavailable, the remaining ones can
be used instead.  \f(CWbool\fR is used in the flow control operators
(like \f(CWwhile\fR) and for the ternary \*(L"\f(CW?:\fR\*(R" operation.  These functions can
return any arbitrary Perl value.  If the corresponding operation for this value
is overloaded too, that operation will be called again with this value.
.Ip "\(bu \fISpecial\fR" 5
.IX Item "\(bu \fISpecial\fR"
.Sp
.Vb 1
\&    "nomethod", "fallback", "=",
.Ve
see the section on \fI\s-1SPECIAL\s0 \s-1SYMBOLS\s0 \s-1FOR\s0 \f(CWuse overload\fR\fR.
.PP
See the section on \fIFallback\fR for an explanation of when a missing method can be autogenerated.
.Sh "Inheritance and overloading"
.IX Subsection "Inheritance and overloading"
Inheritance interacts with overloading in two ways.
.Ip "Strings as values of \f(CWuse overload\fR directive" 5
.IX Item "Strings as values of \f(CWuse overload\fR directive"
If \f(CWvalue\fR in
.Sp
.Vb 1
\&  use overload key => value;
.Ve
is a string, it is interpreted as a method name.
.Ip "Overloading of an operation is inherited by derived classes" 5
.IX Item "Overloading of an operation is inherited by derived classes"
Any class derived from an overloaded class is also overloaded.  The
set of overloaded methods is the union of overloaded methods of all
the ancestors. If some method is overloaded in several ancestor, then
which description will be used is decided by the usual inheritance
rules:
.Sp
If \f(CWA\fR inherits from \f(CWB\fR and \f(CWC\fR (in this order), \f(CWB\fR overloads
\f(CW+\fR with \f(CW\e&D::plus_sub\fR, and \f(CWC\fR overloads \f(CW+\fR by \f(CW"plus_meth"\fR,
then the subroutine \f(CWD::plus_sub\fR will be called to implement
operation \f(CW+\fR for an object in package \f(CWA\fR.
.PP
Note that since the value of the \f(CWfallback\fR key is not a subroutine,
its inheritance is not governed by the above rules.  In the current
implementation, the value of \f(CWfallback\fR in the first overloaded
ancestor is used, but this is accidental and subject to change.
.SH "SPECIAL SYMBOLS FOR \f(CWuse overload\fR"
.IX Header "SPECIAL SYMBOLS FOR \f(CWuse overload\fR"
Three keys are recognized by Perl that are not covered by the above
description.
.Sh "Last Resort"
.IX Subsection "Last Resort"
\f(CW"nomethod"\fR should be followed by a reference to a function of four
parameters.  If defined, it is called when the overloading mechanism
cannot find a method for some operation.  The first three arguments of
this function coincide with the arguments for the corresponding method if
it were found, the fourth argument is the symbol
corresponding to the missing method.  If several methods are tried,
the last one is used.  Say, \f(CW1-$a\fR can be equivalent to
.PP
.Vb 1
\&        &nomethodMethod($a,1,1,"-")
.Ve
if the pair \f(CW"nomethod" => "nomethodMethod"\fR was specified in the
\f(CWuse overload\fR directive.
.PP
If some operation cannot be resolved, and there is no function
assigned to \f(CW"nomethod"\fR, then an exception will be raised via \fIdie()\fR--
unless \f(CW"fallback"\fR was specified as a key in \f(CWuse overload\fR directive.
.Sh "Fallback "
.IX Subsection "Fallback "
The key \f(CW"fallback"\fR governs what to do if a method for a particular
operation is not found.  Three different cases are possible depending on
the value of \f(CW"fallback"\fR:
.Ip "\(bu \f(CWundef\fR" 16
.IX Item "\(bu \f(CWundef\fR"
Perl tries to use a
substituted method (see the section on \fI\s-1MAGIC\s0 \s-1AUTOGENERATION\s0\fR).  If this fails, it
then tries to calls \f(CW"nomethod"\fR value; if missing, an exception
will be raised.
.Ip "\(bu \s-1TRUE\s0" 16
.IX Item "\(bu \s-1TRUE\s0"
The same as for the \f(CWundef\fR value, but no exception is raised.  Instead,
it silently reverts to what it would have done were there no \f(CWuse overload\fR
present.
.Ip "\(bu defined, but \s-1FALSE\s0" 16
.IX Item "\(bu defined, but \s-1FALSE\s0"
No autogeneration is tried.  Perl tries to call
\f(CW"nomethod"\fR value, and if this is missing, raises an exception. 
.PP
\fBNote.\fR \f(CW"fallback"\fR inheritance via \f(CW@ISA\fR is not carved in stone
yet, see the section on \fIInheritance and overloading\fR.
.Sh "Copy Constructor"
.IX Subsection "Copy Constructor"
The value for \f(CW"="\fR is a reference to a function with three
arguments, i.e., it looks like the other values in \f(CWuse
overload\fR. However, it does not overload the Perl assignment
operator. This would go against Camel hair.
.PP
This operation is called in the situations when a mutator is applied
to a reference that shares its object with some other reference, such
as
.PP
.Vb 2
\&        $a=$b; 
\&        $a++;
.Ve
To make this change \f(CW$a\fR and not change \f(CW$b\fR, a copy of \f(CW$$a\fR is made,
and \f(CW$a\fR is assigned a reference to this new object.  This operation is
done during execution of the \f(CW$a++\fR, and not during the assignment,
(so before the increment \f(CW$$a\fR coincides with \f(CW$$b\fR).  This is only
done if \f(CW++\fR is expressed via a method for \f(CW'++'\fR or \f(CW'+='\fR.  Note
that if this operation is expressed via \f(CW'+'\fR a nonmutator, i.e., as
in
.PP
.Vb 2
\&        $a=$b; 
\&        $a=$a+1;
.Ve
then \f(CW$a\fR does not reference a new copy of \f(CW$$a\fR, since $$a does not
appear as lvalue when the above code is executed.
.PP
If the copy constructor is required during the execution of some mutator,
but a method for \f(CW'='\fR was not specified, it can be autogenerated as a
string copy if the object is a plain scalar.
.Ip "\fBExample\fR" 5
.IX Item "\fBExample\fR"
The actually executed code for 
.Sp
.Vb 3
\&        $a=$b; 
\&        Something else which does not modify $a or $b....
\&        ++$a;
.Ve
may be
.Sp
.Vb 4
\&        $a=$b; 
\&        Something else which does not modify $a or $b....
\&        $a = $a->clone(undef,"");
\&        $a->incr(undef,"");
.Ve
if \f(CW$b\fR was mathemagical, and \f(CW'++'\fR was overloaded with \f(CW\e&incr\fR,
\f(CW'='\fR was overloaded with \f(CW\e&clone\fR.
.SH "MAGIC AUTOGENERATION"
.IX Header "MAGIC AUTOGENERATION"
If a method for an operation is not found, and the value for  \f(CW"fallback"\fR is
TRUE or undefined, Perl tries to autogenerate a substitute method for
the missing operation based on the defined operations.  Autogenerated method
substitutions are possible for the following operations:
.Ip "\fIAssignment forms of arithmetic operations\fR" 16
.IX Item "\fIAssignment forms of arithmetic operations\fR"
\f(CW$a+=$b\fR can use the method for \f(CW"+"\fR if the method for \f(CW"+="\fR
is not defined.
.Ip "\fIConversion operations\fR " 16
.IX Item "\fIConversion operations\fR "
String, numeric, and boolean conversion are calculated in terms of one
another if not all of them are defined.
.Ip "\fIIncrement and decrement\fR" 16
.IX Item "\fIIncrement and decrement\fR"
The \f(CW++$a\fR operation can be expressed in terms of \f(CW$a+=1\fR or \f(CW$a+1\fR,
and \f(CW$a--\fR in terms of \f(CW$a-=1\fR and \f(CW$a-1\fR.
.Ip "\f(CWabs($a)\fR" 16
.IX Item "\f(CWabs($a)\fR"
can be expressed in terms of \f(CW$a<0\fR and \f(CW-$a\fR (or \f(CW0-$a\fR).
.Ip "\fIUnary minus\fR" 16
.IX Item "\fIUnary minus\fR"
can be expressed in terms of subtraction.
.Ip "\fINegation\fR" 16
.IX Item "\fINegation\fR"
\f(CW!\fR and \f(CWnot\fR can be expressed in terms of boolean conversion, or
string or numerical conversion.
.Ip "\fIConcatenation\fR" 16
.IX Item "\fIConcatenation\fR"
can be expressed in terms of string conversion.
.Ip "\fIComparison operations\fR " 16
.IX Item "\fIComparison operations\fR "
can be expressed in terms of its \*(L"spaceship\*(R" counterpart: either
\f(CW<=>\fR or \f(CWcmp\fR:
.Sp
.Vb 2
\&    <, >, <=, >=, ==, !=        in terms of <=>
\&    lt, gt, le, ge, eq, ne      in terms of cmp
.Ve
.Ip "\fICopy operator\fR" 16
.IX Item "\fICopy operator\fR"
can be expressed in terms of an assignment to the dereferenced value, if this
value is a scalar and not a reference.
.SH "WARNING"
.IX Header "WARNING"
The restriction for the comparison operation is that even if, for example,
`\f(CWcmp\fR\*(R' should return a blessed reference, the autogenerated `\f(CWlt\fR\*(R'
function will produce only a standard logical value based on the
numerical value of the result of `\f(CWcmp\fR\*(R'.  In particular, a working
numeric conversion is needed in this case (possibly expressed in terms of
other conversions).
.PP
Similarly, \f(CW.=\fR  and \f(CWx=\fR operators lose their mathemagical properties
if the string conversion substitution is applied.
.PP
When you \fIchop()\fR a mathemagical object it is promoted to a string and its
mathemagical properties are lost.  The same can happen with other
operations as well.
.SH "Run-time Overloading"
.IX Header "Run-time Overloading"
Since all \f(CWuse\fR directives are executed at compile-time, the only way to
change overloading during run-time is to
.PP
.Vb 1
\&    eval 'use overload "+" => \e&addmethod';
.Ve
You can also use
.PP
.Vb 1
\&    eval 'no overload "+", "--", "<="';
.Ve
though the use of these constructs during run-time is questionable.
.SH "Public functions"
.IX Header "Public functions"
Package \f(CWoverload.pm\fR provides the following public functions:
.Ip "overload::StrVal(arg)" 5
.IX Item "overload::StrVal(arg)"
Gives string value of \f(CWarg\fR as in absence of stringify overloading.
.Ip "overload::Overloaded(arg)" 5
.IX Item "overload::Overloaded(arg)"
Returns true if \f(CWarg\fR is subject to overloading of some operations.
.Ip "overload::Method(obj,op)" 5
.IX Item "overload::Method(obj,op)"
Returns \f(CWundef\fR or a reference to the method that implements \f(CWop\fR.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
What follows is subject to change RSN.
.PP
The table of methods for all operations is cached in magic for the
symbol table hash for the package.  The cache is invalidated during
processing of \f(CWuse overload\fR, \f(CWno overload\fR, new function
definitions, and changes in \f(CW@ISA\fR. However, this invalidation remains
unprocessed until the next \f(CWbless\fRing into the package. Hence if you
want to change overloading structure dynamically, you'll need an
additional (fake) \f(CWbless\fRing to update the table.
.PP
(Every SVish thing has a magic queue, and magic is an entry in that
queue.  This is how a single variable may participate in multiple
forms of magic simultaneously.  For instance, environment variables
regularly have two forms at once: their \f(CW%ENV\fR magic and their taint
magic. However, the magic which implements overloading is applied to
the stashes, which are rarely used directly, thus should not slow down
Perl.)
.PP
If an object belongs to a package using overload, it carries a special
flag.  Thus the only speed penalty during arithmetic operations without
overloading is the checking of this flag.
.PP
In fact, if \f(CWuse overload\fR is not present, there is almost no overhead
for overloadable operations, so most programs should not suffer
measurable performance penalties.  A considerable effort was made to
minimize the overhead when overload is used in some package, but the
arguments in question do not belong to packages using overload.  When
in doubt, test your speed with \f(CWuse overload\fR and without it.  So far
there have been no reports of substantial speed degradation if Perl is
compiled with optimization turned on.
.PP
There is no size penalty for data if overload is not used. The only
size penalty if overload is used in some package is that \fIall\fR the
packages acquire a magic during the next \f(CWbless\fRing into the
package. This magic is three-words-long for packages without
overloading, and carries the cache tabel if the package is overloaded.
.PP
Copying (\f(CW$a=$b\fR) is shallow; however, a one-level-deep copying is 
carried out before any operation that can imply an assignment to the
object \f(CW$a\fR (or \f(CW$b\fR) refers to, like \f(CW$a++\fR.  You can override this
behavior by defining your own copy constructor (see the section on \fICopy Constructor\fR).
.PP
It is expected that arguments to methods that are not explicitly supposed
to be changed are constant (but this is not enforced).
.SH "AUTHOR"
.IX Header "AUTHOR"
Ilya Zakharevich <\fIilya@math.mps.ohio-state.edu\fR>.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
When Perl is run with the \fB\-Do\fR switch or its equivalent, overloading
induces diagnostic messages.
.PP
Using the \f(CWm\fR command of Perl debugger (see the \fIperldebug\fR manpage) one can
deduce which operations are overloaded (and which ancestor triggers
this overloading). Say, if \f(CWeq\fR is overloaded, then the method \f(CW(eq\fR
is shown by debugger. The method \f(CW()\fR corresponds to the \f(CWfallback\fR
key (in fact a presence of this method shows that this package has
overloading enabled, and it is what is used by the \f(CWOverloaded\fR
function).
.SH "BUGS"
.IX Header "BUGS"
Because it is used for overloading, the per-package hash \f(CW%OVERLOAD\fR now
has a special meaning in Perl. The symbol table is filled with names
looking like line-noise.
.PP
For the purpose of inheritance every overloaded package behaves as if
\f(CWfallback\fR is present (possibly undefined). This may create
interesting effects if some package is not overloaded, but inherits
from two overloaded packages.
.PP
This document is confusing.

.rn }` ''
