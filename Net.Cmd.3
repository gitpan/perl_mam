.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Net::Cmd 3 "perl 5.004, patch 55" "17/Nov/97" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Net::Cmd \- Network Command class (as used by FTP, SMTP etc)
.SH "SYNOPSIS"
.PP
.Vb 3
\&    use Net::Cmd;
\&    
\&    @ISA = qw(Net::Cmd);
.Ve
.SH "DESCRIPTION"
\f(CWNet::Cmd\fR is a collection of methods that can be inherited by a sub class
of \f(CWIO::Handle\fR. These methods implement the functionality required for a
command based protocol, for example FTP and SMTP.
.SH "USER METHODS"
These methods provide a user interface to the \f(CWNet::Cmd\fR object.
.Ip "debug ( \s-1VALUE\s0 )" 4
Set the level of debug information for this object. If \f(CWVALUE\fR is not given
then the current state is returned. Otherwise the state is changed to 
\f(CWVALUE\fR and the previous state returned. 
.Sp
Set the level of debug information for this object. If no argument is
given then the current state is returned. Otherwise the state is
changed to \f(CW$value\fRand the previous state returned.  Different packages
may implement different levels of debug but, a  non-zero value result in
copies of all commands and responses also being sent to \s-1STDERR\s0.
.Sp
If \f(CWVALUE\fR is \f(CWundef\fR then the debug level will be set to the default
debug level for the class.
.Sp
This method can also be called as a \fIstatic\fR method to set/get the default
debug level for a given class.
.Ip "message ()" 4
Returns the text message returned from the last command
.Ip "code ()" 4
Returns the 3-digit code from the last command. If a command is pending
then the value 0 is returned
.Ip "ok ()" 4
Returns non-zero if the last code value was greater than zero and
less than 400. This holds true for most command servers. Servers
where this does not hold may override this method.
.Ip "status ()" 4
Returns the most significant digit of the current status code. If a command
is pending then \f(CWCMD_PENDING\fR is returned.
.Ip "datasend ( \s-1DATA\s0 )" 4
Send data to the remote server, converting \s-1LF\s0 to \s-1CRLF\s0. Any line starting
with a \*(L'.\*(R' will be prefixed with another \*(L'.\*(R'.
\f(CWDATA\fR may be an array or a reference to an array.
.Ip "dataend ()" 4
End the sending of data to the remote server. This is done by ensuring that
the data already sent ends with \s-1CRLF\s0 then sending \*(L'.\s-1CRLF\s0\*(R' to end the
transmission. Once this data has been sent \f(CWdataend\fR calls \f(CWresponse\fR and
returns true if \f(CWresponse\fR returns \s-1CMD_OK\s0.
.SH "CLASS METHODS"
These methods are not intended to be called by the user, but used or 
over-ridden by a sub-class of \f(CWNet::Cmd\fR
.Ip "debug_print ( \s-1DIR\s0, \s-1TEXT\s0 )" 4
Print debugging information. \f(CWDIR\fR denotes the direction \fItrue\fR being
data being sent to the server. Calls \f(CWdebug_text\fR before printing to
\s-1STDERR\s0.
.Ip "debug_text ( \s-1TEXT\s0 )" 4
This method is called to print debugging information. \s-1TEXT\s0 is
the text being sent. The method should return the text to be printed
.Sp
This is primarily meant for the use of modules such as \s-1FTP\s0 where passwords
are sent, but we do not want to display them in the debugging information.
.Ip "command ( \s-1CMD\s0 [, \s-1ARGS\s0, ... ])" 4
Send a command to the command server. All arguments a first joined with
a space character and \s-1CRLF\s0 is appended, this string is then sent to the
command server.
.Sp
Returns undef upon failure
.Ip "unsupported ()" 4
Sets the status code to 580 and the response text to \*(L'Unsupported command\*(R'.
Returns zero.
.Ip "response ()" 4
Obtain a response from the server. Upon success the most significant digit
of the status code is returned. Upon failure, timeout etc., \fIundef\fR is
returned.
.Ip "parse_response ( \s-1TEXT\s0 )" 4
This method is called by \f(CWresponse\fR as a method with one argument. It should
return an array of 2 values, the 3-digit status code and a flag which is true
when this is part of a multi-line response and this line is not the list.
.Ip "getline ()" 4
Retrieve one line, delimited by \s-1CRLF\s0, from the remote server. Returns \fIundef\fR
upon failure.
.Sp
\fB\s-1NOTE\s0\fR: If you do use this method for any reason, please remember to add
some \f(CWdebug_print\fR calls into your method.
.Ip "ungetline ( \s-1TEXT\s0 )" 4
Unget a line of text from the server.
.Ip "read_until_dot ()" 4
Read data from the remote server until a line consisting of a single \*(L'.\*(R'.
Any lines starting with \*(L'..\*(R' will have one of the \*(L'.'s removed.
.Sp
Returns a reference to a list containing the lines, or \fIundef\fR upon failure.
.SH "EXPORTS"
\f(CWNet::Cmd\fR exports six subroutines, five of these, \f(CWCMD_INFO\fR, \f(CWCMD_OK\fR,
\f(CWCMD_MORE\fR, \f(CWCMD_REJECT\fR and \f(CWCMD_ERROR\fR ,correspond to possible results
of \f(CWresponse\fR and \f(CWstatus\fR. The sixth is \f(CWCMD_PENDING\fR.
.SH "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "COPYRIGHT"
Copyright (c) 1995-1997 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

.rn }` ''
.IX Title "Net::Cmd 3"
.IX Name "Net::Cmd - Network Command class (as used by FTP, SMTP etc)"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "USER METHODS"

.IX Item "debug ( \s-1VALUE\s0 )"

.IX Item "message ()"

.IX Item "code ()"

.IX Item "ok ()"

.IX Item "status ()"

.IX Item "datasend ( \s-1DATA\s0 )"

.IX Item "dataend ()"

.IX Header "CLASS METHODS"

.IX Item "debug_print ( \s-1DIR\s0, \s-1TEXT\s0 )"

.IX Item "debug_text ( \s-1TEXT\s0 )"

.IX Item "command ( \s-1CMD\s0 [, \s-1ARGS\s0, ... ])"

.IX Item "unsupported ()"

.IX Item "response ()"

.IX Item "parse_response ( \s-1TEXT\s0 )"

.IX Item "getline ()"

.IX Item "ungetline ( \s-1TEXT\s0 )"

.IX Item "read_until_dot ()"

.IX Header "EXPORTS"

.IX Header "AUTHOR"

.IX Header "COPYRIGHT"

