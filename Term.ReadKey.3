.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH ReadKey 3 "perl 5.005, patch 53" "7/Jan/98" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Term::ReadKey \- A perl module for simple terminal control
.SH "SYNOPSIS"
.PP
.Vb 7
\&        use Term::ReadKey;
\&        ReadMode 4; # Turn off controls keys
\&        while (not defined ($key = ReadKey(-1)) {
\&                # No key yet
\&        }
\&        print "Get key $key\en";
\&        ReadMode 0; # Reset tty mode before exiting
.Ve
.SH "DESCRIPTION"
Term::ReadKey is a compiled perl module dedicated to providing simple
control over terminal driver modes (cbreak, raw, cooked, etc.,) support for
non-blocking reads, if the architecture allows, and some generalized handy
functions for working with terminals. One of the main goals is to have the
functions as portable as possible, so you can just plug in \*(L"use
Term::ReadKey\*(R" on any architecture and have a good likelyhood of it working.
.Ip "ReadMode \s-1MODE\s0 [, Filehandle]" 8
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 17
\&    0    Restore original settings.
\&    1    Change to cooked mode.
\&    2    Change to cooked mode with echo off. 
\&          (Good for passwords)
\&    3    Change to cbreak mode.
\&    4    Change to raw mode.
\&    5    Change to ultra-raw mode. 
\&          (LF to CR/LF translation turned off) 
\&          
\&    Or, you may use the synonyms:
\&    
\&    restore
\&    normal
\&    noecho
\&    cbreak
\&    raw
\&    ultra-raw
.Ve
These functions are automatically applied to the \s-1STDIN\s0 handle if no other
handle is supplied. Modes 0 and 5 have some special properties worth
mentioning: not only will mode 0 restore original settings, but it cause the
next ReadMode call to save a new set of default settings. Mode 5 is similar
to mode 4, except no \s-1CR/LF\s0 translation is performed, and if possible, parity
will be disabled (only if not being used by the terminal, however. It is no different
from mode 4 under Windows.)
.Sp
If you are executing another program that may be changing the terminal mode,
you will either want to say
.Sp
.Vb 5
\&    ReadMode 1
\&    system('someprogram');
\&    ReadMode 1;
\&    
\&which resets the settings after the program has run, or:
.Ve
.Vb 7
\&    $somemode=1;
\&    ReadMode 0;
\&    system('someprogram');
\&    ReadMode 1;
\&    
\&which records any changes the program may have made, before resetting the
\&mode.
.Ve
.Ip "ReadKey \s-1MODE\s0 [, Filehandle]" 8
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 3
\&    0    Perform a normal read using getc
\&    -1   Perform a non-blocked read
\&    >0   Perform a timed read
.Ve
(If the filehandle is not supplied, it will default to \s-1STDIN\s0.) If there is
nothing waiting in the buffer during a non-blocked read, then undef will be
returned. Note that if the \s-1OS\s0 does not provide any known mechanism for
non-blocking reads, then a \f(CWReadKey -1\fR can die with a fatal error. This
will hopefully not be common.
.Sp
If \s-1MODE\s0 is greater then zero, then ReadKey will use it as a timeout value in
seconds (fractional seconds are allowed), and won't return \f(CWundef\fR until
that time expires. (Note, again, that some \s-1OS\s0's may not support this timeout
behaviour.) If \s-1MODE\s0 is less then zero, then this is treated as a timeout
of zero, and thus will return immediately if no character is waiting. A \s-1MODE\s0
of zero, however, will act like a normal getc.
.Sp
There are currently some limitations with this call under Windows. It may be
possible that non-blocking reads will fail when reading repeating keys from
more then one console.
.Ip "ReadLine \s-1MODE\s0 [, Filehandle]" 8
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 3
\&    0    Perform a normal read using scalar(<FileHandle>)
\&    -1   Perform a non-blocked read
\&    >0   Perform a timed read
.Ve
If there is nothing waiting in the buffer during a non-blocked read, then
undef will be returned. Note that if the \s-1OS\s0 does not provide any known
mechanism for non-blocking reads, then a \f(CWReadLine 1\fR can die with a fatal
error. This will hopefully not be common. Note that a non-blocking test is
only performed for the first character in the line, not the entire line.
This call will probably \fBnot\fR do what you assume, especially with
ReadMode's higher then 1. For example, pressing Space and then Backspace
would appear to leave you where you started, but any timeouts would now
be suspended.
.Sp
This call is currently not available under Windows.
.Ip "GetTerminalSize [Filehandle]" 8
Returns either an empty array if this operation is unsupported, or a four
element array containing: the width of the terminal in characters, the
height of the terminal in character, the width in pixels, and the height in
pixels. (The pixel size will only be valid in some environments.)
.Sp
Under Windows, this function must be called with an \*(L"output\*(R" filehandle,
such as \s-1STDOUT\s0, or a handle opened to \s-1CONOUT\s0$.
.Ip "SetTerminalSize \s-1WIDTH\s0,\s-1HEIGHT\s0,\s-1XPIX\s0,\s-1YPIX\s0 [, Filehandle]" 8
Return \-1 on failure, 0 otherwise. Note that this terminal size is only for
\fBinformative\fR value, and changing the size via this mechanism will \fBnot\fR
change the size of the screen. For example, XTerm uses a call like this when
it resizes the screen. If any of the new measurements vary from the old, the
\s-1OS\s0 will probably send a \s-1SIGWINCH\s0 signal to anything reading that tty or pty.
.Sp
This call does not work under Windows.
.Ip "GetSpeeds [, Filehandle]" 8
Returns either an empty array if the operation is unsupported, or a two
value array containing the terminal in and out speeds, in \fBdecimal\fR. E.g,
an in speed of 9600 baud and an out speed of 4800 baud would be returned as
(9600,4800). Note that currently the in and out speeds will always be
identical in some \s-1OS\s0's. No speeds are reported under Windows.
.Ip "GetControlChars [, Filehandle]" 8
Returns an array containing key/value pairs suitable for a hash. The pairs
consist of a key, the name of the control character/signal, and the value
of that character, as a single character. This call does nothing under Windows.
.Sp
Each key will be an entry from the following list:
.Sp
.Vb 19
\&        DISCARD
\&        DSUSPEND
\&        EOF
\&        EOL
\&        EOL2
\&        ERASE
\&        ERASEWORD
\&        INTERRUPT
\&        KILL
\&        MIN
\&        QUIT
\&        QUOTENEXT
\&        REPRINT
\&        START
\&        STATUS
\&        STOP
\&        SUSPEND
\&        SWITCH
\&        TIME
.Ve
Thus, the following will always return the current interrupt character,
regardless of platform.
.Sp
.Vb 2
\&        %keys = GetControlChars;
\&        $int = $keys{INTERRUPT};
.Ve
.Ip "SetControlChars [, Filehandle]" 8
Takes an array containing key/value pairs, as a hash will produce. The pairs
should consist of a key that is the name of a legal control
character/signal, and the value should be either a single character, or a
number in the range 0-255. SetControlChars will die with a runtime error if
an invalid character name is passed or there is an error changing the
settings. The list of valid names is easily available via
.Sp
.Vb 2
\&        %cchars = GetControlChars();
\&        @cnames = keys %cchars;
.Ve
This call does nothing under Windows.
.SH "AUTHOR"
Kenneth Albanowski <kjahds@kjahds.com>

.rn }` ''
.IX Title "ReadKey 3"
.IX Name "Term::ReadKey - A perl module for simple terminal control"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "ReadMode \s-1MODE\s0 [, Filehandle]"

.IX Item "ReadKey \s-1MODE\s0 [, Filehandle]"

.IX Item "ReadLine \s-1MODE\s0 [, Filehandle]"

.IX Item "GetTerminalSize [Filehandle]"

.IX Item "SetTerminalSize \s-1WIDTH\s0,\s-1HEIGHT\s0,\s-1XPIX\s0,\s-1YPIX\s0 [, Filehandle]"

.IX Item "GetSpeeds [, Filehandle]"

.IX Item "GetControlChars [, Filehandle]"

.IX Item "SetControlChars [, Filehandle]"

.IX Header "AUTHOR"

