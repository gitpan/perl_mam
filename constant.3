.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH constant 3 "perl 5.005, patch 53" "5/Nov/98" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
constant \- Perl pragma to declare constants
.SH "SYNOPSIS"
.PP
.Vb 7
\&    use constant BUFFER_SIZE    => 4096;
\&    use constant ONE_YEAR       => 365.2425 * 24 * 60 * 60;
\&    use constant PI             => 4 * atan2 1, 1;
\&    use constant DEBUGGING      => 0;
\&    use constant ORACLE         => 'oracle@cs.indiana.edu';
\&    use constant USERNAME       => scalar getpwuid($<);
\&    use constant USERINFO       => getpwuid($<);
.Ve
.Vb 1
\&    sub deg2rad { PI * $_[0] / 180 }
.Ve
.Vb 1
\&    print "This line does nothing"              unless DEBUGGING;
.Ve
.Vb 5
\&    # references can be declared constant
\&    use constant CHASH          => { foo => 42 };
\&    use constant CARRAY         => [ 1,2,3,4 ];
\&    use constant CPSEUDOHASH    => [ { foo => 1}, 42 ];
\&    use constant CCODE          => sub { "bite $_[0]\en" };
.Ve
.Vb 5
\&    print CHASH->{foo};
\&    print CARRAY->[$i];
\&    print CPSEUDOHASH->{foo};
\&    print CCODE->("me");
\&    print CHASH->[10];                          # compile-time error
.Ve
.SH "DESCRIPTION"
This will declare a symbol to be a constant with the given scalar
or list value.
.PP
When you declare a constant such as \f(CWPI\fR using the method shown
above, each machine your script runs upon can have as many digits
of accuracy as it can use. Also, your program will be easier to
read, more likely to be maintained (and maintained correctly), and
far less likely to send a space probe to the wrong planet because
nobody noticed the one equation in which you wrote \f(CW3.14195\fR.
.SH "NOTES"
The value or values are evaluated in a list context. You may override
this with \f(CWscalar\fR as shown above.
.PP
These constants do not directly interpolate into double-quotish
strings, although you may do so indirectly. (See the \fIperlref\fR manpage for
details about how this works.)
.PP
.Vb 1
\&    print "The value of PI is @{[ PI ]}.\en";
.Ve
List constants are returned as lists, not as arrays.
.PP
.Vb 2
\&    $homedir = USERINFO[7];             # WRONG
\&    $homedir = (USERINFO)[7];           # Right
.Ve
The use of all caps for constant names is merely a convention,
although it is recommended in order to make constants stand out
and to help avoid collisions with other barewords, keywords, and
subroutine names. Constant names must begin with a letter.
.PP
Constant symbols are package scoped (rather than block scoped, as
\f(CWuse strict\fR is). That is, you can refer to a constant from package
Other as \f(CWOther::CONST\fR.
.PP
As with all \f(CWuse\fR directives, defining a constant happens at
compile time. Thus, it's probably not correct to put a constant
declaration inside of a conditional statement (like \f(CWif ($foo)
{ use constant ... }\fR).
.PP
Omitting the value for a symbol gives it the value of \f(CWundef\fR in
a scalar context or the empty list, \f(CW()\fR, in a list context. This
isn't so nice as it may sound, though, because in this case you
must either quote the symbol name, or use a big arrow, (\f(CW=>\fR),
with nothing to point to. It is probably best to declare these
explicitly.
.PP
.Vb 2
\&    use constant UNICORNS       => ();
\&    use constant LOGFILE        => undef;
.Ve
The result from evaluating a list constant in a scalar context is
not documented, and is \fBnot\fR guaranteed to be any particular value
in the future. In particular, you should not rely upon it being
the number of elements in the list, especially since it is not
\fBnecessarily\fR that value in the current implementation.
.PP
Magical values, tied values, and references can be made into
constants at compile time, allowing for way cool stuff like this.
(These error numbers aren't totally portable, alas.)
.PP
.Vb 3
\&    use constant E2BIG => ($! = 7);
\&    print   E2BIG, "\en";        # something like "Arg list too long"
\&    print 0+E2BIG, "\en";        # "7"
.Ve
Errors in dereferencing constant references are trapped at compile-time.
.SH "TECHNICAL NOTE"
In the current implementation, scalar constants are actually
inlinable subroutines. As of version 5.004 of Perl, the appropriate
scalar constant is inserted directly in place of some subroutine
calls, thereby saving the overhead of a subroutine call. See
the section on \fIConstant Functions\fR in the \fIperlsub\fR manpage for details about how and when this
happens.
.SH "BUGS"
In the current version of Perl, list constants are not inlined
and some symbols may be redefined without generating a warning.
.PP
It is not possible to have a subroutine or keyword with the same
name as a constant. This is probably a Good Thing.
.PP
Unlike constants in some languages, these cannot be overridden
on the command line or via environment variables.
.PP
You can get into trouble if you use constants in a context which
automatically quotes barewords (as is true for any subroutine call).
For example, you can't say \f(CW$hash{CONSTANT}\fR because \f(CWCONSTANT\fR will
be interpreted as a string.  Use \f(CW$hash{CONSTANT()}\fR or
\f(CW$hash{+CONSTANT}\fR to prevent the bareword quoting mechanism from
kicking in.  Similarly, since the \f(CW=>\fR operator quotes a bareword
immediately to its left you have to say \f(CWCONSTANT() => 'value'\fR
instead of \f(CWCONSTANT => 'value'\fR.
.SH "AUTHOR"
Tom Phoenix, <\fIrootbeer@teleport.com\fR>, with help from
many other folks.
.SH "COPYRIGHT"
Copyright (C) 1997, Tom Phoenix
.PP
This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.

.rn }` ''
.IX Title "constant 3"
.IX Name "constant - Perl pragma to declare constants"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "NOTES"

.IX Header "TECHNICAL NOTE"

.IX Header "BUGS"

.IX Header "AUTHOR"

.IX Header "COPYRIGHT"

