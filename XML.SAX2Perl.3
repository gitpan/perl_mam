.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::XML::SAX2Perl 3 "perl 5.007, patch 00" "22/Feb/100" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
XML::SAX2Perl -- translate Java/CORBA style SAX methods to Perl methods
.SH "SYNOPSIS"
.PP
.Vb 1
\& use XML::SAX2Perl;
.Ve
.Vb 2
\& $sax2perl = XML::SAX2Perl(Handler => $my_handler);
\& $sax->setDocumentHandler($sax2perl);
.Ve
.SH "DESCRIPTION"
\f(CWXML::SAX2Perl\fR is a SAX filter that translates Java/CORBA style SAX
methods to Perl style method calls.  This man page summarizes the
specific options, handlers, and properties supported by
\f(CWXML::SAX2Perl\fR; please refer to the Perl SAX standard \f(CWXML::SAX\fR
for general usage information.
.SH "METHODS"
.Ip "new" 4
Creates a new parser object.  Default options for parsing, described
below, are passed as key-value pairs or as a single hash.  Options may
be changed directly in the parser object unless stated otherwise.
Options passed to `\f(CWparse()\fR\*(R' override the default options in the
parser object for the duration of the parse.
.Ip "parse" 4
Parses a document.  Options, described below, are passed as key-value
pairs or as a single hash.  Options passed to `\f(CWparse()\fR\*(R' override
default options in the parser object.
.Ip "location" 4
Returns the location as a hash:
.Sp
.Vb 6
\&  ColumnNumber    The column number of the parse.
\&  LineNumber      The line number of the parse.
\&  PublicId        A string containing the public identifier, or undef
\&                  if none is available.
\&  SystemId        A string containing the system identifier, or undef
\&                  if none is available.
.Ve
.Ip "\s-1SAX\s0 DocumentHandler Methods" 4
The following methods are DocumentHandler methods that the \s-1SAX\s0 1.0
parser will call and \f(CWXML::SAX2Perl\fR will translate to Perl \s-1SAX\s0
methods calls.  See \s-1SAX\s0 1.0 for details.
.Sp
.Vb 8
\& setDocumentLocator(locator)
\& startDocument()
\& endDocument()
\& startElement(name, atts)
\& endElement(name)
\& characters(ch, start, length)
\& ignorableWhitespace(ch, start, length)
\& processingInstruction(target, data)
.Ve
.SH "OPTIONS"
The following options are supported by \f(CWXML::SAX2Perl\fR:
.PP
.Vb 7
\& Handler          default handler to receive events
\& DocumentHandler  handler to receive document events
\& DTDHandler       handler to receive DTD events
\& ErrorHandler     handler to receive error events
\& EntityResolver   handler to resolve entities
\& Locale           locale to provide localisation for errors
\& Source           hash containing the input source for parsing
.Ve
If no handlers are provided then all events will be silently ignored,
except for `\f(CWfatal_error()\fR\*(R' which will cause a `\f(CWdie()\fR\*(R' to be
called after calling `\f(CWend_document()\fR\*(R'.
.PP
If a single string argument is passed to the `\f(CWparse()\fR\*(R' method, it
is treated as if a `\f(CWSource\fR\*(R' option was given with a `\f(CWString\fR\*(R'
parameter.
.PP
The `\f(CWSource\fR\*(R' hash may contain the following parameters:
.PP
.Vb 6
\& ByteStream       The raw byte stream (file handle) containing the
\&                  document.
\& String           A string containing the document.
\& SystemId         The system identifier (URI) of the document.
\& PublicId         The public identifier.
\& Encoding         A string describing the character encoding.
.Ve
If more than one of `\f(CWByteStream\fR\*(R', `\f(CWString\fR\*(R', or `\f(CWSystemId\fR\*(R',
then preference is given first to `\f(CWByteStream\fR\*(R', then `\f(CWString\fR\*(R',
then `\f(CWSystemId\fR\*(R'.
.SH "HANDLERS"
The following handlers and properties are supported by
\f(CWXML::SAX2Perl\fR:
.Sh "DocumentHandler methods"
.Ip "start_document" 4
Receive notification of the beginning of a document. 
.Sp
.Vb 2
\& Locator          An object that can return the location of any SAX
\&                  document event.
.Ve
.Ip "end_document" 4
Receive notification of the end of a document. 
.Sp
No properties defined.
.Ip "start_element" 4
Receive notification of the beginning of an element. 
.Sp
.Vb 2
\& Name             The element type name.
\& Attributes       Attributes attached to the element, if any.
.Ve
\s-1ALPHA\s0 \s-1WARNING\s0: The `\f(CWAttributes\fR\*(R' value is not translated from the
\s-1SAX\s0 1.0 value, so it will contain an AttributeList object.
.Ip "end_element" 4
Receive notification of the end of an element. 
.Sp
.Vb 1
\& Name             The element type name.
.Ve
.Ip "characters" 4
Receive notification of character data. 
.Sp
.Vb 1
\& Data             The characters from the XML document.
.Ve
.Ip "ignorable_whitespace" 4
Receive notification of ignorable whitespace in element content. 
.Sp
.Vb 1
\& Data             The characters from the XML document.
.Ve
.Ip "processing_instruction" 4
Receive notification of a processing instruction. 
.Sp
.Vb 2
\& Target           The processing instruction target. 
\& Data             The processing instruction data, if any.
.Ve
.SH "AUTHOR"
Ken MacLeod <ken@bitsko.slc.ut.us>
.SH "SEE ALSO"
\fIperl\fR\|(1), \fIXML::Perl2SAX\fR\|(3).
.PP
.Vb 2
\& Extensible Markup Language (XML) <http://www.w3c.org/XML/>
\& Simple API for XML (SAX) <http://www.megginson.com/SAX/>
.Ve

.rn }` ''
.IX Title "lib::XML::SAX2Perl 3"
.IX Name "XML::SAX2Perl - translate Java/CORBA style SAX methods to Perl methods"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "METHODS"

.IX Item "new"

.IX Item "parse"

.IX Item "location"

.IX Item "\s-1SAX\s0 DocumentHandler Methods"

.IX Header "OPTIONS"

.IX Header "HANDLERS"

.IX Subsection "DocumentHandler methods"

.IX Item "start_document"

.IX Item "end_document"

.IX Item "start_element"

.IX Item "end_element"

.IX Item "characters"

.IX Item "ignorable_whitespace"

.IX Item "processing_instruction"

.IX Header "AUTHOR"

.IX Header "SEE ALSO"

