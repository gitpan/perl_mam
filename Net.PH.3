.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Net::PH 3 "perl 5.005, patch 53" "30/Nov/97" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Net::PH \- CCSO Nameserver Client class
.SH "SYNOPSIS"
.PP
.Vb 6
\&    use Net::PH;
\&    
\&    $ph = Net::PH->new("some.host.name",
\&                       Port    => 105,
\&                       Timeout => 120,
\&                       Debug   => 0);
.Ve
.Vb 17
\&    if($ph) {
\&        $q = $ph->query({ field1 => "value1" },
\&                        [qw(name address pobox)]);
\&    
\&        if($q) {
\&        }
\&    }
\&    
\&    # Alternative syntax
\&    
\&    if($ph) {
\&        $q = $ph->query('field1=value1',
\&                        'name address pobox');
\&    
\&        if($q) {
\&        }
\&    }
.Ve
.SH "DESCRIPTION"
\f(CWNet::PH\fR is a class implementing a simple Nameserver/PH client in Perl
as described in the CCSO Nameserver -- Server-Client Protocol. Like other
modules in the Net:: family the \f(CWNet::PH\fR object inherits methods from
\f(CWNet::Cmd\fR.
.SH "CONSTRUCTOR"
.Ip "new ( [ \s-1HOST\s0 ] [, \s-1OPTIONS\s0 ])" 4
.Sp
.Vb 5
\&    $ph = Net::PH->new("some.host.name",
\&                       Port    => 105,
\&                       Timeout => 120,
\&                       Debug   => 0
\&                      );
.Ve
This is the constructor for a new Net::\s-1PH\s0 object. \f(CWHOST\fR is the
name of the remote host to which a \s-1PH\s0 connection is required.
.Sp
If \f(CWHOST\fR is not given, then the \f(CWSNPP_Host\fR specified in \f(CWNet::Config\fR
will be used.
.Sp
\f(CWOPTIONS\fR is an optional list of named options which are passed in
a hash like fashion, using key and value pairs. Possible options are:-
.Sp
\fBPort\fR \- Port number to connect to on remote host.
.Sp
\fBTimeout\fR \- Maximum time, in seconds, to wait for a response from the
Nameserver, a value of zero will cause all \s-1IO\s0 operations to block.
(default: 120)
.Sp
\fBDebug\fR \- Enable the printing of debugging information to \s-1STDERR\s0
.SH "METHODS"
Unless otherwise stated all methods return either a \fItrue\fR or \fIfalse\fR
value, with \fItrue\fR meaning that the operation was a success. When a method
states that it returns a value, failure will be returned as \fIundef\fR or an
empty list.
.Ip "query( \s-1SEARCH\s0 [, \s-1RETURN\s0 ] )" 4
.Sp
.Vb 12
\&    $q = $ph->query({ name => $myname },
\&                    [qw(name email schedule)]);
\&    
\&    foreach $handle (@{$q}) {
\&        foreach $field (keys %{$handle}) {
\&            $c = ${$handle}{$field}->code;
\&            $v = ${$handle}{$field}->value;
\&            $f = ${$handle}{$field}->field;
\&            $t = ${$handle}{$field}->text;
\&            print "field:[$field] [$c][$v][$f][$t]\en" ;
\&        }
\&    }
.Ve
.Vb 1
\&    
.Ve
Search the database and return fields from all matching entries.
.Sp
The \f(CWSEARCH\fR argument is a reference to a \s-1HASH\s0 which contains field/value
pairs which will be passed to the Nameserver as the search criteria.
.Sp
\f(CWRETURN\fR is optional, but if given it should be a reference to a list which
contains field names to be returned.
.Sp
The alternative syntax is to pass strings instead of references, for example
.Sp
.Vb 2
\&    $q = $ph->query('name=myname',
\&                    'name email schedule');
.Ve
The \f(CWSEARCH\fR argument is a string that is passed to the Nameserver as the 
search criteria. The strings being passed should \fBnot\fR contain any carriage
returns, or else the query command might fail or return invalid data.
.Sp
\f(CWRETURN\fR is optional, but if given it should be a string which will
contain field names to be returned.
.Sp
Each match from the server will be returned as a \s-1HASH\s0 where the keys are the
field names and the values are \f(CWNet::PH:Result\fR objects (\fIcode\fR, \fIvalue\fR, 
\fIfield\fR, \fItext\fR).
.Sp
Returns a reference to an \s-1ARRAY\s0 which contains references to HASHs, one
per match from the server.
.Ip "change( \s-1SEARCH\s0 , \s-1MAKE\s0 )" 4
.Sp
.Vb 2
\&    $r = $ph->change({ email => "*.domain.name" },
\&                     { schedule => "busy");
.Ve
Change field values for matching entries.
.Sp
The \f(CWSEARCH\fR argument is a reference to a \s-1HASH\s0 which contains field/value
pairs which will be passed to the Nameserver as the search criteria.
.Sp
The \f(CWMAKE\fR argument is a reference to a \s-1HASH\s0 which contains field/value
pairs which will be passed to the Nameserver that
will set new values to designated fields.
.Sp
The alternative syntax is to pass strings instead of references, for example
.Sp
.Vb 2
\&    $r = $ph->change('email="*.domain.name"',
\&                     'schedule="busy"');
.Ve
The \f(CWSEARCH\fR argument is a string to be passed to the Nameserver as the 
search criteria. The strings being passed should \fBnot\fR contain any carriage
returns, or else the query command might fail or return invalid data.
.Sp
The \f(CWMAKE\fR argument is a string to be passed to the Nameserver that
will set new values to designated fields.
.Sp
Upon success all entries that match the search criteria will have
the field values, given in the Make argument, changed.
.Ip "login( \s-1USER\s0, \s-1PASS\s0 [, \s-1ENCRYPT\s0 ])" 4
.Sp
.Vb 1
\&    $r = $ph->login('username','password',1);
.Ve
Enter login mode using \f(CWUSER\fR and \f(CWPASS\fR. If \f(CWENCRYPT\fR is given and
is \fItrue\fR then the password will be used to encrypt a challenge text 
string provided by the server, and the encrypted string will be sent back
to the server. If \f(CWENCRYPT\fR is not given, or \fIfalse\fR then the password 
will be sent in clear text (\fIthis is not recommended\fR)
.Ip "logout()" 4
.Sp
.Vb 1
\&    $r = $ph->logout();
.Ve
Exit login mode and return to anonymous mode.
.Ip "fields( [ \s-1FIELD_LIST\s0 ] )" 4
.Sp
.Vb 8
\&    $fields = $ph->fields();
\&    foreach $field (keys %{$fields}) {
\&        $c = ${$fields}{$field}->code;
\&        $v = ${$fields}{$field}->value;
\&        $f = ${$fields}{$field}->field;
\&        $t = ${$fields}{$field}->text;
\&        print "field:[$field] [$c][$v][$f][$t]\en";
\&    }
.Ve
In a scalar context, returns a reference to a \s-1HASH\s0. The keys of the \s-1HASH\s0 are
the field names and the values are \f(CWNet::PH:Result\fR objects (\fIcode\fR,
\fIvalue\fR, \fIfield\fR, \fItext\fR).
.Sp
In an array context, returns a two element array. The first element is a
reference to a \s-1HASH\s0 as above, the second element is a reference to an array
which contains the tag names in the order that they were returned from the
server.
.Sp
\f(CWFIELD_LIST\fR is a string that lists the fields for which info will be
returned.
.Ip "add( \s-1FIELD_VALUES\s0 )" 4
.Sp
.Vb 1
\&    $r = $ph->add( { name => $name, phone => $phone });
.Ve
This method is used to add new entries to the Nameserver database. You
must successfully call the \fIlogin\fR manpage before this method can be used.
.Sp
\fBNote\fR that this method adds new entries to the database. To modify
an existing entry use the \fIchange\fR manpage.
.Sp
\f(CWFIELD_VALUES\fR is a reference to a \s-1HASH\s0 which contains field/value
pairs which will be passed to the Nameserver and will be used to 
initialize the new entry.
.Sp
The alternative syntax is to pass a string instead of a reference, for example
.Sp
.Vb 1
\&    $r = $ph->add('name=myname phone=myphone');
.Ve
\f(CWFIELD_VALUES\fR is a string that consists of field/value pairs which the
new entry will contain. The strings being passed should \fBnot\fR contain any
carriage returns, or else the query command might fail or return invalid data.
.Ip "delete( \s-1FIELD_VALUES\s0 )" 4
.Sp
.Vb 1
\&    $r = $ph->delete('name=myname phone=myphone');
.Ve
This method is used to delete existing entries from the Nameserver database.
You must successfully call the \fIlogin\fR manpage before this method can be used.
.Sp
\fBNote\fR that this method deletes entries to the database. To modify
an existing entry use the \fIchange\fR manpage.
.Sp
\f(CWFIELD_VALUES\fR is a string that serves as the search criteria for the
records to be deleted. Any entry in the database which matches this search 
criteria will be deleted.
.Ip "id( [ \s-1ID\s0 ] )" 4
.Sp
.Vb 1
\&    $r = $ph->id('709');
.Ve
Sends \f(CWID\fR to the Nameserver, which will enter this into its
logs. If \f(CWID\fR is not given then the \s-1UID\s0 of the user running the
process will be sent.
.Ip "status()" 4
Returns the current status of the Nameserver.
.Ip "siteinfo()" 4
.Sp
.Vb 8
\&    $siteinfo = $ph->siteinfo();
\&    foreach $field (keys %{$siteinfo}) {
\&        $c = ${$siteinfo}{$field}->code;
\&        $v = ${$siteinfo}{$field}->value;
\&        $f = ${$siteinfo}{$field}->field;
\&        $t = ${$siteinfo}{$field}->text;
\&        print "field:[$field] [$c][$v][$f][$t]\en";
\&    }
.Ve
Returns a reference to a \s-1HASH\s0 containing information about the server's 
site. The keys of the \s-1HASH\s0 are the field names and values are
\f(CWNet::PH:Result\fR objects (\fIcode\fR, \fIvalue\fR, \fIfield\fR, \fItext\fR).
.Ip "quit()" 4
.Sp
.Vb 1
\&    $r = $ph->quit();
.Ve
Quit the connection
.SH "Q&A"
How do I get the values of a Net::PH::Result object?
.PP
.Vb 8
\&    foreach $handle (@{$q}) {
\&        foreach $field (keys %{$handle}) {
\&            $my_code  = ${$q}{$field}->code;
\&            $my_value = ${$q}{$field}->value;
\&            $my_field = ${$q}{$field}->field;
\&            $my_text  = ${$q}{$field}->text;
\&        }
\&    }
.Ve
How do I get a count of the returned matches to my query?
.PP
.Vb 1
\&    $my_count = scalar(@{$query_result});
.Ve
How do I get the status code and message of the last \f(CW$ph\fR command?
.PP
.Vb 2
\&    $status_code    = $ph->code;
\&    $status_message = $ph->message;
.Ve
.SH "SEE ALSO"
the \fINet::Cmd\fR manpage
.SH "AUTHORS"
Graham Barr <gbarr@pobox.com>
Alex Hristov <hristov@slb.com>
.SH "ACKNOWLEDGMENTS"
Password encryption code ported to perl by Broc Seib <bseib@purdue.edu>,
Purdue University Computing Center.
.PP
Otis Gospodnetic <otisg@panther.middlebury.edu> suggested
passing parameters as string constants. Some queries cannot be 
executed when passing parameters as string references.
.PP
.Vb 1
\&        Example: query first_name last_name email="*.domain"
.Ve
.SH "COPYRIGHT"
The encryption code is based upon cryptit.c, Copyright (C) 1988 by
Steven Dorner, and Paul Pomes, and the University of Illinois Board
of Trustees, and by CSNET.
.PP
All other code is Copyright (c) 1996-1997 Graham Barr <gbarr@pobox.com>
and Alex Hristov <hristov@slb.com>. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

.rn }` ''
.IX Title "Net::PH 3"
.IX Name "Net::PH - CCSO Nameserver Client class"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "CONSTRUCTOR"

.IX Item "new ( [ \s-1HOST\s0 ] [, \s-1OPTIONS\s0 ])"

.IX Header "METHODS"

.IX Item "query( \s-1SEARCH\s0 [, \s-1RETURN\s0 ] )"

.IX Item "change( \s-1SEARCH\s0 , \s-1MAKE\s0 )"

.IX Item "login( \s-1USER\s0, \s-1PASS\s0 [, \s-1ENCRYPT\s0 ])"

.IX Item "logout()"

.IX Item "fields( [ \s-1FIELD_LIST\s0 ] )"

.IX Item "add( \s-1FIELD_VALUES\s0 )"

.IX Item "delete( \s-1FIELD_VALUES\s0 )"

.IX Item "id( [ \s-1ID\s0 ] )"

.IX Item "status()"

.IX Item "siteinfo()"

.IX Item "quit()"

.IX Header "Q&A"

.IX Header "SEE ALSO"

.IX Header "AUTHORS"

.IX Header "ACKNOWLEDGMENTS"

.IX Header "COPYRIGHT"

