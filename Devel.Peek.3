.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Peek 3 "perl 5.005, patch 53" "3/Oct/98" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Devel::Peek \- A data debugging tool for the XS programmer
.SH "SYNOPSIS"
.PP
.Vb 5
\&        use Devel::Peek;
\&        Dump( $a );
\&        Dump( $a, 5 );
\&        DumpArray( 5, $a, $b, ... );
\&        mstat "Point 5";
.Ve
.SH "DESCRIPTION"
Devel::Peek contains functions which allows raw Perl datatypes to be
manipulated from a Perl script.  This is used by those who do XS programming
to check that the data they are sending from C to Perl looks as they think
it should look.  The trick, then, is to know what the raw datatype is
supposed to look like when it gets to Perl.  This document offers some tips
and hints to describe good and bad raw data.
.PP
It is very possible that this document will fall far short of being useful
to the casual reader.  The reader is expected to understand the material in
the first few sections of the \fIperlguts\fR manpage.
.PP
Devel::Peek supplies a \f(CWDump()\fR function which can dump a raw Perl
datatype, and \f(CWmstat("marker")\fR function to report on memory usage
(if perl is compiled with corresponding option).  The function
\fIDeadCode()\fR provides statistics on the data \*(L"frozen\*(R" into inactive
\f(CWCV\fR.  Devel::Peek also supplies \f(CWSvREFCNT()\fR, \f(CWSvREFCNT_inc()\fR, and
\f(CWSvREFCNT_dec()\fR which can query, increment, and decrement reference
counts on SVs.  This document will take a passive, and safe, approach
to data debugging and for that it will describe only the \f(CWDump()\fR
function.
.PP
Function \f(CWDumpArray()\fR allows dumping of multiple values (useful when you
need to analize returns of functions).
.PP
The global variable \f(CW$Devel::Peek::pv_limit\fR can be set to limit the
number of character printed in various string values.  Setting it to 0
means no limit.
.SH "EXAMPLES"
The following examples don't attempt to show everything as that would be a
monumental task, and, frankly, we don't want this manpage to be an internals
document for Perl.  The examples do demonstrate some basics of the raw Perl
datatypes, and should suffice to get most determined people on their way.
There are no guidewires or safety nets, nor blazed trails, so be prepared to
travel alone from this point and on and, if at all possible, don't fall into
the quicksand (it's bad for business).
.PP
Oh, one final bit of advice: take the \fIperlguts\fR manpage with you.  When you return we
expect to see it well-thumbed.
.Sh "A simple scalar string"
Let's begin by looking a simple scalar which is holding a string.
.PP
.Vb 3
\&        use Devel::Peek 'Dump';
\&        $a = "hello";
\&        Dump $a;
.Ve
The output:
.PP
.Vb 7
\&        SV = PVIV(0xbc288)
\&          REFCNT = 1
\&          FLAGS = (POK,pPOK)
\&          IV = 0
\&          PV = 0xb2048 "hello"\e0
\&          CUR = 5
\&          LEN = 6
.Ve
This says \f(CW$a\fR is an \s-1SV\s0, a scalar.  The scalar is a \s-1PVIV\s0, a string.
Its reference count is 1.  It has the \f(CWPOK\fR flag set, meaning its
current \s-1PV\s0 field is valid.  Because \s-1POK\s0 is set we look at the \s-1PV\s0 item
to see what is in the scalar.  The \e0 at the end indicate that this
\s-1PV\s0 is properly \s-1NUL\s0\-terminated.
If the \s-1FLAGS\s0 had been \s-1IOK\s0 we would look
at the \s-1IV\s0 item.  \s-1CUR\s0 indicates the number of characters in the \s-1PV\s0.
\s-1LEN\s0 indicates the number of bytes requested for the \s-1PV\s0 (one more than
\s-1CUR\s0, in this case, because \s-1LEN\s0 includes an extra byte for the
end-of-string marker).
.Sh "A simple scalar number"
If the scalar contains a number the raw \s-1SV\s0 will be leaner.
.PP
.Vb 3
\&        use Devel::Peek 'Dump';
\&        $a = 42;
\&        Dump $a;
.Ve
The output:
.PP
.Vb 4
\&        SV = IV(0xbc818)
\&          REFCNT = 1
\&          FLAGS = (IOK,pIOK)
\&          IV = 42
.Ve
This says \f(CW$a\fR is an \s-1SV\s0, a scalar.  The scalar is an \s-1IV\s0, a number.  Its
reference count is 1.  It has the \f(CWIOK\fR flag set, meaning it is currently
being evaluated as a number.  Because \s-1IOK\s0 is set we look at the \s-1IV\s0 item to
see what is in the scalar.
.Sh "A simple scalar with an extra reference"
If the scalar from the previous example had an extra reference:
.PP
.Vb 4
\&        use Devel::Peek 'Dump';
\&        $a = 42;
\&        $b = \e$a;
\&        Dump $a;
.Ve
The output:
.PP
.Vb 4
\&        SV = IV(0xbe860)
\&          REFCNT = 2
\&          FLAGS = (IOK,pIOK)
\&          IV = 42
.Ve
Notice that this example differs from the previous example only in its
reference count.  Compare this to the next example, where we dump \f(CW$b\fR
instead of \f(CW$a\fR.
.Sh "A reference to a simple scalar"
This shows what a reference looks like when it references a simple scalar.
.PP
.Vb 4
\&        use Devel::Peek 'Dump';
\&        $a = 42;
\&        $b = \e$a;
\&        Dump $b;
.Ve
The output:
.PP
.Vb 8
\&        SV = RV(0xf041c)
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xbab08
\&        SV = IV(0xbe860)
\&          REFCNT = 2
\&          FLAGS = (IOK,pIOK)
\&          IV = 42
.Ve
Starting from the top, this says \f(CW$b\fR is an \s-1SV\s0.  The scalar is an \s-1RV\s0, a
reference.  It has the \f(CWROK\fR flag set, meaning it is a reference.  Because
\s-1ROK\s0 is set we have an \s-1RV\s0 item rather than an \s-1IV\s0 or \s-1PV\s0.  Notice that Dump
follows the reference and shows us what \f(CW$b\fR was referencing.  We see the
same \f(CW$a\fR that we found in the previous example.
.PP
Note that the value of \f(CWRV\fR coincides with the numbers we see when we
stringify \f(CW$b\fR. The addresses inside \fI\s-1RV\s0()\fR and \fI\s-1IV\s0()\fR are addresses of
\f(CWX***\fR structure which holds the current state of an \f(CWSV\fR. This
address may change during lifetime of an \s-1SV\s0.
.Sh "A reference to an array"
This shows what a reference to an array looks like.
.PP
.Vb 3
\&        use Devel::Peek 'Dump';
\&        $a = [42];
\&        Dump $a;
.Ve
The output:
.PP
.Vb 20
\&        SV = RV(0xf041c)
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xb2850
\&        SV = PVAV(0xbd448)
\&          REFCNT = 1
\&          FLAGS = ()
\&          IV = 0
\&          NV = 0
\&          ARRAY = 0xb2048
\&          ALLOC = 0xb2048
\&          FILL = 0
\&          MAX = 0
\&          ARYLEN = 0x0
\&          FLAGS = (REAL)
\&        Elt No. 0 0xb5658
\&        SV = IV(0xbe860)
\&          REFCNT = 1
\&          FLAGS = (IOK,pIOK)
\&          IV = 42
.Ve
This says \f(CW$a\fR is an \s-1SV\s0 and that it is an \s-1RV\s0.  That \s-1RV\s0 points to
another \s-1SV\s0 which is a \s-1PVAV\s0, an array.  The array has one element,
element zero, which is another \s-1SV\s0. The field \f(CWFILL\fR above indicates
the last element in the array, similar to \f(CW$#$a\fR.
.PP
If \f(CW$a\fR pointed to an array of two elements then we would see the
following.
.PP
.Vb 3
\&        use Devel::Peek 'Dump';
\&        $a = [42,24];
\&        Dump $a;
.Ve
The output:
.PP
.Vb 25
\&        SV = RV(0xf041c)
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xb2850
\&        SV = PVAV(0xbd448)
\&          REFCNT = 1
\&          FLAGS = ()
\&          IV = 0
\&          NV = 0
\&          ARRAY = 0xb2048
\&          ALLOC = 0xb2048
\&          FILL = 0
\&          MAX = 0
\&          ARYLEN = 0x0
\&          FLAGS = (REAL)
\&        Elt No. 0  0xb5658
\&        SV = IV(0xbe860)
\&          REFCNT = 1
\&          FLAGS = (IOK,pIOK)
\&          IV = 42
\&        Elt No. 1  0xb5680
\&        SV = IV(0xbe818)
\&          REFCNT = 1
\&          FLAGS = (IOK,pIOK)
\&          IV = 24
.Ve
Note that \f(CWDump\fR will not report \fIall\fR the elements in the array,
only several first (depending on how deep it already went into the
report tree).
.Sh "A reference to a hash"
The following shows the raw form of a reference to a hash.
.PP
.Vb 3
\&        use Devel::Peek 'Dump';
\&        $a = {hello=>42};
\&        Dump $a;
.Ve
The output:
.PP
.Vb 19
\&        SV = RV(0xf041c)
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xb2850
\&        SV = PVHV(0xbd448)
\&          REFCNT = 1
\&          FLAGS = ()
\&          NV = 0
\&          ARRAY = 0xbd748
\&          KEYS = 1
\&          FILL = 1
\&          MAX = 7
\&          RITER = -1
\&          EITER = 0x0
\&        Elt "hello" => 0xbaaf0
\&        SV = IV(0xbe860)
\&          REFCNT = 1
\&          FLAGS = (IOK,pIOK)
\&          IV = 42
.Ve
This shows \f(CW$a\fR is a reference pointing to an \s-1SV\s0.  That \s-1SV\s0 is a \s-1PVHV\s0, a
hash. Fields \s-1RITER\s0 and \s-1EITER\s0 are used by \f(CWthe \fIeach\fR\fR manpage.
.Sh "Dumping a large array or hash"
The \f(CWDump()\fR function, by default, dumps up to 4 elements from a
toplevel array or hash.  This number can be increased by supplying a
second argument to the function.
.PP
.Vb 3
\&        use Devel::Peek 'Dump';
\&        $a = [10,11,12,13,14];
\&        Dump $a;
.Ve
Notice that \f(CWDump()\fR prints only elements 10 through 13 in the above code.
The following code will print all of the elements.
.PP
.Vb 3
\&        use Devel::Peek 'Dump';
\&        $a = [10,11,12,13,14];
\&        Dump $a, 5;
.Ve
.Sh "A reference to an \s-1SV\s0 which holds a C pointer"
This is what you really need to know as an \s-1XS\s0 programmer, of course.  When
an \s-1XSUB\s0 returns a pointer to a C structure that pointer is stored in an \s-1SV\s0
and a reference to that \s-1SV\s0 is placed on the \s-1XSUB\s0 stack.  So the output from
an \s-1XSUB\s0 which uses something like the T_PTROBJ map might look something like
this:
.PP
.Vb 11
\&        SV = RV(0xf381c)
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xb8ad8
\&        SV = PVMG(0xbb3c8)
\&          REFCNT = 1
\&          FLAGS = (OBJECT,IOK,pIOK)
\&          IV = 729160
\&          NV = 0
\&          PV = 0
\&          STASH = 0xc1d10       "CookBookB::Opaque"
.Ve
This shows that we have an \s-1SV\s0 which is an \s-1RV\s0.  That \s-1RV\s0 points at another
\s-1SV\s0.  In this case that second \s-1SV\s0 is a \s-1PVMG\s0, a blessed scalar.  Because it is
blessed it has the \f(CWOBJECT\fR flag set.  Note that an \s-1SV\s0 which holds a C
pointer also has the \f(CWIOK\fR flag set.  The \f(CWSTASH\fR is set to the package
name which this \s-1SV\s0 was blessed into.
.PP
The output from an \s-1XSUB\s0 which uses something like the T_PTRREF map, which
doesn't bless the object, might look something like this:
.PP
.Vb 10
\&        SV = RV(0xf381c)
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xb8ad8
\&        SV = PVMG(0xbb3c8)
\&          REFCNT = 1
\&          FLAGS = (IOK,pIOK)
\&          IV = 729160
\&          NV = 0
\&          PV = 0
.Ve
.Sh "A reference to a subroutine"
Looks like this:
.PP
.Vb 18
\&        SV = RV(0x798ec)
\&          REFCNT = 1
\&          FLAGS = (TEMP,ROK)
\&          RV = 0x1d453c
\&        SV = PVCV(0x1c768c)
\&          REFCNT = 2
\&          FLAGS = ()
\&          IV = 0
\&          NV = 0
\&          COMP_STASH = 0x31068  "main"
\&          START = 0xb20e0
\&          ROOT = 0xbece0
\&          XSUB = 0x0
\&          XSUBANY = 0
\&          GVGV::GV = 0x1d44e8   "MY" :: "top_targets"
\&          FILEGV = 0x1fab74     "_<(eval 5)"
\&          DEPTH = 0
\&          PADLIST = 0x1c9338
.Ve
This shows that 
.Ip "" 5
the subroutine is not an \s-1XSUB\s0 (since \f(CWSTART\fR and \f(CWROOT\fR are
non-zero, and \f(CWXSUB\fR is zero);
.Ip "" 5
that it was compiled in the package \f(CWmain\fR;
.Ip "" 5
under the name \f(CWMY::top_targets\fR; 
.Ip "" 5
inside a 5th eval in the program;
.Ip "" 5
it is not currently executed (see \f(CWDEPTH\fR);
.Ip "" 5
it has no prototype (\f(CWPROTOTYPE\fR field is missing).
.SH "EXPORTS"
\f(CWPeek\fR, \f(CWmstats\fR, \f(CWDeadCode\fR by default. Additionally available \f(CWSvREFCNT\fR,
\f(CWSvREFCNT_inc\fR, \f(CWSvREFCNT_dec\fR.
.SH "BUGS"
Readers have been known to skip important parts of the \fIperlguts\fR manpage, causing much
frustration for all.
.SH "SEE ALSO"
the \fIperlguts\fR manpage, and the \fIperlguts\fR manpage, again.

.rn }` ''
.IX Title "Peek 3"
.IX Name "Devel::Peek - A data debugging tool for the XS programmer"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "EXAMPLES"

.IX Subsection "A simple scalar string"

.IX Subsection "A simple scalar number"

.IX Subsection "A simple scalar with an extra reference"

.IX Subsection "A reference to a simple scalar"

.IX Subsection "A reference to an array"

.IX Subsection "A reference to a hash"

.IX Subsection "Dumping a large array or hash"

.IX Subsection "A reference to an \s-1SV\s0 which holds a C pointer"

.IX Subsection "A reference to a subroutine"

.IX Item ""

.IX Item ""

.IX Item ""

.IX Item ""

.IX Item ""

.IX Item ""

.IX Header "EXPORTS"

.IX Header "BUGS"

.IX Header "SEE ALSO"

