.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::Net::Telnet 3 "perl 5.004, patch 55" "15/Mar/97" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Net::Telnet \- interact with TELNET port or other TCP ports
.SH "SYNOPSIS"
.PP
.Vb 2
\&    use Net::Telnet ();
\&    see METHODS section below
.Ve
.SH "DESCRIPTION"
Net::Telnet allows you to make client connections to a TCP port and do
network I/O, especially with a port using the TELNET protocol.  Simple
I/O methods such as print, get, and getline are provided.  More
sophisticated interactive features are provided because connecting to
a TELNET port ultimately means communicating with a program designed
for human interaction.  Some interactive features include the ability
to specify a timeout and to wait for patterns to appear in the input
stream, such as the prompt from a command interpreter.
.PP
This example prints who's logged-on to the remote host sparky:
.PP
.Vb 7
\&    $sparky = new Net::Telnet (Host => "sparky",
\&                               Timeout => 10,
\&                               Prompt => '/[$%#>] $/');
\&    $sparky->login($username, $passwd);
\&    @lines = $sparky->cmd("/usr/bin/who");
\&    print @lines;
\&    $sparky->close;
.Ve
Methods \fBlogin()\fR and \fBcmd()\fR use the prompt setting in the object
to determine when a login or command is complete.  If the prompt
doesn't match, it's likely those commands will timeout.
.PP
Other reasons to use this class than strictly with a TELNET port are:
.Ip "\(bu" 2
You're not familiar with sockets and you want a simple way to make
client connections to \s-1TCP\s0 services.
.Ip "\(bu" 2
You want to be able to specify your own time-out while connecting,
reading, or writing.
.Ip "\(bu" 2
You're communicating with an interactive program at the other end of
some socket or pipe and you want to wait for certain patterns to
appear.
.PP
\fBPlease note\fR some important differences with most other Perl I/O
calls.  All input is buffered, while all output is flushed.  The
output record separator for \fBprint()\fR is set to \fB\en\fR by default, so
there's no need to append all your commands with a newline.  See
\fBoutput_record_separator()\fR to change the default.  In the input
stream, each sequence of \fB\er\en\fR is converted to \fB\en\fR.  In the output
stream, each occurrence of \fB\en\fR is converted to a sequence of
\fB\er\en\fR.  See \fBbinmode()\fR to change the default.  \s-1TCP\s0 protocols
typically use the \s-1ASCII\s0 sequence \fIcarriage-return\fR \fInewline\fR to
designate a newline.
.PP
You'll need to be running at least Perl version 5.002 to use this
module.  This module does not require any libraries that don't already
come with the standard Perl distribution.  If you have the \s-1IO\s0::
libraries then methods are inherited from the class \s-1IO::\s0Socket::\s-1INET\s0,
otherwise FileHandle is used as a base class.
.PP
Special methods are provided to handle errors.  Normally when an error
or timeout is encountered using a telnet object, the program dies with
an error message printed to standard error.  You may arrange for the
methods to return with an undefined value instead by using
\fBerrmode()\fR or the \fBerrmode\fR option to \fBnew()\fR.  See \fBerrmode()\fR
for other sophisticated error mode settings.  The error message itself
may be obtained using the \fBerrmsg()\fR.
.PP
Note that \fIeof\fR is not considered an error while \fItiming-out\fR is.
.PP
While debugging your program use \fBinput_log()\fR or \fBdump_log()\fR to
see what's actually being received and sent.
.PP
Two different styles of named arguments are supported.  This document
only shows the \s-1IO\s0:: style:
.PP
.Vb 1
\&    Net::Telnet->new(Timeout => 20);
.Ve
however the dash-option style is also allowed:
.PP
.Vb 1
\&    Net::Telnet->new(-timeout => 20);
.Ve
For more help, see the \fB\s-1EXAMPLES\s0\fR section below.
.PP
This is an alpha version \- meaning that the interface may change in
future versions.  Contact me, Jay Rogers <jay@rgrs.com>, if you find
any bugs or have suggestions for improvement.
.SH "METHODS"
.Sh "new \- create a new Net::Telnet object"
.PP
.Vb 13
\&    $obj = Net::Telnet->new([Binmode    => $mode,]
\&                            [Dump_Log   => $filename,]
\&                            [Errmode    => $errmode,]
\&                            [Fhopen     => $filehandle,]
\&                            [Host       => $host,]
\&                            [Input_log  => $file,]
\&                            [Input_record_separator => $char,]
\&                            [Output_log => $file,]
\&                            [Output_record_separator => $char,]
\&                            [Port       => $port,]
\&                            [Prompt     => $matchop,]
\&                            [Telnetmode => $mode,]
\&                            [Timeout    => $secs,]);
.Ve
This is the constructor for Net::Telnet objects.  A new object is
returned on success, the \fI$errmode\fR action is performed on failure \-
see \fBerrmode()\fR.  The arguments are short-cuts to methods of the same
name.
.PP
If the \fI$host\fR argument is given then the object is opened by
connecting to \s-1TCP\s0 \fI$port\fR on \fI$host\fR.  Also see \fBopen()\fR.  The new
object returned is given the following defaults in the absence of
corresponding named arguments:
.Ip "\(bu" 2
The default \fBhost\fR is \fB"localhost\*(R"\fR
.Ip "\(bu" 2
The default \fBport\fR is \fB23\fR
.Ip "\(bu" 2
The default \fBprompt\fR is \fB'/[$%#\fR>\fB] $/\*(R'\fR
.Ip "\(bu" 2
The default \fBtimeout\fR is \fB10\fR
.Ip "\(bu" 2
The default \fBerrmode\fR is \fB'die\*(R'\fR
.Ip "\(bu" 2
The default \fBoutput_record_separator\fR is \fB\*(R"\en\*(R"\fR
.Ip "\(bu" 2
The default \fBinput_record_separator\fR is \fB\*(R"\en\*(R"\fR
.Ip "\(bu" 2
The default \fBbinmode\fR is \fB0\fR, which means do newline translations
.Sh "binmode \- turn off/on newline translation"
.PP
.Vb 1
\&    $prev = $obj->binmode($mode);
.Ve
This method controls whether or not sequences of \fB\er\en\fR are
translated.  By default they are translated (i.e. binmode is \fIoff\fR).
.PP
If \fI$mode\fR is missing or \fB1\fR then binmode is \fIon\fR and newline
translation is not done.
.PP
If \fI$mode\fR is \fB0\fR then binmode is \fIoff\fR and newline translation is
done.  In the input stream, each sequence of \fB\er\en\fR is converted to
\fB\en\fR and in the output stream, each occurrence of \fB\en\fR is converted
to a sequence of \fB\er\en\fR.
.PP
Note that input is always buffered.  Changing binmode doesn't effect
what's already been read into the buffer.  Output is not buffered and
changing binmode will have an immediate effect.
.Sh "break \- send \s-1TELNET\s0 break character"
.PP
.Vb 1
\&    $ok = $obj->break;
.Ve
This method sends the \s-1TELNET\s0 break character.  This character is
provided because it's a signal outside the \s-1USASCII\s0 set which is
currently given local meaning within many systems.  It's intended to
indicate that the Break Key or the Attention Key was hit.
.Sh "close \- close object"
.PP
.Vb 1
\&    $ok = $obj->close;
.Ve
This method closes the socket, file, or pipe associated with the
object.
.Sh "cmd \- issue command and retrieve output"
.PP
.Vb 5
\&    $ok = $obj->cmd($string);
\&    $ok = $obj->cmd(String   => $string,
\&                    [Output  => $ref,]
\&                    [Prompt  => $match,]
\&                    [Timeout => $secs,]);
.Ve
.Vb 5
\&    @output = $obj->cmd($string);
\&    @output = $obj->cmd(String  => $string,
\&                        [Output  => $ref,]
\&                        [Prompt  => $match,]
\&                        [Timeout => $secs,]);
.Ve
This method sends the command \fI$string\fR, and reads the characters
sent back by the command up until and including the matching prompt.
It's assumed that the program to which you're sending is some kind of
command prompting interpreter such as a shell.
.PP
In a scalar context the characters read are discarded and a boolean is
returned indicating the success or failure of sending the command
string and reading the prompt.  Note that in order to return on error,
\fBerrmode()\fR must not be set to \fIdie\fR.
.PP
In an array context, just the output generated by the command is
returned, one line per element.  In other words, all the characters in
between the echoed back command string and the prompt are returned.
If the command happens to return no output, an array containing one
element, the null string is returned.  This is so the array will
indicate \fItrue\fR in a boolean context.
.PP
Optional named arguments are provided to override the current settings
of prompt and timeout.
.PP
The \fBoutput\fR named argument provides an alternative method of
receiving command output.  If you pass a scalar reference, the output
is returned in the referenced scalar.  If you pass an array or hash
reference, the lines of output are returned in the referenced array or
hash.
.Sh "dump_log \- log all I/O in dump format"
.PP
.Vb 1
\&    $fh = $obj->dump_log;
.Ve
.Vb 1
\&    $fh = $obj->dump_log($fh);
.Ve
.Vb 1
\&    $fh = $obj->dump_log($filename);
.Ve
This method starts or stops dump format logging of all the object's
input and output.  The dump format shows the blocks read and written
in a hexadecimal and printable character format.  This method is
useful when debugging, however you might want to first try
\fBinput_log()\fR as it's more readable.
.PP
If no argument is given, the current log filehandle is returned.  A
null string indicates logging is off.
.PP
To stop logging, use a null string as an argument.
.PP
If an open filehandle is given, it is used for logging and returned.
Otherwise, the argument is assumed to be the name of a file, the file
is opened and a filehandle to it is returned.
.Sh "eof \- end of file read indicator"
.PP
.Vb 1
\&    $eof = $obj->eof;
.Ve
This method indicates if end of file has been read.  Because the input
is buffered this isn't the same thing as \fI$obj\fR has closed.  In other
words \fI$obj\fR can be closed but there still can be stuff in the buffer
to be read.  Under this condition you can still read but you won't be
able to write.
.Sh "errmode \- set action to perform on error"
.PP
.Vb 1
\&    $mode = $obj->errmode;
.Ve
.Vb 1
\&    $prev = $obj->errmode($mode);
.Ve
This method gets or sets the action used when errors are encountered
using the object.  The first calling sequence returns the current
error mode.  The second calling sequence sets it to \fI$mode\fR and
returns the previous mode.  Valid values for \fI$mode\fR are \fBdie\fR (the
default), \fBreturn\fR, a \fIcoderef\fR, or an \fIarrayref\fR.
.PP
When mode is \fBdie\fR then when an error is encountered using the
object, the program dies and an error message is printed on standard
error.
.PP
When mode is \fBreturn\fR then the method generating the error places an
error message in the object and returns the undefined value in a
scalar context and a null list in list context.  The error message may
be obtained using \fBerrmsg()\fR.
.PP
When mode is a \fIcoderef\fR, then when an error is encountered
\fIcoderef\fR is called with the error message as its first argument.
Using this mode you may have your own subroutine handle errors.  If
\fIcoderef\fR itself returns then the method generating the error returns
undefined or a null list depending on context.
.PP
When mode is an \fIarrayref\fR, the first element of the array must be a
\fIcoderef\fR.  Any elements that follow are the arguments to \fIcoderef\fR.
When an error is encountered, the \fIcoderef\fR is called with its
arguments.  Using this mode you may have your own subroutine handle
errors.  If the \fIcoderef\fR itself returns then the method generating
the error returns undefined or a null list depending on context.
.Sh "errmsg \- most recent error message"
.PP
.Vb 1
\&    $msg = $obj->errmsg;
.Ve
.Vb 1
\&    $prev = $obj->errmsg(@msgs);
.Ve
The first calling sequence returns the error message associated with
the object.  The null string is returned if no error has been
encountered yet.  The second calling sequence sets the error message
for the object to the concatenation of \fI@msgs\fR and returns the
previous error message.  Normally, error messages are set internally
by a method when an error is encountered.
.Sh "error \- perform the error mode action"
.PP
.Vb 1
\&    $obj->error(@msgs);
.Ve
This method concatenates \fI@msgs\fR into a string and places it in the
object as the error message.  Also see \fBerrmsg()\fR.  It then performs
the error mode.  Also see \fBerrmode()\fR.
.PP
If the error mode doesn't cause the program to die then the undefined
value or a null list is returned depending on context.
.PP
This method is primarily used by this class or a sub-class to perform
the user requested action when an error is encountered.
.Sh "fhopen \- use an existing open filehandle"
.PP
.Vb 1
\&    $ok = $obj->fhopen($fh);
.Ve
This method associates the open filehandle \fI$fh\fR with the object for
further I/O.
.PP
This method provides a way to use this module with a filehandle that's
already opened.  Suppose you want to use the features of this module
to do I/O to something other than a \s-1TCP\s0 port.  Instead of opening the
object for I/O to a \s-1TCP\s0 port by passing a \fBhost\fR arg to \fBnew()\fR or
invoking \fBopen()\fR, call this method instead.
.Sh "get \- read block of data"
.PP
.Vb 1
\&    $data = $obj->get([Timeout => $secs,]);
.Ve
This method reads a block of data from the object and returns it along
with any buffered data.  If no buffered data is available to return,
it will wait for data to read using the timeout specified in the
object.  You can override that timeout using \fI$secs\fR.  Also see
\fBtimeout()\fR.  If buffered data is available to return, it also checks
for a block of data that can be immediately read.
.PP
On eof an undefined value is returned.  On timeout or other errors the
error mode action is performed.
.Sh "getline \- read next line"
.PP
.Vb 1
\&    $line = $obj->getline([Timeout => $secs,]);
.Ve
This method reads and returns the next line of data from the object.
You can use \fBinput_record_separator()\fR to change the notion of what
separates a line.  The default is \fB\en\fR.
.PP
If a line isn't immediately available, this method blocks waiting for
a line or the timeout.  You can override the object's timeout for this
method using \fI$secs\fR.  Also see \fBtimeout()\fR.
.PP
On eof an undefined value is returned.  On timeout or other errors the
error mode action is performed.
.Sh "getlines \- read next lines"
.PP
.Vb 1
\&    @lines = $obj->getlines([Timeout => $secs,]);
.Ve
This method reads and returns the next available lines of data from
the object.  You can use \fBinput_record_separator()\fR to change the
notion of what separates a line.  The default is \fB\en\fR.
.PP
If a line isn't immediately available, this method blocks waiting for
one or more lines, or the timeout.  You can override the object's
timeout for this method using \fI$secs\fR.  Also see \fBtimeout()\fR.
.PP
On eof a null array is returned.  On timeout or other errors the error
mode action is performed.
.Sh "host \- name of remote host"
.PP
.Vb 1
\&    $host = $obj->host;
.Ve
.Vb 1
\&    $prev = $obj->host($host);
.Ve
This method designates the remote host.  With no argument this method
returns the current host name set in the object.  With an argument it
sets the current host name to \fI$host\fR and returns the previous host
name.  You may indicate the remote host using either a hostname or an
\s-1IP\s0 address.
.Sh "input_log \- log all input"
.PP
.Vb 1
\&    $fh = $obj->input_log;
.Ve
.Vb 1
\&    $fh = $obj->input_log($fh);
.Ve
.Vb 1
\&    $fh = $obj->input_log($filename);
.Ve
This method starts or stops logging of input.  This is useful when
debugging.  Also see \fBdump_log()\fR.  Because most command interpreters
echo back commands received, its likely all your output will also be
in this log.  Note that input logging occurs after newline
translation.  See \fBbinmode()\fR for details on newline translation.
.PP
If no argument is given, the log filehandle is returned.  A null
string indicates logging is off.
.PP
To stop logging, use a null string as an argument.
.PP
If an open filehandle is given, it is used for logging and returned.
Otherwise, the argument is assumed to be the name of a file, the file
is opened for logging and a filehandle to it is returned.
.Sh "input_record_separator \- input line delimiter"
.PP
.Vb 1
\&    $rs = $obj->input_record_separator;
.Ve
.Vb 1
\&    $prev = $obj->input_record_separator($rs);
.Ve
This method designates the line delimiter for input.  It's used with
\fBgetline()\fR, \fBgetlines()\fR, and \fBcmd()\fR to determine lines in the
input.
.PP
With no argument this method returns the current input record
separator set in the object.  With an argument it sets the input
record separator to \fI$rs\fR and returns the previous value.
.Sh "lastline \- the lastline read"
.PP
.Vb 1
\&    $line = $obj->lastline;
.Ve
.Vb 1
\&    $prev = $obj->lastline($line);
.Ve
This method saves the last line read from the object.  This may be a
useful error message when the remote side abnormally closes the
connection.  Typically the remote side will print an error message
before closing.
.PP
With no argument this method returns the last line read from the
object.  With an argument it sets the last line read to \fI$line\fR and
returns the previous value.  Normally, only internal methods set the
last line.
.Sh "login \- perform standard login"
.PP
.Vb 1
\&    $ok = $obj->login($username, $password);
.Ve
.Vb 4
\&    $ok = $obj->login(Name     => $username,
\&                      Password => $password,
\&                      [Prompt  => $match,]
\&                      [Timeout => $secs,]);
.Ve
This method performs a standard login by waiting for a login prompt and
responding with \fI$username\fR, then waiting for the password prompt and
responding with \fI$password\fR, and then waiting for the command
interpreter prompt.  If any of the prompts sent don't match what's
expected, the method will timeout \- unless timeout is turned off.
.PP
Login prompts must match either of the patterns:
.PP
.Vb 2
\&    /login[: ]*$/i
\&    /username[: ]*$/i
.Ve
Password prompts must match the pattern:
.PP
.Vb 1
\&    /password[: ]*$/i
.Ve
The command interpreter prompt must match the current value of
\fBprompt()\fR.
.PP
Optional named arguments are provided to override the current settings
of prompt and timeout.
.Sh "max_buffer_length \- maximum size of input buffer"
.PP
.Vb 1
\&    $len = $obj->max_buffer_length;
.Ve
.Vb 1
\&    $prev = $obj->max_buffer_length($len);
.Ve
This method designates the maximum size of the input buffer.  An error
is generated when a read causes the buffer to exceed this limit.  The
default value is 1,048,576 bytes (1MB).  The input buffer can grow
much larger than the block size when you read using \fBgetline()\fR or
\fBwaitfor()\fR and the data stream contains no newlines or matching
waitfor patterns.
.PP
With no argument this method returns the current maximum buffer length
set in the object.  With an argument it sets the maximum buffer length
to \fI$len\fR and returns the previous value.
.Sh "open \- connect to host and port"
.PP
.Vb 1
\&    $ok = $obj->open($host);
.Ve
.Vb 3
\&    $ok = $obj->open([Host    => $host,]
\&                     [Port    => $port,]
\&                     [Timeout => $secs,]);
.Ve
This method opens a \s-1TCP\s0 connection to \fI$port\fR on \fI$host\fR.  If either
argument is missing then the current value of \fBhost()\fR or \fBport()\fR
is used.
.PP
An optional named argument is provided to override the current setting
of timeout.
.PP
Timeouts don't work for this method on machines that don't implement
\s-1SIGALRM\s0.  For those machines, an error is returned when the system
reaches its own time-out while trying to connect.
.PP
A side effect of this method is to reset the alarm interval associated
with \s-1SIGALRM\s0.
.Sh "output_field_separator \- field separator for print"
.PP
.Vb 1
\&    $ofs = $obj->output_field_separator;
.Ve
.Vb 1
\&    $prev = $obj->output_field_separator($ofs);
.Ve
This method designates the output field separator for \fBprint()\fR.
Ordinarily the print method simply prints out the comma separated
fields you specify.  Set this to specify what's printed between
fields.
.PP
With no argument this method returns the current output field
separator set in the object.  With an argument it sets the output
field separator to \fI$ofs\fR and returns the previous value.
.Sh "output_log \- log all output"
.PP
.Vb 1
\&    $fh = $obj->output_log;
.Ve
.Vb 1
\&    $fh = $obj->output_log($fh);
.Ve
.Vb 1
\&    $fh = $obj->output_log($filename);
.Ve
This method starts or stops logging of output.  This is useful when
debugging.  Also see \fBdump_log()\fR.  Because most command interpreters
echo back commands received, its likely all your output would also be
in an input log.  See \fBinput_log()\fR.  Note that output logging occurs
before newline translation.  See \fBbinmode()\fR for details on newline
translation.
.PP
If no argument is given, the log filehandle is returned.  A null
string indicates logging is off.
.PP
To stop logging, use a null string as an argument.
.PP
If an open filehandle is given, it is used for logging and returned.
Otherwise, the argument is assumed to be the name of a file, the file
is opened for logging and a filehandle to it is returned.
.Sh "output_record_separator \- output line delimiter"
.PP
.Vb 1
\&    $ors = $obj->output_record_separator;
.Ve
.Vb 1
\&    $prev = $obj->output_record_separator($ors);
.Ve
This method designates the output record separator for \fBprint()\fR.
Ordinarily the print operator simply prints out the comma separated
fields you specify, with no trailing newline or record separator
assumed.  Set this variable to specify what's printed at the end of
the print.
.PP
Note: the output record separator is set to \fB\en\fR by default, so
there's no need to append all your commands with a newline.
.PP
With no argument this method returns the current output record
separator set in the object.  With an argument it sets the output
record separator to \fI$ors\fR and returns the previous value.
.Sh "port \- remote port"
.PP
.Vb 1
\&    $port = $obj->port;
.Ve
.Vb 1
\&    $prev = $obj->port($port);
.Ve
This method designates the remote \s-1TCP\s0 port.  With no argument this
method returns the current port number.  With an argument it sets the
current port number to \fI$port\fR and returns the previous port.  If
\fI$port\fR is a service name, then first it's converted to a port number
using the perl function \fBgetservbyname()\fR.
.Sh "print \- write to object"
.PP
.Vb 1
\&    $ok = $obj->print(@list);
.Ve
This method prints a string or a comma-separated list of strings to
the opened object and returns non-zero if all data was successfully
written.
.PP
By default, the \fBoutput_record_separator()\fR is set to \fB\en\fR in order
to have your commands automatically end with a newline.  In most cases
your output is being read by a command interpreter which won't accept
a command until newline is read.  This is similar to someone typing a
command and hitting the return key.
.PP
On failure, it's possible that some data was written.  If you choose
to try and recover from a print timing-out, use \fBprint_length()\fR to
determine how much was written before timeout occurred.
.Sh "print_length \- number of bytes written by print"
.PP
.Vb 1
\&    $num = $obj->print_length;
.Ve
This returns the number of bytes successfully written by the most
recent \fBprint()\fR.
.Sh "prompt \- pattern to match a prompt"
.PP
.Vb 1
\&    $matchop = $obj->prompt;
.Ve
.Vb 1
\&    $prev = $obj->prompt($matchop);
.Ve
This method sets the pattern used to find a prompt in the input
stream.  It must be a string representing a valid perl pattern match
operator.  The methods \fBlogin()\fR and \fBcmd()\fR try to read until
matching the prompt.  If the pattern chosen doesn't match what's
sent, then it's likely those commands will timeout.
.PP
With no argument this method returns the prompt set in the object.
With an argument it sets the prompt to \fI$matchop\fR and returns the
previous value.
.PP
The default prompt is \*(L'/[$%#>] $/\*(R'
.PP
Always use single quotes to construct \fI$matchop\fR to avoid unintended
backslash interpretation.  Using single quotes, you only need add
extra backslashes to quote patterns containing \fB\e\*(R'\fR or \fB\e\e\fR.
.Sh "telnetmode \- turn off/on telnet command interpretation"
.PP
.Vb 1
\&    $prev = $obj->telnet($mode);
.Ve
This method controls whether or not telnet commands in the data stream
are recognized and handled.  The telnet protocol uses certain
character sequences sent in the data stream to control the session.
If the port you're connecting to isn't using the telnet protocol, then
you should turn this mode off.  The default is \fIon\fR.
.PP
If \fI$mode\fR is \fB0\fR then telnet mode is off.  If \fI$mode\fR is missing
or \fB1\fR then telnet mode is on.
.Sh "timed_out \- timeout indicator"
.PP
.Vb 1
\&    $boolean = $obj->timed_out;
.Ve
.Vb 1
\&    $prev = $obj->timed_out($boolean);
.Ve
This method indicates if a previous read or write method timed-out.
.PP
With no argument this method returns true if a previous method
timed-out.  With an argument it sets the indicator.  Generally this is
used by internal methods to clear it.
.Sh "timeout \- I/O timeout interval"
.PP
.Vb 1
\&    $secs = $obj->timeout;
.Ve
.Vb 1
\&    $prev = $obj->timeout($secs);
.Ve
This method sets the timeout interval that's used when performing I/O
or connecting to a port.  When a method doesn't complete within the
timeout interval then it's an error and the error mode action is
performed.
.PP
The timeout may be expressed as a relative or absolute value.  If
\fI$secs\fR is greater than or equal to the time the program was started,
as determined by $^T, then it's the absolute time when timeout occurs.
Also see the perl function \fBtime()\fR.  A relative timeout happens
\fI$secs\fR from when the I/O method begins.
.PP
If \fI$secs\fR is \fB0\fR then timeout occurs if the data cannot be
immediately read or written.  Use the undefined value to turn off
timing-out.
.PP
With no argument this method returns the timeout set in the object.
With an argument it sets the timeout to \fI$secs\fR and returns the
previous value.
.Sh "watchfor \- wait for pattern in the input"
.PP
.Vb 4
\&    $ok = $obj->waitfor($matchop);
\&    $ok = $obj->waitfor([Match   => $matchop,]
\&                        [String  => $string,]
\&                        [Timeout => $secs,]);
.Ve
.Vb 4
\&    ($prematch, $match) = $obj->waitfor($matchop);
\&    ($prematch, $match) = $obj->waitfor([Match   => $matchop,]
\&                                        [String  => $string,]
\&                                        [Timeout => $secs,]);
.Ve
This method reads until a pattern match or string is found in the
input stream.  All the characters before and including the match are
removed from the input stream.  On eof an undefined value is returned.
On timeout or other errors the error mode action is performed.
.PP
In an array context the characters before the match and the matched
characters are returned in \fI$prematch\fR and \fI$match\fR.
.PP
You can specify more than one pattern or string by simply providing
multiple \fBMatch\fR and/or \fBString\fR named arguments.  A \fI$matchop\fR
must be a string representing a valid perl pattern match operator.
The \fI$string\fR is just a substring to find in the input stream.
.PP
An optional named argument is provided to override the current setting
of timeout.
.PP
Always use single quotes to construct \fI$matchop\fR to avoid unintended
backslash interpretation.  Using single quotes, you only need add
extra backslashes to quote patterns containing \fB\e\*(R'\fR or \fB\e\e\fR.
.SH "SEE ALSO"
.Ip "\(bu" 2
\s-1RFC\s0 854 \- \s-1TELNET\s0 Protocol Specification
.Ip "\(bu" 2
\s-1RFC\s0 1143 \- The Q Method of Implementing \s-1TELNET\s0 Option Negotiation
.Ip "\(bu" 2
\s-1TELNET\s0 Options
.SH "EXAMPLES"
This example gets the current weather forecast for Brainerd, Minnesota.
.PP
.Vb 2
\&    use Net::Telnet ();
\&    my($forecast, $t);
.Ve
.Vb 1
\&    $t = new Net::Telnet (-host => "rainmaker.wunderground.com");
.Ve
.Vb 3
\&    ## Wait for first prompt and "hit return".
\&    $t->waitfor('/continue:.*$/');
\&    $t->print("");
.Ve
.Vb 3
\&    ## Wait for second prompt and respond with city code.
\&    $t->waitfor('/city code:.*$/');
\&    $t->print("BRD");
.Ve
.Vb 3
\&    ## Read and print the first page of forecast.
\&    ($forecast) = $t->waitfor('/[ \et]+press return to continue/i');
\&    print $forecast;
.Ve
.Vb 1
\&    exit;
.Ve
This example checks a POP server to see if you have mail.
.PP
.Vb 2
\&    use Net::Telnet ();
\&    my($hostname, $line, $passwd, $pop, $username);
.Ve
.Vb 3
\&    $hostname = "your_destination_host_here";
\&    $username = "your_username_here";
\&    $passwd = "your_password_here";
.Ve
.Vb 3
\&    $pop = new Net::Telnet (-host => $hostname,
\&                            -port => 110,
\&                            -telnetmode => '');
.Ve
.Vb 3
\&    ## Read connection message.
\&    $line = $pop->getline;
\&    die $line unless $line =~ /^\e+OK/;
.Ve
.Vb 4
\&    ## Send user name.
\&    $pop->print("user $username");
\&    $line = $pop->getline;
\&    die $line unless $line =~ /^\e+OK/;
.Ve
.Vb 4
\&    ## Send password.
\&    $pop->print("pass $passwd");
\&    $line = $pop->getline;
\&    die $line unless $line =~ /^\e+OK/;
.Ve
.Vb 4
\&    ## Request status of messages.
\&    $pop->print("list");
\&    $line = $pop->getline;
\&    print $line;
.Ve
.Vb 1
\&    exit;
.Ve
Here's an example you can use to down load a file of any type.  The
file is read from the remote host's standard output using cat.  To
prevent any output processing, the remote host's standard output is
put in raw mode using the Bourne shell.  The Bourne shell is used
because some shells, notably tcsh, prevent changing tty modes.  Upon
completion, FTP style statistics are printed to stderr.
.PP
.Vb 4
\&    use Net::Telnet;
\&    my($block, $filename, $host, $hostname, $k_per_sec, $line,
\&       $num_read, $passwd, $prevblock, $prompt, $size, $size_bsd,
\&       $size_sysv, $start_time, $total_time, $username);
.Ve
.Vb 4
\&    $hostname = "your_destination_host_here";
\&    $username = "your_username_here";
\&    $passwd = "your_password_here";
\&    $filename = "your_download_file_here";
.Ve
.Vb 5
\&    ## Connect and login.
\&    $host = new Net::Telnet (Host => $hostname,
\&                             Timeout => 30,
\&                             Prompt => '/[%#>] $/');
\&    $host->login($username, $passwd);
.Ve
.Vb 4
\&    ## Make sure prompt won't match anything in send data.
\&    $prompt = '_funkyPrompt_';
\&    $host->prompt("/$prompt\e$/");
\&    $host->cmd("set prompt = '$prompt'");
.Ve
.Vb 12
\&    ## Get size of file.
\&    ($line) = $host->cmd("/usr/bin/ls -l $filename");
\&    ($size_bsd, $size_sysv) = (split ' ', $line)[3,4];
\&    if ($size_sysv =~ /^\ed+$/) {
\&        $size = $size_sysv;
\&    }
\&    elsif ($size_bsd =~ /^\ed+$/) {
\&        $size = $size_bsd;
\&    }
\&    else {
\&        die "$filename: no such file on $hostname";
\&    }
.Ve
.Vb 5
\&    ## Start sending the file.
\&    binmode STDOUT;
\&    $host->binmode;
\&    $host->print("/usr/bin/sh -c 'stty raw; cat $filename'");
\&    $host->getline;    # discard echoed back line
.Ve
.Vb 13
\&    ## Read file a block at a time.
\&    $num_read = 0;
\&    $prevblock = '';
\&    $start_time = time;
\&    while (($block = $host->get) and ($block !~ /$prompt$/o)) {
\&        if (length $block >= length $prompt) {
\&            print $prevblock;
\&            $num_read += length $prevblock;
\&            $prevblock = $block;
\&        }
\&        else {
\&            $prevblock .= $block;
\&        }
.Ve
.Vb 2
\&    }
\&    $host->close;
.Ve
.Vb 7
\&    ## Print last block without trailing prompt.
\&    $prevblock .= $block;
\&    $prevblock =~ s/$prompt$//;
\&    print $prevblock;
\&    $num_read += length $prevblock;
\&    die "error: expected size $size, received size $num_read\en"
\&        unless $num_read == $size;
.Ve
.Vb 6
\&    ## Print totals.
\&    $total_time = (time - $start_time) || 1;
\&    $k_per_sec = ($size / 1024) / $total_time;
\&    $k_per_sec = sprintf "%3.1f", $k_per_sec;
\&    warn("$num_read bytes received in $total_time seconds ",
\&         "($k_per_sec Kbytes/s)\en");
.Ve
.Vb 1
\&    exit;
.Ve
Here's an example that shows how to talk to a program that
must communicate via a terminal.  In this case we're talking
to the telnet program via a pseudo-terminal.  We use the
Comm package to start the telnet program and return a
filehandle to the pseudo-terminal.  This example sends some
initial commands and then allows the user to type commands
to the telnet session.
.PP
.Vb 3
\&    use Net::Telnet;
\&    my($comm_pty, $host, $hostname, $passwd, $pty,
\&       $username, @lines);
.Ve
.Vb 3
\&    $hostname = "your_host_here";
\&    $username = "your_name_here";
\&    $passwd = "your_passwd_here";
.Ve
.Vb 4
\&    ## Start the telnet program so we can talk to it via a
\&    ## pseudo-terminal.
\&    {
\&        local $^W = 0;  # Comm.pl isn't warning clean
.Ve
.Vb 5
\&        require "Comm.pl";
\&        &Comm::init("close_it", "interact",
\&                    "open_proc", "stty_raw", "stty_sane");
\&        $comm_pty = &open_proc("telnet $hostname")
\&            or die "open_proc failed";
.Ve
.Vb 8
\&        ## Unfortunately the Comm package doesn't
\&        ## return us a fully qualified filehandle.  We
\&        ## must keep the filehandle Comm returned for
\&        ## its use and we must build another filehandle
\&        ## qualified with the current package for our
\&        ## use.
\&        $pty = "main::" . $comm_pty;
\&    }
.Ve
.Vb 13
\&    ## Obtain a new Net::Telnet object that does I/O to the
\&    ## pseudo-terminal attached to the running telnet
\&    ## program.  The "Telnetmode" is "off" because we're
\&    ## not talking directly to a telnet port as we normally
\&    ## do, we're talking to a pseudo-terminal.  The
\&    ## "Output_record_separator" is now a carriage-return
\&    ## because that's what you'd normally hit when you get
\&    ## done typing a line at a terminal.
\&    $host = new Net::Telnet (Fhopen => $pty,
\&                             Timeout => 10,
\&                             Prompt => '/[%#>] $/',
\&                             Telnetmode => 0,
\&                             Output_record_separator => "\er");
.Ve
.Vb 4
\&    ## Issue some commands.
\&    $host->login($username, $passwd);
\&    $host->cmd("setenv DISPLAY $ENV{DISPLAY}");
\&    print $host->cmd("who");
.Ve
.Vb 5
\&    ## Allow the user to interact with telnet program until
\&    ## they exit.
\&    {
\&        no strict 'subs';  # so we can refer to STDIN
\&        local $^W = 0;     # Comm.pl isn't warning clean
.Ve
.Vb 5
\&        &stty_raw(STDIN);
\&        &interact($comm_pty);
\&        &stty_sane(STDIN);
\&        &close_it($comm_pty);
\&    }
.Ve
.Vb 2
\&    print "Exited telnet\en";
\&    exit;
.Ve
.SH "AUTHOR"
Jay Rogers <jay@rgrs.com>
.SH "COPYRIGHT"
Copyright (c) 1997 Jay Rogers. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

.rn }` ''
.IX Title "lib::Net::Telnet 3"
.IX Name "Net::Telnet - interact with TELNET port or other TCP ports"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "METHODS"

.IX Subsection "new \- create a new Net::Telnet object"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "binmode \- turn off/on newline translation"

.IX Subsection "break \- send \s-1TELNET\s0 break character"

.IX Subsection "close \- close object"

.IX Subsection "cmd \- issue command and retrieve output"

.IX Subsection "dump_log \- log all I/O in dump format"

.IX Subsection "eof \- end of file read indicator"

.IX Subsection "errmode \- set action to perform on error"

.IX Subsection "errmsg \- most recent error message"

.IX Subsection "error \- perform the error mode action"

.IX Subsection "fhopen \- use an existing open filehandle"

.IX Subsection "get \- read block of data"

.IX Subsection "getline \- read next line"

.IX Subsection "getlines \- read next lines"

.IX Subsection "host \- name of remote host"

.IX Subsection "input_log \- log all input"

.IX Subsection "input_record_separator \- input line delimiter"

.IX Subsection "lastline \- the lastline read"

.IX Subsection "login \- perform standard login"

.IX Subsection "max_buffer_length \- maximum size of input buffer"

.IX Subsection "open \- connect to host and port"

.IX Subsection "output_field_separator \- field separator for print"

.IX Subsection "output_log \- log all output"

.IX Subsection "output_record_separator \- output line delimiter"

.IX Subsection "port \- remote port"

.IX Subsection "print \- write to object"

.IX Subsection "print_length \- number of bytes written by print"

.IX Subsection "prompt \- pattern to match a prompt"

.IX Subsection "telnetmode \- turn off/on telnet command interpretation"

.IX Subsection "timed_out \- timeout indicator"

.IX Subsection "timeout \- I/O timeout interval"

.IX Subsection "watchfor \- wait for pattern in the input"

.IX Header "SEE ALSO"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "EXAMPLES"

.IX Header "AUTHOR"

.IX Header "COPYRIGHT"

