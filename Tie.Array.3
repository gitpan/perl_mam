.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Tie::Array 3 "perl 5.005, patch 53" "7/Feb/98" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Tie::Array \- base class for tied arrays
.SH "SYNOPSIS"
.PP
.Vb 21
\&    package NewArray;
\&    use Tie::Array;
\&    @ISA = ('Tie::Array');
\&                       
\&    # mandatory methods
\&    sub TIEARRAY { ... }  
\&    sub FETCH { ... }     
\&    sub FETCHSIZE { ... } 
\&        
\&    sub STORE { ... }        # mandatory if elements writeable
\&    sub STORESIZE { ... }    # mandatory if elements can be added/deleted
\&                               
\&    # optional methods - for efficiency
\&    sub CLEAR { ... }  
\&    sub PUSH { ... } 
\&    sub POP { ... } 
\&    sub SHIFT { ... } 
\&    sub UNSHIFT { ... } 
\&    sub SPLICE { ... } 
\&    sub EXTEND { ... } 
\&    sub DESTROY { ... }
.Ve
.Vb 4
\&    package NewStdArray;
\&    use Tie::Array;
\&    
\&    @ISA = ('Tie::StdArray');
.Ve
.Vb 1
\&    # all methods provided by default
.Ve
.Vb 1
\&    package main;
.Ve
.Vb 3
\&    $object = tie @somearray,Tie::NewArray;
\&    $object = tie @somearray,Tie::StdArray;
\&    $object = tie @somearray,Tie::NewStdArray;
.Ve
.SH "DESCRIPTION"
This module provides methods for array-tying classes. See
the \fIperltie\fR manpage for a list of the functions required in order to tie an array
to a package. The basic \fBTie::Array\fR package provides stub \f(CWDELETE\fR 
and \f(CWEXTEND\fR methods, and implementations of \f(CWPUSH\fR, \f(CWPOP\fR, \f(CWSHIFT\fR, 
\f(CWUNSHIFT\fR, \f(CWSPLICE\fR and \f(CWCLEAR\fR in terms of basic \f(CWFETCH\fR, \f(CWSTORE\fR, 
\f(CWFETCHSIZE\fR, \f(CWSTORESIZE\fR.
.PP
The \fBTie::StdArray\fR package provides efficient methods required for tied arrays 
which are implemented as blessed references to an \*(L"inner\*(R" perl array.
It inherits from \fBTie::Array\fR, and should cause tied arrays to behave exactly 
like standard arrays, allowing for selective overloading of methods. 
.PP
For developers wishing to write their own tied arrays, the required methods
are briefly defined below. See the the \fIperltie\fR manpage section for more detailed
descriptive, as well as example code:
.Ip "\s-1TIEARRAY\s0 classname, \s-1LIST\s0" 5
The class method is invoked by the command \f(CWtie @array, classname\fR. Associates
an array instance with the specified class. \f(CWLIST\fR would represent
additional arguments (along the lines of the \fIAnyDBM_File\fR manpage and compatriots) needed
to complete the association. The method should return an object of a class which
provides the methods below. 
.Ip "\s-1STORE\s0 this, index, value" 5
Store datum \fIvalue\fR into \fIindex\fR for the tied array assoicated with
object \fIthis\fR. If this makes the array larger then
class's mapping of \f(CWundef\fR should be returned for new positions.
.Ip "\s-1FETCH\s0 this, index" 5
Retrieve the datum in \fIindex\fR for the tied array assoicated with
object \fIthis\fR.
.Ip "\s-1FETCHSIZE\s0 this" 5
Returns the total number of items in the tied array assoicated with
object \fIthis\fR. (Equivalent to \f(CWscalar(@array)\fR).
.Ip "\s-1STORESIZE\s0 this, count" 5
Sets the total number of items in the tied array assoicated with
object \fIthis\fR to be \fIcount\fR. If this makes the array larger then
class's mapping of \f(CWundef\fR should be returned for new positions.
If the array becomes smaller then entries beyond count should be
deleted. 
.Ip "\s-1EXTEND\s0 this, count" 5
Informative call that array is likely to grow to have \fIcount\fR entries.
Can be used to optimize allocation. This method need do nothing.
.Ip "\s-1CLEAR\s0 this" 5
Clear (remove, delete, ...) all values from the tied array assoicated with
object \fIthis\fR.
.Ip "\s-1DESTROY\s0 this" 5
Normal object destructor method.
.Ip "\s-1PUSH\s0 this, \s-1LIST\s0 " 5
Append elements of \s-1LIST\s0 to the array.
.Ip "\s-1POP\s0 this" 5
Remove last element of the array and return it.
.Ip "\s-1SHIFT\s0 this" 5
Remove the first element of the array (shifting other elements down)
and return it.
.Ip "\s-1UNSHIFT\s0 this, \s-1LIST\s0 " 5
Insert \s-1LIST\s0 elements at the begining of the array, moving existing elements
up to make room.
.Ip "\s-1SPLICE\s0 this, offset, length, \s-1LIST\s0" 5
Perform the equivalent of \f(CWsplice\fR on the array. 
.Sp
\fIoffset\fR is optional and defaults to zero, negative values count back 
from the end of the array. 
.Sp
\fIlength\fR is optional and defaults to rest of the array.
.Sp
\fI\s-1LIST\s0\fR may be empty.
.Sp
Returns a list of the original \fIlength\fR elements at \fIoffset\fR.
.SH "CAVEATS"
There is no support at present for tied \f(CW@ISA\fR. There is a potential conflict 
between magic entries needed to notice setting of \f(CW@ISA\fR, and those needed to
implement \*(L'tie\*(R'.   
.PP
Very little consideration has been given to the behaviour of tied arrays
when \f(CW$[\fR is not default value of zero.
.SH "AUTHOR"
Nick Ing-Simmons <nik@tiuk.ti.com>

.rn }` ''
.IX Title "Tie::Array 3"
.IX Name "Tie::Array - base class for tied arrays"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "\s-1TIEARRAY\s0 classname, \s-1LIST\s0"

.IX Item "\s-1STORE\s0 this, index, value"

.IX Item "\s-1FETCH\s0 this, index"

.IX Item "\s-1FETCHSIZE\s0 this"

.IX Item "\s-1STORESIZE\s0 this, count"

.IX Item "\s-1EXTEND\s0 this, count"

.IX Item "\s-1CLEAR\s0 this"

.IX Item "\s-1DESTROY\s0 this"

.IX Item "\s-1PUSH\s0 this, \s-1LIST\s0 "

.IX Item "\s-1POP\s0 this"

.IX Item "\s-1SHIFT\s0 this"

.IX Item "\s-1UNSHIFT\s0 this, \s-1LIST\s0 "

.IX Item "\s-1SPLICE\s0 this, offset, length, \s-1LIST\s0"

.IX Header "CAVEATS"

.IX Header "AUTHOR"

