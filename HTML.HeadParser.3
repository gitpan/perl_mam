.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::HTML::HeadParser 3 "perl 5.004, patch 55" "26/Jun/97" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
HTML::HeadParser \- Parse <HEAD> section of a HTML document
.SH "SYNOPSIS"
.PP
.Vb 3
\& require HTML::HeadParser;
\& $p = HTML::HeadParser->new;
\& $p->parse($text) and  print "not finished";
.Ve
.Vb 3
\& $p->header('Title')          # to access <title>....</title>
\& $p->header('Content-Base')   # to access <base href="http://...">
\& $p->header('Foo')            # to access <meta http-equiv="Foo" content="...">
.Ve
.SH "DESCRIPTION"
The \fIHTML::HeadParser\fR is a specialized (and lightweight)
\fIHTML::Parser\fR that will only parse the <HEAD>...</HEAD> section of a
HTML document.  The \fIparse()\fR and \fIparse_file()\fR methods will return a
FALSE value as soon as a <BODY> element is found, and should not be
called again after this.
.PP
The \fIHTML::HeadParser\fR constructor takes an optional \fIHTTP::Headers\fR
object reference as argument.  The parser will update this header
object as the various <HEAD> elements are recognized.  If no
header is given we will create an internal (and initially empty)
header object.  This header object can be accessed with the \fIheader()\fR
method.
.PP
The following header fields are initialized from elements found in the
<HEAD> section of the HTML document:
.Ip "Content-Base:" 4
The \fIContent-Base\fR header is initialized from the <base
href=\*(R"..."> element.
.Ip "Title:" 4
The \fITitle\fR header is initialized from the <title>...</title>
element.
.Ip "Isindex:" 4
The \fIIsindex\fR header will be added if there is a <isindex>
element in the <head>.  The header value is initialized from the
\fIprompt\fR attribute if it is present.  If not \fIprompt\fR attribute is
given it will have \*(L'?\*(R' as the value.
.Ip "X\-Meta-Foo" 4
All <meta> elements will initialize headers with the prefix
\*(L"X\-Meta-\*(R".  If the element contains a \fIhttp-equiv\fR attribute, then it
will be honored as the header name.
.SH "METHODS"
The following methods (in addition to those provided by the
superclass) are available:
.Ip "$hp = \s-1HTML::\s0HeadParser->new( [$header] )" 4
.Ip "$hp->parse( $text )" 4
Parses some \s-1HTML\s0 text (see \s-1HTML::\s0Parser->\fIparse()\fR) but will return
\s-1FALSE\s0 as soon as parsing should end.
.Ip "$hp->header;" 4
Returns a reference to the \s-1HTML::\s0Header object.
.Ip "$hp->header( $key )" 4
Returns a header value.
.Ip "$hp->as_string;" 4
Same as \f(CW$hp\fR\->header->as_string
.SH "EXAMPLES"
.Sp
.Vb 9
\& $h = HTTP::Headers->new;
\& $p = HTML::HeadParser->new($h);
\& $p->parse(<<EOT);
\& <title>Stupid example</title>
\& <base href="http://www.sn.no/libwww-perl/">
\& Normal text starts here.
\& EOT
\& undef $p;
\& print $h->title;   # should print "Stupid example"
.Ve
.SH "SEE ALSO"
the \fIHTML::Parser\fR manpage, the \fIHTTP::Headers\fR manpage
.SH "COPYRIGHT"
Copyright 1996-1997 Gisle Aas. All rights reserved.
.Sp
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
Gisle Aas <aas@sn.no>

.rn }` ''
.IX Title "lib::HTML::HeadParser 3"
.IX Name "HTML::HeadParser - Parse <HEAD> section of a HTML document"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "Content-Base:"

.IX Item "Title:"

.IX Item "Isindex:"

.IX Item "X\-Meta-Foo"

.IX Header "METHODS"

.IX Item "$hp = \s-1HTML::\s0HeadParser->new( [$header] )"

.IX Item "$hp->parse( $text )"

.IX Item "$hp->header;"

.IX Item "$hp->header( $key )"

.IX Item "$hp->as_string;"

.IX Header "EXAMPLES"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

.IX Header "AUTHOR"

