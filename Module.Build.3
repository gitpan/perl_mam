.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Module::Build 3"
.TH Module::Build 3 "2003-09-20" "perl v5.8.2" "User Contributed Perl Documentation"
.SH "NAME"
Module::Build \- Build and install Perl modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Standard process for building & installing modules:
.PP
.Vb 4
\&   perl Build.PL
\&   ./Build
\&   ./Build test
\&   ./Build install
.Ve
.PP
Or, if you're on a platform (like \s-1DOS\s0 or Windows) that doesn't like
the \*(L"./\*(R" notation, you can do this:
.PP
.Vb 4
\&   perl Build.PL
\&   perl Build
\&   perl Build test
\&   perl Build install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Module::Build\*(C'\fR is a system for building, testing, and installing
Perl modules.  It is meant to be a replacement for
\&\f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR.  Developers may alter the behavior of the
module through subclassing in a much more straightforward way than
with \f(CW\*(C`MakeMaker\*(C'\fR.  It also does not require a \f(CW\*(C`make\*(C'\fR on your system
\&\- most of the \f(CW\*(C`Module::Build\*(C'\fR code is pure-perl and written in a very
cross-platform way.  In fact, you don't even need a shell, so even
platforms like MacOS (traditional) can use it fairly easily.  Its only
prerequisites are modules that are included with perl 5.6.0, and it
works fine on perl 5.005 if you can install a few additional modules.
.PP
See \s-1MOTIVATIONS\s0 for more comparisons between \f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR
and \f(CW\*(C`Module::Build\*(C'\fR.
.PP
To install \f(CW\*(C`Module::Build\*(C'\fR, and any other module that uses
\&\f(CW\*(C`Module::Build\*(C'\fR for its installation process, do the following:
.PP
.Vb 4
\&  perl Build.PL       # 'Build.PL' script creates the 'Build' script
\&  ./Build             # Need ./ to ensure we're using this "Build" script
\&  ./Build test        # and not another one that happens to be in the PATH
\&  ./Build install
.Ve
.PP
This illustrates initial configuration and the running of three
\&'actions'.  In this case the actions run are 'build' (the default
action), 'test', and 'install'.  Actions defined so far include:
.PP
.Vb 11
\&  build                          docs        
\&  clean                          fakeinstall 
\&  code                           help        
\&  diff                           install     
\&  dist                           manifest    
\&  distcheck                      ppd         
\&  distclean                      realclean   
\&  distdir                        skipcheck   
\&  distmeta                       test        
\&  distsign                       testdb      
\&  disttest                       versioninstall
.Ve
.PP
You can run the 'help' action for a complete list of actions.
.PP
When creating a \f(CW\*(C`Build.PL\*(C'\fR script for a module, something like the
following code will typically be used:
.PP
.Vb 12
\&  use Module::Build;
\&  my $build = Module::Build->new
\&    (
\&     module_name => 'Foo::Bar',
\&     license => 'perl',
\&     requires => {
\&                  'perl'           => '5.6.1',
\&                  'Some::Module'   => '1.23',
\&                  'Other::Module'  => '>= 1.2, != 1.5, < 2.0',
\&                 },
\&    );
\&  $build->create_build_script;
.Ve
.PP
A simple module could get away with something as short as this for its
\&\f(CW\*(C`Build.PL\*(C'\fR script:
.PP
.Vb 5
\&  use Module::Build;
\&  Module::Build->new(
\&     module_name => 'Foo::Bar',
\&     license => 'perl',
\&  )->create_build_script;
.Ve
.PP
The model used by \f(CW\*(C`Module::Build\*(C'\fR is a lot like the \f(CW\*(C`MakeMaker\*(C'\fR
metaphor, with the following correspondences:
.PP
.Vb 5
\&   In Module::Build                 In ExtUtils::MakeMaker
\&  ---------------------------      ------------------------
\&   Build.PL (initial script)        Makefile.PL (initial script)
\&   Build (a short perl script)      Makefile (a long Makefile)
\&   _build/ (saved state info)       various config text in the Makefile
.Ve
.PP
Any customization can be done simply by subclassing \f(CW\*(C`Module::Build\*(C'\fR
and adding a method called (for example) \f(CW\*(C`ACTION_test\*(C'\fR, overriding
the default 'test' action.  You could also add a method called
\&\f(CW\*(C`ACTION_whatever\*(C'\fR, and then you could perform the action \f(CW\*(C`Build
whatever\*(C'\fR.
.PP
For information on providing backward compatibility with
\&\f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR, see Module::Build::Compat.
.SH "METHODS"
.IX Header "METHODS"
I list here some of the most important methods in \f(CW\*(C`Module::Build\*(C'\fR.
Normally you won't need to deal with these methods unless you want to
subclass \f(CW\*(C`Module::Build\*(C'\fR.  But since one of the reasons I created
this module in the first place was so that subclassing is possible
(and easy), I will certainly write more docs as the interface
stabilizes.
.IP "\fInew()\fR" 4
.IX Item "new()"
Creates a new Module::Build object.  Arguments to the \fInew()\fR method are
listed below.  Most arguments are optional, but you must provide
either the \f(CW\*(C`module_name\*(C'\fR argument, or \f(CW\*(C`dist_name\*(C'\fR and one of
\&\f(CW\*(C`dist_version\*(C'\fR or \f(CW\*(C`dist_version_from\*(C'\fR.  In other words, you must
provide enough information to determine both a distribution name and
version.
.RS 4
.IP "module_name" 4
.IX Item "module_name"
The \f(CW\*(C`module_name\*(C'\fR is a shortcut for setting default values of
\&\f(CW\*(C`dist_name\*(C'\fR and \f(CW\*(C`dist_version_from\*(C'\fR, reflecting the fact that the
majority of \s-1CPAN\s0 distributions are centered around one \*(L"main\*(R" module.
For instance, if you set \f(CW\*(C`module_name\*(C'\fR to \f(CW\*(C`Foo::Bar\*(C'\fR, then
\&\f(CW\*(C`dist_name\*(C'\fR will default to \f(CW\*(C`Foo\-Bar\*(C'\fR and \f(CW\*(C`dist_version_from\*(C'\fR will
default to \f(CW\*(C`lib/Foo/Bar.pm\*(C'\fR.  \f(CW\*(C`dist_version_from\*(C'\fR will in turn be
used to set \f(CW\*(C`dist_version\*(C'\fR.
.Sp
Setting \f(CW\*(C`module_name\*(C'\fR won't override a \f(CW\*(C`dist_*\*(C'\fR parameter you
specify explicitly.
.IP "dist_name" 4
.IX Item "dist_name"
Specifies the name for this distribution.  Most authors won't need to
set this directly, they can use \f(CW\*(C`module_name\*(C'\fR to set \f(CW\*(C`dist_name\*(C'\fR to
a reasonable default.  However, some agglomerative distributions like
\&\f(CW\*(C`libwww\-perl\*(C'\fR or \f(CW\*(C`bioperl\*(C'\fR have names that don't correspond directly
to a module name, so \f(CW\*(C`dist_name\*(C'\fR can be set independently.
.IP "dist_version" 4
.IX Item "dist_version"
Specifies a version number for the distribution.  See \f(CW\*(C`module_name\*(C'\fR
or \f(CW\*(C`dist_version_from\*(C'\fR for ways to have this set automatically from a
\&\f(CW$VERSION\fR variable in a module.  One way or another, a version
number needs to be set.
.IP "dist_version_from" 4
.IX Item "dist_version_from"
Specifies a file to look for the distribution version in.  Most
authors won't need to set this directly, they can use \f(CW\*(C`module_name\*(C'\fR
to set it to a reasonable default.
.Sp
The version is extracted from the specified file according to the same
rules as \f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR and \f(CW\*(C`CPAN.pm\*(C'\fR.  It involves finding
the first line that matches the regular expression
.Sp
.Vb 1
\&   /([\e$*])(([\ew\e:\e']*)\ebVERSION)\eb.*\e=/
.Ve
.Sp
, \fIeval()\fR\-ing that line, then checking the value of the \f(CW$VERSION\fR
variable.  Quite ugly, really, but all the modules on \s-1CPAN\s0 depend on
this process, so there's no real opportunity to change to something
better.
.IP "license" 4
.IX Item "license"
Specifies the licensing terms of your distribution.  Valid options include:
.RS 4
.IP "perl" 4
.IX Item "perl"
The distribution may be copied and redistributed under the same terms
as perl itself (this is by far the most common licensing option for
modules on \s-1CPAN\s0).  This is a dual license, in which the user may
choose between either the \s-1GPL\s0 or the Artistic license.
.IP "gpl" 4
.IX Item "gpl"
The distribution is distributed under the terms of the Gnu General
Public License (http://www.opensource.org/licenses/gpl\-license.php).
.IP "lgpl" 4
.IX Item "lgpl"
The distribution is distributed under the terms of the Gnu Lesser
General Public License
(http://www.opensource.org/licenses/lgpl\-license.php).
.IP "artistic" 4
.IX Item "artistic"
The distribution is licensed under the Artistic License, as specified
by the \fIArtistic\fR file in the standard perl distribution.
.IP "bsd" 4
.IX Item "bsd"
The distribution is licensed under the \s-1BSD\s0 License
(http://www.opensource.org/licenses/bsd\-license.php).
.IP "open_source" 4
.IX Item "open_source"
The distribution is licensed under some other Open Source
Initiative-approved license listed at
http://www.opensource.org/licenses/ .
.IP "unrestricted" 4
.IX Item "unrestricted"
The distribution is licensed under a license that is \fBnot\fR approved
by www.opensource.org but that allows distribution without
restrictions.
.IP "restrictive" 4
.IX Item "restrictive"
The distribution may not be redistributed without special permission
from the author and/or copyright holder.
.RE
.RS 4
.Sp
Note that you must still include the terms of your license in your
documentation \- this field only lets automated tools figure out your
licensing restrictions.  Humans still need something to read.
.Sp
It is a fatal error to use a license other than the ones mentioned
above.  This is not because I wish to impose licensing terms on you \-
please let me know if you would like another license option to be
added to the list.  You may also use a license type of \f(CW\*(C`unknown\*(C'\fR if
you don't wish to specify your terms (but this is usually not a good
idea for you to do!).
.Sp
I just started out with a small set of licenses to keep things simple,
figuring I'd let people with actual working knowledge in this area
tell me what to do.  So if that's you, drop me a line.
.RE
.IP "requires" 4
.IX Item "requires"
An optional \f(CW\*(C`requires\*(C'\fR argument specifies any module prerequisites that
the current module depends on.  The prerequisites are given in a hash
reference, where the keys are the module names and the values are
version specifiers:
.Sp
.Vb 4
\& requires => {Foo::Module => '2.4',
\&              Bar::Module => 0,
\&              Ken::Module => '>= 1.2, != 1.5, < 2.0',
\&              perl => '5.6.0'},
.Ve
.Sp
These four version specifiers have different effects.  The value
\&\f(CW'2.4'\fR means that \fBat least\fR version 2.4 of \f(CW\*(C`Foo::Module\*(C'\fR must be
installed.  The value \f(CW0\fR means that \fBany\fR version of \f(CW\*(C`Bar::Module\*(C'\fR
is acceptable, even if \f(CW\*(C`Bar::Module\*(C'\fR doesn't define a version.  The
more verbose value \f(CW'>= 1.2, != 1.5, < 2.0'\fR means that
\&\f(CW\*(C`Ken::Module\*(C'\fR's version must be \fBat least\fR 1.2, \fBless than\fR 2.0,
and \fBnot equal to\fR 1.5.  The list of criteria is separated by commas,
and all criteria must be satisfied.
.Sp
A special \f(CW\*(C`perl\*(C'\fR entry lets you specify the versions of the Perl
interpreter that are supported by your module.  The same version
dependency-checking semantics are available, except that we also
understand perl's new double-dotted version numbers.
.Sp
One note: currently \f(CW\*(C`Module::Build\*(C'\fR doesn't actually \fIrequire\fR the
user to have dependencies installed, it just strongly urges.  In the
future we may require it.  There's now a \f(CW\*(C`recommends\*(C'\fR section for
things that aren't absolutely required.
.Sp
Automated tools like \s-1CPAN\s0.pm should refuse to install a module if one
of its dependencies isn't satisfied, unless a \*(L"force\*(R" command is given
by the user.  If the tools are helpful, they should also offer to
install the dependencies.
.Sp
A sysnonym for \f(CW\*(C`requires\*(C'\fR is \f(CW\*(C`prereq\*(C'\fR, to help succour people
transitioning from \f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR.  The \f(CW\*(C`requires\*(C'\fR term is
preferred, but the \f(CW\*(C`prereq\*(C'\fR term will remain valid in future
distributions.
.IP "recommends" 4
.IX Item "recommends"
This is just like the \f(CW\*(C`requires\*(C'\fR argument, except that modules listed
in this section aren't essential, just a good idea.  We'll just print
a friendly warning if one of these modules aren't found, but we'll
continue running.
.Sp
If a module is recommended but not required, all tests should still
pass if the module isn't installed.  This may mean that some tests
will be skipped if recommended dependencies aren't present.
.Sp
Automated tools like \s-1CPAN\s0.pm should inform the user when recommended
modules aren't installed, and it should offer to install them if it
wants to be helpful.
.IP "build_requires" 4
.IX Item "build_requires"
Modules listed in this section are necessary to build and install the
given module, but are not necessary for regular usage of it.  This is
actually an important distinction \- it allows for tighter control over
the body of installed modules, and facilitates correct dependency
checking on binary/packaged distributions of the module.
.IP "conflicts" 4
.IX Item "conflicts"
Modules listed in this section conflict in some serious way with the
given module.  \f(CW\*(C`Module::Build\*(C'\fR will refuse to install the given
module if
.IP "create_makefile_pl" 4
.IX Item "create_makefile_pl"
This parameter lets you use Module::Build::Compat during the
\&\f(CW\*(C`distdir\*(C'\fR (or \f(CW\*(C`dist\*(C'\fR) action to automatically create a Makefile.PL
for compatibility with ExtUtils::MakeMaker.  The parameter's value
should be one of the styles named in the Module::Build::Compat
documentation.
.IP "c_source" 4
.IX Item "c_source"
An optional \f(CW\*(C`c_source\*(C'\fR argument specifies a directory which contains
C source files that the rest of the build may depend on.  Any \f(CW\*(C`.c\*(C'\fR
files in the directory will be compiled to object files.  The
directory will be added to the search path during the compilation and
linking phases of any C or \s-1XS\s0 files.
.IP "pm_files" 4
.IX Item "pm_files"
An optional parameter specifying the set of \f(CW\*(C`.pm\*(C'\fR files in this
distribution, specified as a hash reference whose keys are the files'
locations in the distributions, and whose values are their logical
locations based on their package name, i.e. where they would be found
in a \*(L"normal\*(R" Module::Build\-style distribution.  This parameter is
mainly intended to support alternative layouts of files.
.Sp
For instance, if you have an old-style MakeMaker distribution for a
module called \f(CW\*(C`Foo::Bar\*(C'\fR and a \fIBar.pm\fR file at the top level of the
distribution, you could specify your layout in your \f(CW\*(C`Build.PL\*(C'\fR like
this:
.Sp
.Vb 5
\& my $build = Module::Build->new
\&   ( module_name => 'Foo::Bar',
\&     ...
\&     pm_files => { 'Bar.pm' => 'lib/Foo/Bar.pm' },
\&   );
.Ve
.Sp
Note that the values should include \f(CW\*(C`lib/\*(C'\fR, because this is where
they would be found in a \*(L"normal\*(R" Module::Build\-style distribution.
.Sp
Note also that the path specifications are \fIalways\fR given in
Unix-like format, not in the style of the local system.
.IP "pod_files" 4
.IX Item "pod_files"
Just like \f(CW\*(C`pm_files\*(C'\fR, but used for specifying the set of \f(CW\*(C`.pod\*(C'\fR
files in your distribution.
.IP "xs_files" 4
.IX Item "xs_files"
Just like \f(CW\*(C`pm_files\*(C'\fR, but used for specifying the set of \f(CW\*(C`.xs\*(C'\fR
files in your distribution.
.IP "PL_files" 4
.IX Item "PL_files"
An optional parameter specifying a set of \f(CW\*(C`.PL\*(C'\fR files in your
distribution.  These will be run as Perl scripts prior to processing
the rest of the files in your distribution.  They are usually used as
templates for creating other files dynamically, so that a file like
\&\f(CW\*(C`lib/Foo/Bar.pm.PL\*(C'\fR might create the file \f(CW\*(C`lib/Foo/Bar.pm\*(C'\fR.
.Sp
The files are specified with the \f(CW\*(C`.PL\*(C'\fR files as hash keys, and the
file(s) they generate as hash values, like so:
.Sp
.Vb 7
\& my $build = Module::Build->new
\&   ( module_name => 'Foo::Bar',
\&     ...
\&     PL_files => { 'lib/Bar.pm.PL' => 'lib/Bar.pm',
\&                   'lib/Foo.PL' => [ 'lib/Foo1.pm', 'lib/Foo2.pm' ],
\&                 },
\&   );
.Ve
.Sp
Note that the path specifications are \fIalways\fR given in Unix-like
format, not in the style of the local system.
.IP "script_files" 4
.IX Item "script_files"
An optional parameter specifying a set of files that should be
installed as executable perl scripts when the module is installed.
May be given as an array reference of the files, or as a hash
reference whose keys are the files (and whose values will currently be
ignored).
.Sp
The default is to install no script files \- in other words, there is
no default location where Module::Build will look for script files to
install.
.Sp
For backward compatibility, you may use the parameter \f(CW\*(C`scripts\*(C'\fR
instead of \f(CW\*(C`script_files\*(C'\fR.  Please consider this usage deprecated,
though it will continue to exist for several version releases.
.IP "autosplit" 4
.IX Item "autosplit"
An optional \f(CW\*(C`autosplit\*(C'\fR argument specifies a file which should be run
through the \f(CW\*(C`Autosplit::autosplit()\*(C'\fR function.  In general I don't
consider this a great idea, because it's not always clear that
autosplitting achieves its intended performance benefits.  It may even
harm performance in environments like mod_perl, where as much as
possible of a module's code should be loaded during startup.
.IP "dynamic_config" 4
.IX Item "dynamic_config"
A boolean flag indicating whether the \fIBuild.PL\fR file must be
executed, or whether this module can be built, tested and installed
solely from consulting its metadata file.  The default value is 0,
reflecting the fact that \*(L"most\*(R" of the modules on \s-1CPAN\s0 just need to be
copied from one place to another.  The main reason to set this to a
true value is that your module performs some dynamic configuration as
part of its build/install process.
.Sp
Currently \f(CW\*(C`Module::Build\*(C'\fR doesn't actually do anything with this flag
\&\- it's probably going to be up to tools like \f(CW\*(C`CPAN.pm\*(C'\fR to do
something useful with it.  It can potentially bring lots of security,
packaging, and convenience improvements.
.IP "add_to_cleanup" 4
.IX Item "add_to_cleanup"
An array reference of files to be cleaned up when the \f(CW\*(C`clean\*(C'\fR action
is performed.  See also the \fIadd_to_cleanup()\fR method.
.IP "sign" 4
.IX Item "sign"
If a true value is specified for this parameter, \f(CW\*(C`Module::Signature\*(C'\fR
will be used (via the 'distsign' action) to create a \s-1SIGNATURE\s0 file
for your distribution during the 'distdir' action, and to add the
\&\s-1SIGNATURE\s0 file to the \s-1MANIFEST\s0 (therefore, don't add it yourself).
.Sp
The default value is false.  In the future, the default may change to
true if you have \f(CW\*(C`Module::Signature\*(C'\fR installed on your system.
.IP "extra_compiler_flags" 4
.IX Item "extra_compiler_flags"
.PD 0
.IP "extra_linker_flags" 4
.IX Item "extra_linker_flags"
.PD
These parameters can contain array references (or strings, in which
case they will be split into arrays) to pass through to the compiler
and linker phases when compiling/linking C code.  For example, to tell
the compiler that your code is \*(C+, you might do:
.Sp
.Vb 4
\& my build = Module::Build->new(
\&     module_name          => 'Spangly',
\&     extra_compiler_flags => ['-x', 'c++'],
\& );
.Ve
.Sp
To link your \s-1XS\s0 code against glib you might write something like:
.Sp
.Vb 6
\& my build = Module::Build->new(
\&     module_name          => 'Spangly',
\&     dynamic_config       => 1,
\&     extra_compiler_flags => `glib-config --cflags`,
\&     extra_linker_flags   => `glib-config --libs`,
\& );
.Ve
.IP "dist_author" 4
.IX Item "dist_author"
This should be something like \*(L"John Doe <jdoe@example.com>\*(R".  This is
used when creating \s-1PPD\s0 files.  If this is not specified, then
\&\f(CW\*(C`Module::Build\*(C'\fR looks at the module from which it gets the
distribution's version.  If it finds a \s-1POD\s0 section marked \*(L"=head1
\&\s-1AUTHOR\s0\*(R", then it uses the contents of this section.
.IP "dist_abstract" 4
.IX Item "dist_abstract"
This should be a short description of the distribution.  This is used
when creating \s-1PPD\s0 files.  If it is not given then \f(CW\*(C`Module::Build\*(C'\fR
looks in the \s-1POD\s0 of the module from which it gets the distribution's
version.  It looks for the first line matching \f(CW\*(C`$package\es\-\es(.+)\*(C'\fR,
and uses the captured text as the abstract.
.IP "codebase" 4
.IX Item "codebase"
This can be either a single scalar string, or an array reference of
strings.  It is required when creating \s-1PPD\s0 files.  It should be a \s-1URL\s0,
or URLs, to be used as the value for the \f(CW\*(C`<CODEBASE>\*(C'\fR tag in the
generated \s-1PPD\s0.
.RE
.RS 4
.RE
.IP "\fIsubclass()\fR" 4
.IX Item "subclass()"
This creates a new \f(CW\*(C`Module::Build\*(C'\fR subclass on the fly, as described
in the \s-1SUBCLASSING\s0 section.  The caller must provide either a
\&\f(CW\*(C`class\*(C'\fR or \f(CW\*(C`code\*(C'\fR parameter, or both.  The \f(CW\*(C`class\*(C'\fR parameter
indicates the name to use for the new subclass, and defaults to
\&\f(CW\*(C`MyModuleBuilder\*(C'\fR.  The \f(CW\*(C`code\*(C'\fR parameter specifies Perl code to use
as the body of the subclass.
.IP "\fIcreate_build_script()\fR" 4
.IX Item "create_build_script()"
Creates an executable script called \f(CW\*(C`Build\*(C'\fR in the current directory
that will be used to execute further user actions.  This script is
roughly analogous (in function, not in form) to the Makefile created
by \f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR.  This method also creates some temporary
data in a directory called \f(CW\*(C`_build/\*(C'\fR.  Both of these will be removed
when the \f(CW\*(C`realclean\*(C'\fR action is performed.
.IP "add_to_cleanup(@files)" 4
.IX Item "add_to_cleanup(@files)"
You may call \f(CW\*(C`$self\->add_to_cleanup(@files)\*(C'\fR
to tell \f(CW\*(C`Module::Build\*(C'\fR that certain files should be removed when the
user performs the \f(CW\*(C`Build clean\*(C'\fR action.  I decided to provide a
dynamic method, rather than just use a static list of files, because these
static lists can get difficult to manage.  I usually prefer to keep
the responsibility for registering temporary files close to the code
that creates them.
.IP "\fIresume()\fR" 4
.IX Item "resume()"
You'll probably never call this method directly, it's only called from
the auto-generated \f(CW\*(C`Build\*(C'\fR script.  The \f(CW\*(C`new()\*(C'\fR method is only
called once, when the user runs \f(CW\*(C`perl Build.PL\*(C'\fR.  Thereafter, when
the user runs \f(CW\*(C`Build test\*(C'\fR or another action, the \f(CW\*(C`Module::Build\*(C'\fR
object is created using the \f(CW\*(C`resume()\*(C'\fR method to reinstantiate with
the settings given earlier to \f(CW\*(C`new()\*(C'\fR.
.IP "\fIcurrent()\fR" 4
.IX Item "current()"
This method returns a reasonable faxsimile of the currently-executing
\&\f(CW\*(C`Module::Build\*(C'\fR object representing the current build.  You can use
this object to query its \f(CW\*(C`notes()\*(C'\fR method, inquire about installed
modules, and so on.  This is a great way to share information between
different parts of your building process.  For instance, you can ask
the user a question during \f(CW\*(C`perl Build.PL\*(C'\fR, then use their answer
during a regression test:
.Sp
.Vb 3
\& # In Build.PL:
\& my $color = $build->prompt("What is your favorite color?");
\& $build->notes(color => $color);
.Ve
.Sp
.Vb 5
\& # In t/colortest.t:
\& use Module::Build;
\& my $build = Module::Build->current;
\& my $color = $build->notes('color');
\& ...
.Ve
.Sp
The way the \f(CW\*(C`current()\*(C'\fR method is currently implemented, there may be
slight differences between the \f(CW$build\fR object in Build.PL and the
one in \f(CW\*(C`t/colortest.t\*(C'\fR.  It is our goal to minimize these differences
in future releases of Module::Build, so please report any anomalies
you find.
.IP "\fInotes()\fR" 4
.IX Item "notes()"
.PD 0
.IP "notes($key)" 4
.IX Item "notes($key)"
.ie n .IP "notes($key => $value)" 4
.el .IP "notes($key => \f(CW$value\fR)" 4
.IX Item "notes($key => $value)"
.PD
The \f(CW\*(C`notes()\*(C'\fR value allows you to store your own persistent
information about the build, and to share that information among
different entities involved in the build.  See the example in the
\&\f(CW\*(C`current()\*(C'\fR method.
.Sp
The \f(CW\*(C`notes()\*(C'\fR method is essentally a glorified hash access.  With no
arguments, \f(CW\*(C`notes()\*(C'\fR returns a reference to the entire hash of notes.
With one argument, \f(CW\*(C`notes($key)\*(C'\fR returns the value associated with
the given key.  With two arguments, \f(CW\*(C`notes($key, $value)\*(C'\fR sets the
value associated with the given key to \f(CW$value\fR.
.ie n .IP "dispatch($action, %args)" 4
.el .IP "dispatch($action, \f(CW%args\fR)" 4
.IX Item "dispatch($action, %args)"
This method is also called from the auto-generated \f(CW\*(C`Build\*(C'\fR script.
It parses the command-line arguments into an action and an argument
list, then calls the appropriate routine to handle the action.
Currently (though this may change), an action \f(CW\*(C`foo\*(C'\fR will invoke the
\&\f(CW\*(C`ACTION_foo\*(C'\fR method.  All arguments (including everything mentioned
in \s-1ACTIONS\s0 below) are contained in the \f(CW\*(C`$self\->{args}\*(C'\fR hash
reference.
.IP "\fIos_type()\fR" 4
.IX Item "os_type()"
If you're subclassing Module::Build and some code needs to alter its
behavior based on the current platform, you may only need to know
whether you're running on Windows, Unix, MacOS, \s-1VMS\s0, etc. and not the
fine-grained value of Perl's \f(CW$^O\fR variable.  The \f(CW\*(C`os_type()\*(C'\fR method
will return a string like \f(CW\*(C`Windows\*(C'\fR, \f(CW\*(C`Unix\*(C'\fR, \f(CW\*(C`MacOS\*(C'\fR, \f(CW\*(C`VMS\*(C'\fR, or
whatever is appropriate.  If you're running on an unknown platform, it
will return \f(CW\*(C`undef\*(C'\fR \- there shouldn't be many unknown platforms
though.
.IP "\fIprereq_failures()\fR" 4
.IX Item "prereq_failures()"
Returns a data structure containing information about any failed
prerequisites (of any of the types described above), or \f(CW\*(C`undef\*(C'\fR if
all prerequisites are met.
.Sp
The data structure returned is a hash reference.  The top level keys
are the type of prerequisite failed, one of \*(L"requires\*(R",
\&\*(L"build_requires\*(R", \*(L"conflicts\*(R", or \*(L"recommends\*(R".  The associated values
are hash references whose keys are the names of required (or
conflicting) modules.  The associated values of those are hash
references indicating some information about the failure.  For example:
.Sp
.Vb 5
\& {
\&  have => '0.42',
\&  need => '0.59',
\&  message => 'Version 0.42 is installed, but we need version 0.59',
\& }
.Ve
.Sp
or
.Sp
.Vb 5
\& {
\&  have => '<none>',
\&  need => '0.59',
\&  message => 'Prerequisite Foo isn't installed',
\& }
.Ve
.Sp
This hash has the same structure as the hash returned by the
\&\f(CW\*(C`check_installed_status()\*(C'\fR method, except that in the case of
\&\*(L"conflicts\*(R" dependencies we change the \*(L"need\*(R" key to \*(L"conflicts\*(R" and
construct a proper message.
.Sp
Examples:
.Sp
.Vb 2
\&  # Check a required dependency on Foo::Bar
\&  if ( $m->prereq_failures->{requires}{Foo::Bar} ) { ...
.Ve
.Sp
.Vb 2
\&  # Check whether there were any failures
\&  if ( $m->prereq_failures ) { ...
.Ve
.Sp
.Vb 7
\&  # Show messages for all failures
\&  my $failures = $m->prereq_failures;
\&  while (my ($type, $list) = each %$failures) {
\&    while (my ($name, $hash) = each %$list) {
\&      print "Failure for $name: $hash->{message}\en";
\&    }
\&  }
.Ve
.IP "\fIrequires()\fR" 4
.IX Item "requires()"
.PD 0
.IP "\fIbuild_requires()\fR" 4
.IX Item "build_requires()"
.IP "\fIrecommends()\fR" 4
.IX Item "recommends()"
.IP "\fIconflicts()\fR" 4
.IX Item "conflicts()"
.PD
Each of these methods returns a hash reference indicating the
prerequisites that were passed to the \f(CW\*(C`new()\*(C'\fR method.
.ie n .IP "check_installed_status($module, $version)" 4
.el .IP "check_installed_status($module, \f(CW$version\fR)" 4
.IX Item "check_installed_status($module, $version)"
This method returns a hash reference indicating whether a version
dependency on a certain module is satisfied.  The \f(CW$module\fR argument
is given as a string like \f(CW"Data::Dumper"\fR or \f(CW"perl"\fR, and the
\&\f(CW$version\fR argument can take any of the forms described in requires
above.  This allows very fine-grained version checking.
.Sp
The returned hash reference has the following structure:
.Sp
.Vb 6
\& {
\&  ok => $whether_the_dependency_is_satisfied,
\&  have => $version_already_installed,
\&  need => $version_requested, # Same as incoming $version argument
\&  message => $informative_error_message,
\& }
.Ve
.Sp
If no version of \f(CW$module\fR is currently installed, the \f(CW\*(C`have\*(C'\fR value
will be the string \f(CW"<none>"\fR.  Otherwise the \f(CW\*(C`have\*(C'\fR value will
simply be the version of the installed module.  Note that this means
that if \f(CW$module\fR is installed but doesn't define a version number,
the \f(CW\*(C`have\*(C'\fR value will be \f(CW\*(C`undef\*(C'\fR \- this is why we don't use \f(CW\*(C`undef\*(C'\fR
for the case when \f(CW$module\fR isn't installed at all.
.Sp
This method may be called either as an object method
(\f(CW\*(C`$build\->check_installed_status($module, $version)\*(C'\fR)
or as a class method 
(\f(CW\*(C`Module::Build\->check_installed_status($module, $version)\*(C'\fR).
.ie n .IP "check_installed_version($module, $version)" 4
.el .IP "check_installed_version($module, \f(CW$version\fR)" 4
.IX Item "check_installed_version($module, $version)"
Like \f(CW\*(C`check_installed_status()\*(C'\fR, but simply returns true or false
depending on whether module \f(CW$module\fR statisfies the dependency
\&\f(CW$version\fR.
.Sp
If the check succeeds, the return value is the actual version of
\&\f(CW$module\fR installed on the system.  This allows you to do the
following:
.Sp
.Vb 6
\& my $installed = $m->check_installed_version('DBI', '1.15');
\& if ($installed) {
\&   print "Congratulations, version $installed of DBI is installed.\en";
\& } else {
\&   die "Sorry, you must install DBI.\en";
\& }
.Ve
.Sp
If the check fails, we return false and set \f(CW$@\fR to an informative
error message.
.Sp
If \f(CW$version\fR is any nontrue value (notably zero) and any version of
\&\f(CW$module\fR is installed, we return true.  In this case, if \f(CW$module\fR
doesn't define a version, or if its version is zero, we return the
special value \*(L"0 but true\*(R", which is numerically zero, but logically
true.
.Sp
In general you might prefer to use \f(CW\*(C`check_installed_status\*(C'\fR if you
need detailed information, or this method if you just need a yes/no
answer.
.ie n .IP "prompt($message, $default)" 4
.el .IP "prompt($message, \f(CW$default\fR)" 4
.IX Item "prompt($message, $default)"
Asks the user a question and returns their response as a string.  The
first argument specifies the message to display to the user (for
example, \f(CW"Where do you keep your money?"\fR).  The second argument,
which is optional, specifies a default answer (for example,
\&\f(CW"wallet"\fR).  The user will be asked the question once.
.Sp
If the current session doesn't seem to be interactive (i.e. if
\&\f(CW\*(C`STDIN\*(C'\fR and \f(CW\*(C`STDOUT\*(C'\fR look like they're attached to files or
something, not terminals), we'll just use the default without
letting the user provide an answer.
.Sp
This method may be called as a class or object method.
.ie n .IP "y_n($message, $default)" 4
.el .IP "y_n($message, \f(CW$default\fR)" 4
.IX Item "y_n($message, $default)"
Asks the user a yes/no question using \f(CW\*(C`prompt()\*(C'\fR and returns true or
false accordingly.  The user will be asked the question repeatedly
until they give an answer that looks like \*(L"yes\*(R" or \*(L"no\*(R".
.Sp
The first argument specifies the message to display to the user (for
example, \f(CW"Shall I invest your money for you?"\fR), and the second
argument specifies the default answer (for example, \f(CW"y"\fR).
.Sp
Note that the default is specified as a string like \f(CW"y"\fR or \f(CW"n"\fR,
and the return value is a Perl boolean value like 1 or 0.  I thought
about this for a while and this seemed like the most useful way to do
it.
.Sp
This method may be called as a class or object method.
.IP "\fIscript_files()\fR" 4
.IX Item "script_files()"
Returns an array reference specifying the perl script files to be
installed.  This corresponds to the \f(CW\*(C`script_files\*(C'\fR parameter to the
\&\f(CW\*(C`new()\*(C'\fR method.  With an optional argument, this parameter may be set
dynamically.
.Sp
For backward compatibility, the \f(CW\*(C`scripts()\*(C'\fR method does exactly the
same thing as \f(CW\*(C`script_files()\*(C'\fR.  \f(CW\*(C`scripts()\*(C'\fR is deprecated, but it
will stay around for several versions to give people time to
transition.
.IP "copy_if_modified(%parameters)" 4
.IX Item "copy_if_modified(%parameters)"
Takes the file in the \f(CW\*(C`from\*(C'\fR parameter and copies it to the file in
the \f(CW\*(C`to\*(C'\fR parameter, or the directory in the \f(CW\*(C`to_dir\*(C'\fR parameter, if
the file has changed since it was last copied (or if it doesn't exist
in the new location).  By default the entire directory structure of
\&\f(CW\*(C`from\*(C'\fR will be copied into \f(CW\*(C`to_dir\*(C'\fR; an optional \f(CW\*(C`flatten\*(C'\fR
parameter will copy into \f(CW\*(C`to_dir\*(C'\fR without doing so.
.Sp
Returns the path to the destination file, or \f(CW\*(C`undef\*(C'\fR if nothing
needed to be copied.
.Sp
Any directories that need to be created in order to perform the
copying will be automatically created.
.ie n .IP "do_system($cmd, @args)" 4
.el .IP "do_system($cmd, \f(CW@args\fR)" 4
.IX Item "do_system($cmd, @args)"
This is a fairly simple wrapper around Perl's \f(CW\*(C`system()\*(C'\fR built-in
command.  Given a command and an array of optional arguments, this
method will print the command to \f(CW\*(C`STDOUT\*(C'\fR, and then execute it using
Perl's \f(CW\*(C`system()\*(C'\fR.  It returns true or false to indicate success or
failure (the opposite of how \f(CW\*(C`system()\*(C'\fR works, but more intuitive).
.Sp
Note that if you supply a single argument to \f(CW\*(C`do_system()\*(C'\fR, it
will/may be processed by the systems's shell, and any special
characters will do their special things.  If you supply multiple
arguments, no shell will get involved and the command will be executed
directly.
.IP "\fIhave_c_compiler()\fR" 4
.IX Item "have_c_compiler()"
Returns true if the current system seems to have a working C compiler.
We currently determine this by attempting to compile a simple C source
file and reporting whether the attempt was successful.
.IP "\fIbase_dir()\fR" 4
.IX Item "base_dir()"
Returns a string containing the root-level directory of this build,
i.e. where the \f(CW\*(C`Build.PL\*(C'\fR script and the \f(CW\*(C`lib\*(C'\fR directory can be
found.  This is usually the same as the current working directory,
because the \f(CW\*(C`Build\*(C'\fR script will \f(CW\*(C`chdir()\*(C'\fR into this directory as
soon as it begins execution.
.IP "\fIdist_name()\fR" 4
.IX Item "dist_name()"
Returns the name of the current distribution, as passed to the
\&\f(CW\*(C`new()\*(C'\fR method in a \f(CW\*(C`dist_name\*(C'\fR or modified \f(CW\*(C`module_name\*(C'\fR
parameter.
.IP "\fIdist_version()\fR" 4
.IX Item "dist_version()"
Returns the version of the current distribution, as determined by the
\&\f(CW\*(C`new()\*(C'\fR method from a \f(CW\*(C`dist_version\*(C'\fR, \f(CW\*(C`dist_version_from\*(C'\fR, or
\&\f(CW\*(C`module_name\*(C'\fR parameter.
.ie n .IP "up_to_date($source_file, $derived_file)" 4
.el .IP "up_to_date($source_file, \f(CW$derived_file\fR)" 4
.IX Item "up_to_date($source_file, $derived_file)"
.PD 0
.IP "up_to_date(\e@source_files, \e@derived_files)" 4
.IX Item "up_to_date(@source_files, @derived_files)"
.PD
This method can be used to compare a set of source files to a set of
derived files.  If any of the source files are newer than any of the
derived files, it returns false.  Additionally, if any of the derived
files do not exist, it returns false.  Otherwise it returns true.
.Sp
The arguments may be either a scalar or an array reference of file
names.
.IP "contains_pod($file)" 4
.IX Item "contains_pod($file)"
Returns true if the given file appears to contain \s-1POD\s0 documentation.
Currently this checks whether the file has a line beginning with
\&'=pod', '=head', or '=item', but the exact semantics may change in the
future.
.SH "ACTIONS"
.IX Header "ACTIONS"
There are some general principles at work here.  First, each task when
building a module is called an \*(L"action\*(R".  These actions are listed
above; they correspond to the building, testing, installing,
packaging, etc. tasks.
.PP
Second, arguments are processed in a very systematic way.  Arguments
are always key=value pairs.  They may be specified at \f(CW\*(C`perl Build.PL\*(C'\fR
time (i.e.  \f(CW\*(C`perl Build.PL destdir=/my/secret/place\*(C'\fR), in which case
their values last for the lifetime of the \f(CW\*(C`Build\*(C'\fR script.  They may
also be specified when executing a particular action (i.e.
\&\f(CW\*(C`Build test verbose=1\*(C'\fR), in which case their values last only for the
lifetime of that command.  Per-action command-line parameters take
precedence over parameters specified at \f(CW\*(C`perl Build.PL\*(C'\fR time.
.PP
The build process also relies heavily on the \f(CW\*(C`Config.pm\*(C'\fR module, and
all the key=value pairs in \f(CW\*(C`Config.pm\*(C'\fR are available in 
.PP
\&\f(CW\*(C`$self\->{config}\*(C'\fR.  If the user wishes to override any of the
values in \f(CW\*(C`Config.pm\*(C'\fR, she may specify them like so:
.PP
.Vb 1
\&  perl Build.PL config='cc=gcc ld=gcc'
.Ve
.PP
Not the greatest interface, I'm looking for alternatives.  Speak now!
Maybe:
.PP
.Vb 1
\&  perl Build.PL config=cc:gcc config=ld:gcc
.Ve
.PP
or something.
.PP
The following build actions are provided by default.
.IP "help" 4
.IX Item "help"
This action will simply print out a message that is meant to help you
use the build process.  It will show you a list of available build
actions too.
.Sp
With an optional argument specifying an action name (e.g. \f(CW\*(C`Build help
test\*(C'\fR), the 'help' action will show you any \s-1POD\s0 documentation it can
find for that action.
.IP "build" 4
.IX Item "build"
If you run the \f(CW\*(C`Build\*(C'\fR script without any arguments, it runs the
\&\f(CW\*(C`build\*(C'\fR action, which in turn runs the \f(CW\*(C`code\*(C'\fR and \f(CW\*(C`docs\*(C'\fR actions.
.Sp
This is analogous to the MakeMaker 'make all' target.
.IP "code" 4
.IX Item "code"
This action builds your codebase.
.Sp
By default it just creates a \f(CW\*(C`blib/\*(C'\fR directory and copies any \f(CW\*(C`.pm\*(C'\fR
and \f(CW\*(C`.pod\*(C'\fR files from your \f(CW\*(C`lib/\*(C'\fR directory into the \f(CW\*(C`blib/\*(C'\fR
directory.  It also compiles any \f(CW\*(C`.xs\*(C'\fR files from \f(CW\*(C`lib/\*(C'\fR and places
them in \f(CW\*(C`blib/\*(C'\fR.  Of course, you need a working C compiler
(probably the same one that built perl itself) for this to work
properly.
.Sp
The \f(CW\*(C`build\*(C'\fR action also runs any \f(CW\*(C`.PL\*(C'\fR files in your \fIlib/\fR
directory.  Typically these create other files, named the same but
without the \f(CW\*(C`.PL\*(C'\fR ending.  For example, a file \fIlib/Foo/Bar.pm.PL\fR
could create the file \fIlib/Foo/Bar.pm\fR.  The \f(CW\*(C`.PL\*(C'\fR files are
processed first, so any \f(CW\*(C`.pm\*(C'\fR files (or other kinds that we deal
with) will get copied correctly.
.Sp
If your \f(CW\*(C`.PL\*(C'\fR scripts don't create any files, or if they create files
with unexpected names, or even if they create multiple files, you
should tell us that so that we can clean up properly after these
created files.  Use the \f(CW\*(C`PL_files\*(C'\fR parameter to \f(CW\*(C`new()\*(C'\fR:
.Sp
.Vb 3
\& PL_files => { 'lib/Foo/Bar_pm.PL' => 'lib/Foo/Bar.pm',
\&               'lib/something.PL'  => ['/lib/something', '/lib/else'],
\&               'lib/funny.PL'      => [] }
.Ve
.Sp
Note that in contrast to MakeMaker, the \f(CW\*(C`build\*(C'\fR action only
(currently) handles \f(CW\*(C`.pm\*(C'\fR, \f(CW\*(C`.pod\*(C'\fR, \f(CW\*(C`.PL\*(C'\fR, and \f(CW\*(C`.xs\*(C'\fR files.  They
must all be in the \f(CW\*(C`lib/\*(C'\fR directory, in the directory structure that
they should have when installed.  We also handle \f(CW\*(C`.c\*(C'\fR files that can
be in the place of your choosing \- see the \f(CW\*(C`c_source\*(C'\fR argument to
\&\f(CW\*(C`new()\*(C'\fR.
.Sp
The \f(CW\*(C`.xs\*(C'\fR support is currently in alpha.  Please let me know whether
it works for you.
.IP "docs" 4
.IX Item "docs"
This will generate documentation (ie: Unix man pages) for any binary and
library files under \fBblib/\fR that contain \s-1POD\s0.  If there are no \f(CW\*(C`bindoc\*(C'\fR or
\&\f(CW\*(C`libdoc\*(C'\fR installation targets defined (as will be the case on systems that
don't support Unix manpages) this action does nothing.
.IP "test" 4
.IX Item "test"
This will use \f(CW\*(C`Test::Harness\*(C'\fR to run any regression tests and report
their results.  Tests can be defined in the standard places: a file
called \f(CW\*(C`test.pl\*(C'\fR in the top-level directory, or several files ending
with \f(CW\*(C`.t\*(C'\fR in a \f(CW\*(C`t/\*(C'\fR directory.
.Sp
If you want tests to be 'verbose', i.e. show details of test execution
rather than just summary information, pass the argument \f(CW\*(C`verbose=1\*(C'\fR.
.Sp
If you want to run tests under the perl debugger, pass the argument
\&\f(CW\*(C`debugger=1\*(C'\fR.
.Sp
In addition, if a file called \f(CW\*(C`visual.pl\*(C'\fR exists in the top-level
directory, this file will be executed as a Perl script and its output
will be shown to the user.  This is a good place to put speed tests or
other tests that don't use the \f(CW\*(C`Test::Harness\*(C'\fR format for output.
.Sp
To override the choice of tests to run, you may pass a \f(CW\*(C`test_files\*(C'\fR
argument whose value is a whitespace-separated list of test scripts to
run.  This is especially useful in development, when you only want to
run a single test to see whether you've squashed a certain bug yet:
.Sp
.Vb 1
\& ./Build test --test_files t/something_failing.t
.Ve
.Sp
You may also pass several \f(CW\*(C`test_files\*(C'\fR arguments separately:
.Sp
.Vb 1
\& ./Build test --test_files t/one.t --test_files t/two.t
.Ve
.Sp
or use a \f(CW\*(C`glob()\*(C'\fR\-style pattern:
.Sp
.Vb 1
\& ./Build test --test_files 't/01-*.t'
.Ve
.IP "testdb" 4
.IX Item "testdb"
This is a synonym for the 'test' action with the \f(CW\*(C`debugger=1\*(C'\fR
argument.
.IP "clean" 4
.IX Item "clean"
This action will clean up any files that the build process may have
created, including the \f(CW\*(C`blib/\*(C'\fR directory (but not including the
\&\f(CW\*(C`_build/\*(C'\fR directory and the \f(CW\*(C`Build\*(C'\fR script itself).
.IP "realclean" 4
.IX Item "realclean"
This action is just like the \f(CW\*(C`clean\*(C'\fR action, but also removes the
\&\f(CW\*(C`_build\*(C'\fR directory and the \f(CW\*(C`Build\*(C'\fR script.  If you run the
\&\f(CW\*(C`realclean\*(C'\fR action, you are essentially starting over, so you will
have to re-create the \f(CW\*(C`Build\*(C'\fR script again.
.IP "diff" 4
.IX Item "diff"
This action will compare the files about to be installed with their
installed counterparts.  For .pm and .pod files, a diff will be shown
(this currently requires a 'diff' program to be in your \s-1PATH\s0).  For
other files like compiled binary files, we simply report whether they
differ.
.Sp
A \f(CW\*(C`flags\*(C'\fR parameter may be passed to the action, which will be passed
to the 'diff' program.  Consult your 'diff' documentation for the
parameters it will accept \- a good one is \f(CW\*(C`\-u\*(C'\fR:
.Sp
.Vb 1
\& ./Build diff flags=-u
.Ve
.IP "install" 4
.IX Item "install"
This action will use \f(CW\*(C`ExtUtils::Install\*(C'\fR to install the files from
\&\f(CW\*(C`blib/\*(C'\fR into the system.  See \*(L"How Installation Paths are Determined\*(R" for details
about how Module::Build determines where to install things, and how to
influence this process.
.Sp
If you want the installation process to look around in \f(CW@INC\fR for
other versions of the stuff you're installing and try to delete it,
you can use the \f(CW\*(C`uninst\*(C'\fR parameter, which tells \f(CW\*(C`ExtUtils::Install\*(C'\fR to
do so:
.Sp
.Vb 1
\& Build install uninst=1
.Ve
.Sp
This can be a good idea, as it helps prevent multiple versions of a
module from being present on your system, which can be a confusing
situation indeed.
.IP "fakeinstall" 4
.IX Item "fakeinstall"
This is just like the \f(CW\*(C`install\*(C'\fR action, but it won't actually do
anything, it will just report what it \fIwould\fR have done if you had
actually run the \f(CW\*(C`install\*(C'\fR action.
.IP "versioninstall" 4
.IX Item "versioninstall"
** Note: since \f(CW\*(C`only.pm\*(C'\fR is so new, and since we just recently added
support for it here too, this feature is to be considered
experimental. **
.Sp
If you have the \f(CW\*(C`only.pm\*(C'\fR module installed on your system, you can
use this action to install a module into the version-specific library
trees. This means that you can have several versions of the same
module installed and \f(CW\*(C`use\*(C'\fR a specific one like this:
.Sp
.Vb 1
\& use only MyModule => 0.55;
.Ve
.Sp
To override the default installation libraries in \f(CW\*(C`only::config\*(C'\fR,
specify the \f(CW\*(C`versionlib\*(C'\fR parameter when you run the \f(CW\*(C`Build.PL\*(C'\fR script:
.Sp
.Vb 1
\& perl Build.PL versionlib=/my/version/place/
.Ve
.Sp
To override which version the module is installed as, specify the
\&\f(CW\*(C`versionlib\*(C'\fR parameter when you run the \f(CW\*(C`Build.PL\*(C'\fR script:
.Sp
.Vb 1
\& perl Build.PL version=0.50
.Ve
.Sp
See the \f(CW\*(C`only.pm\*(C'\fR documentation for more information on
version-specific installs.
.IP "manifest" 4
.IX Item "manifest"
This is an action intended for use by module authors, not people
installing modules.  It will bring the \fI\s-1MANIFEST\s0\fR up to date with the
files currently present in the distribution.  You may use a
\&\fI\s-1MANIFEST\s0.SKIP\fR file to exclude certain files or directories from
inclusion in the \fI\s-1MANIFEST\s0\fR.  \fI\s-1MANIFEST\s0.SKIP\fR should contain a bunch
of regular expressions, one per line.  If a file in the distribution
directory matches any of the regular expressions, it won't be included
in the \fI\s-1MANIFEST\s0\fR.
.Sp
The following is a reasonable \fI\s-1MANIFEST\s0.SKIP\fR starting point, you can
add your own stuff to it:
.Sp
.Vb 7
\&   ^_build
\&   ^Build$
\&   ^blib
\&   ~$
\&   \e.bak$
\&   ^MANIFEST\e.SKIP$
\&   CVS
.Ve
.Sp
See the distcheck and skipcheck actions if you want to find out
what the \f(CW\*(C`manifest\*(C'\fR action would do, without actually doing anything.
.IP "dist" 4
.IX Item "dist"
This action is helpful for module authors who want to package up their
module for distribution through a medium like \s-1CPAN\s0.  It will create a
tarball of the files listed in \fI\s-1MANIFEST\s0\fR and compress the tarball using
\&\s-1GZIP\s0 compression.
.IP "distsign" 4
.IX Item "distsign"
Uses \f(CW\*(C`Module::Signature\*(C'\fR to create a \s-1SIGNATURE\s0 file for your
distribution, and adds the \s-1SIGNATURE\s0 file to the distribution's
\&\s-1MANIFEST\s0.
.IP "distmeta" 4
.IX Item "distmeta"
Creates the \fI\s-1META\s0.yml\fR file for your distribution.
.IP "distcheck" 4
.IX Item "distcheck"
Reports which files are in the build directory but not in the
\&\fI\s-1MANIFEST\s0\fR file, and vice versa. (See manifest for details)
.IP "skipcheck" 4
.IX Item "skipcheck"
Reports which files are skipped due to the entries in the
\&\fI\s-1MANIFEST\s0.SKIP\fR file (See manifest for details)
.IP "distclean" 4
.IX Item "distclean"
Performs the 'realclean' action and then the 'distcheck' action.
.IP "distdir" 4
.IX Item "distdir"
Creates a directory called \f(CW\*(C`$(DISTNAME)\-$(VERSION)\*(C'\fR (if that
directory already exists, it will be removed first).  Then copies all
the files listed in the \fI\s-1MANIFEST\s0\fR file to that directory.  This
directory is what people will see when they download your distribution
and unpack it.
.Sp
While performing the 'distdir' action, a file containing various bits
of \*(L"metadata\*(R" will be created.  The metadata includes the module's
name, version, dependencies, license, and the \f(CW\*(C`dynamic_config\*(C'\fR
flag.  This file is created as \fI\s-1META\s0.yml\fR in \s-1YAML\s0 format, so you
must have the \f(CW\*(C`YAML\*(C'\fR module installed in order to create it.  You
should also ensure that the \fI\s-1META\s0.yml\fR file is listed in your
\&\fI\s-1MANIFEST\s0\fR \- if it's not, a warning will be issued.
.IP "disttest" 4
.IX Item "disttest"
Performs the 'distdir' action, then switches into that directory and
runs a \f(CW\*(C`perl Build.PL\*(C'\fR, followed by the 'build' and 'test' actions in
that directory.
.IP "ppd" 4
.IX Item "ppd"
Build a \s-1PPD\s0 file for your distribution.
.Sh "How Installation Paths are Determined"
.IX Subsection "How Installation Paths are Determined"
When you invoke Module::Build's \f(CW\*(C`build\*(C'\fR action, it needs to figure
out where to install things.  The nutshell version of how this works
is that default installation locations are determined from
\&\fIConfig.pm\fR, and they may be overridden by using the \f(CW\*(C`install_path\*(C'\fR
parameter.  An \f(CW\*(C`install_base\*(C'\fR parameter lets you specify an
alternative installation root like \fI/home/foo\fR, and a \f(CW\*(C`destdir\*(C'\fR lets
you specify a temporary installation directory like \fI/tmp/install\fR in
case you want to create bundled-up installable packages.
.PP
Natively, Module::Build provides default installation locations for
the following types of installable items:
.IP "lib" 4
.IX Item "lib"
Usually pure-Perl module files ending in \fI.pm\fR.
.IP "arch" 4
.IX Item "arch"
\&\*(L"Architecture\-dependent\*(R" module files, usually produced by compiling
\&\s-1XS\s0, Inline, or similar code.
.IP "script" 4
.IX Item "script"
Programs written in pure Perl.  In order to improve reuse, try to make
these as small as possible \- put the code into modules whenever
possible.
.IP "bin" 4
.IX Item "bin"
\&\*(L"Architecture\-dependent\*(R" executable programs, i.e. compiled C code or
something.  Pretty rare to see this in a perl distribution, but it
happens.
.IP "libdoc" 4
.IX Item "libdoc"
Documentation for the stuff in \f(CW\*(C`lib\*(C'\fR and \f(CW\*(C`arch\*(C'\fR.  This is usually
generated from the \s-1POD\s0 in \fI.pm\fR files.  Under Unix, these are manual
pages belonging to the 'man3' category.
.IP "bindoc" 4
.IX Item "bindoc"
Documentation for the stuff in \f(CW\*(C`script\*(C'\fR and \f(CW\*(C`bin\*(C'\fR.  Usually
generated from the \s-1POD\s0 in those files.  Under Unix, these are manual
pages belonging to the 'man1' category.
.PP
\fIinstalldirs\fR
.IX Subsection "installdirs"
.PP
The default destinations for these installable things come from
entries in your system's \f(CW\*(C`Config.pm\*(C'\fR.  You can select from three
different sets of default locations by setting the \f(CW\*(C`installdirs\*(C'\fR
parameter as follows:
.PP
.Vb 2
\&                          'installdirs' set to:
\&                   core          site                vendor
.Ve
.PP
.Vb 1
\&              uses the following defaults from Config.pm:
.Ve
.PP
.Vb 6
\& lib     => installprivlib  installsitelib      installvendorlib
\& arch    => installarchlib  installsitearch     installvendorarch
\& script  => installscript   installsitebin      installvendorbin
\& bin     => installbin      installsitebin      installvendorbin
\& libdoc  => installman3dir  installsiteman3dir  installvendorman3dir
\& bindoc  => installman1dir  installsiteman1dir  installvendorman1dir
.Ve
.PP
The default value of \f(CW\*(C`installdirs\*(C'\fR is \*(L"site\*(R".  If you're creating
vendor distributions of module packages, you may want to do something
like this:
.PP
.Vb 1
\& perl Build.PL installdirs=vendor
.Ve
.PP
or
.PP
.Vb 1
\& Build install installdirs=vendor
.Ve
.PP
If you're installing an updated version of a module that was included
with perl itself (i.e. a \*(L"core module\*(R"), then you may set
\&\f(CW\*(C`installdirs\*(C'\fR to \*(L"core\*(R" to overwrite the module in its present
location.
.PP
(Note that the 'script' line is different from MakeMaker \-
unfortunately there's no such thing as \*(L"installsitescript\*(R" or
\&\*(L"installvendorscript\*(R" entry in \f(CW\*(C`Config.pm\*(C'\fR, so we use the
\&\*(L"installsitebin\*(R" and \*(L"installvendorbin\*(R" entries to at least get the
general location right.  In the future, if \f(CW\*(C`Config.pm\*(C'\fR adds some more
appropriate entries, we'll start using those.)
.PP
\fIinstall_path\fR
.IX Subsection "install_path"
.PP
Once the defaults have been set, you can override them.  You can set
individual entries by using the \f(CW\*(C`install_path\*(C'\fR parameter:
.PP
.Vb 4
\& my $m = Module::Build->new
\&  (...other options...,
\&   install_path => {lib  => '/foo/lib',
\&                    arch => '/foo/lib/arch'});
.Ve
.PP
On the command line, that would look like this:
.PP
.Vb 1
\& perl Build.PL install_path=lib=/foo/lib install_path=arch=/foo/lib/arch
.Ve
.PP
or this:
.PP
.Vb 1
\& Build install install_path=lib=/foo/lib install_path=arch=/foo/lib/arch
.Ve
.PP
\fIinstall_base\fR
.IX Subsection "install_base"
.PP
You can also set the whole bunch of installation paths by supplying the
\&\f(CW\*(C`install_base\*(C'\fR parameter to point to a directory on your system.  For
instance, if you set \f(CW\*(C`install_base\*(C'\fR to \*(L"/home/ken\*(R" on a Linux
system, you'll install as follows:
.PP
.Vb 6
\& lib     => /home/ken/lib
\& arch    => /home/ken/lib/i386-linux
\& script  => /home/ken/scripts
\& bin     => /home/ken/bin
\& libdoc  => /home/ken/man/man1
\& bindoc  => /home/ken/man/man3
.Ve
.PP
Note that this is \fIdifferent\fR from how MakeMaker's \f(CW\*(C`PREFIX\*(C'\fR
parameter works.  \f(CW\*(C`PREFIX\*(C'\fR tries to create a mini-replica of a
\&\f(CW\*(C`site\*(C'\fR\-style installation under the directory you specify, which is
not always possible (and the results are not always pretty in this
case).  \f(CW\*(C`install_base\*(C'\fR just gives you a default layout under the
directory you specify, which may have little to do with the
\&\f(CW\*(C`installdirs=site\*(C'\fR layout.
.PP
The exact layout under the directory you specify may vary by system \-
we try to do the \*(L"sensible\*(R" thing on each platform.
.PP
\fIdestdir\fR
.IX Subsection "destdir"
.PP
If you want to install everything into a temporary directory first
(for instance, if you want to create a directory tree that a package
manager like \f(CW\*(C`rpm\*(C'\fR or \f(CW\*(C`dpkg\*(C'\fR could create a package from), you can
use the \f(CW\*(C`destdir\*(C'\fR parameter:
.PP
.Vb 1
\& perl Build.PL destdir=/tmp/foo
.Ve
.PP
or
.PP
.Vb 1
\& Build install destdir=/tmp/foo
.Ve
.PP
This will effectively install to \*(L"/tmp/foo/$sitelib\*(R",
\&\*(L"/tmp/foo/$sitearch\*(R", and the like, except that it will use
\&\f(CW\*(C`File::Spec\*(C'\fR to make the pathnames work correctly on whatever
platform you're installing on.
.SH "AUTOMATION"
.IX Header "AUTOMATION"
One advantage of Module::Build is that since it's implemented as Perl
methods, you can invoke these methods directly if you want to install
a module non\-interactively.  For instance, the following Perl script
will invoke the entire build/install procedure:
.PP
.Vb 4
\& my $m = Module::Build->new(module_name => 'MyModule');
\& $m->dispatch('build');
\& $m->dispatch('test');
\& $m->dispatch('install');
.Ve
.PP
If any of these steps encounters an error, it will throw a fatal
exception.
.PP
You can also pass arguments as part of the build process:
.PP
.Vb 4
\& my $m = Module::Build->new(module_name => 'MyModule');
\& $m->dispatch('build');
\& $m->dispatch('test', verbose => 1);
\& $m->dispatch('install', sitelib => '/my/secret/place/');
.Ve
.PP
Building and installing modules in this way skips creating the
\&\f(CW\*(C`Build\*(C'\fR script.
.SH "STRUCTURE"
.IX Header "STRUCTURE"
Module::Build creates a class hierarchy conducive to customization.
Here is the parent-child class hierarchy in classy \s-1ASCII\s0 art:
.PP
.Vb 18
\&   /--------------------\e
\&   |   Your::Parent     |  (If you subclass Module::Build)
\&   \e--------------------/
\&            |
\&            |
\&   /--------------------\e  (Doesn't define any functionality
\&   |   Module::Build    |   of its own - just figures out what
\&   \e--------------------/   other modules to load.)
\&            |
\&            |
\&   /-----------------------------------\e  (Some values of $^O may
\&   |   Module::Build::Platform::$^O    |   define specialized functionality.
\&   \e-----------------------------------/   Otherwise it's ...::Default, a
\&            |                              pass-through class.)
\&            |
\&   /--------------------------\e
\&   |   Module::Build::Base    |  (Most of the functionality of 
\&   \e--------------------------/   Module::Build is defined here.)
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Right now, there are two ways to subclass Module::Build.  The first
way is to create a regular module (in a \f(CW\*(C`.pm\*(C'\fR file) that inherits
from Module::Build, and use that module's class instead of using
Module::Build directly:
.PP
.Vb 2
\&  ------ in Build.PL: ----------
\&  #!/usr/bin/perl
.Ve
.PP
.Vb 2
\&  use lib qw(/nonstandard/library/path);
\&  use My::Builder;  # Or whatever you want to call it
.Ve
.PP
.Vb 2
\&  my $m = My::Builder->new(module_name => 'Next::Big::Thing');
\&  $m->create_build_script;
.Ve
.PP
This is relatively straightforward, and is the best way to do things
if your My::Builder class contains lots of code.  The
\&\f(CW\*(C`create_build_script()\*(C'\fR method will ensure that the current value of
\&\f(CW@INC\fR (including the \f(CW\*(C`/nonstandard/library/path\*(C'\fR) is propogated to
the Build script, so that My::Builder can be found when running build
actions.
.PP
For very small additions, Module::Build provides a \f(CW\*(C`subclass()\*(C'\fR
method that lets you subclass Module::Build more conveniently, without
creating a separate file for your module:
.PP
.Vb 2
\&  ------ in Build.PL: ----------
\&  #!/usr/bin/perl
.Ve
.PP
.Vb 9
\&  my $class = Module::Build->subclass
\&    (
\&     class => 'My::Builder',
\&     code => q{
\&      sub ACTION_foo {
\&        print "I'm fooing to death!\en";
\&      }
\&     },
\&    );
.Ve
.PP
.Vb 2
\&  my $m = $class->new(module_name => 'Module::Build');
\&  $m->create_build_script;
.Ve
.PP
Behind the scenes, this actually does create a \f(CW\*(C`.pm\*(C'\fR file, since the
code you provide must persist after Build.PL is run if it is to be
very useful.
.PP
See also the documentation for the \f(CW\*(C`subclass()\*(C'\fR method.
.SH "MOTIVATIONS"
.IX Header "MOTIVATIONS"
There are several reasons I wanted to start over, and not just fix
what I didn't like about MakeMaker:
.IP "\(bu" 4
I don't like the core idea of MakeMaker, namely that \f(CW\*(C`make\*(C'\fR should be
involved in the build process.  Here are my reasons:
.RS 4
.IP "+" 4
When a person is installing a Perl module, what can you assume about
their environment?  Can you assume they have \f(CW\*(C`make\*(C'\fR?  No, but you can
assume they have some version of Perl.
.IP "+" 4
When a person is writing a Perl module for intended distribution, can
you assume that they know how to build a Makefile, so they can
customize their build process?  No, but you can assume they know Perl,
and could customize that way.
.RE
.RS 4
.Sp
For years, these things have been a barrier to people getting the
build/install process to do what they want.
.RE
.IP "\(bu" 4
There are several architectural decisions in MakeMaker that make it
very difficult to customize its behavior.  For instance, when using
MakeMaker you do \f(CW\*(C`use MakeMaker\*(C'\fR, but the object created in
\&\f(CW\*(C`WriteMakefile()\*(C'\fR is actually blessed into a package name that's
created on the fly, so you can't simply subclass
\&\f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR.  There is a workaround \f(CW\*(C`MY\*(C'\fR package that lets
you override certain MakeMaker methods, but only certain explicitly
predefined (by MakeMaker) methods can be overridden.  Also, the method
of customization is very crude: you have to modify a string containing
the Makefile text for the particular target.  Since these strings
aren't documented, and \fIcan't\fR be documented (they take on different
values depending on the platform, version of perl, version of
MakeMaker, etc.), you have no guarantee that your modifications will
work on someone else's machine or after an upgrade of MakeMaker or
perl.
.IP "\(bu" 4
It is risky to make major changes to MakeMaker, since it does so many
things, is so important, and generally works.  \f(CW\*(C`Module::Build\*(C'\fR is an
entirely seperate package so that I can work on it all I want, without
worrying about backward compatibility.
.IP "\(bu" 4
Finally, Perl is said to be a language for system administration.
Could it really be the case that Perl isn't up to the task of building
and installing software?  Even if that software is a bunch of stupid
little \f(CW\*(C`.pm\*(C'\fR files that just need to be copied from one place to
another?  Are you getting riled up yet??
.SH "MIGRATION"
.IX Header "MIGRATION"
Note that if you want to provide both a \fIMakefile.PL\fR and a
\&\fIBuild.PL\fR for your distribution, you probably want to add the
following to \f(CW\*(C`WriteMakefile\*(C'\fR in your \fIMakefile.PL\fR so that MakeMaker
doesn't try to run your \fIBuild.PL\fR as a normal \fI.PL\fR file:
.PP
.Vb 1
\& PL_FILES => {},
.Ve
.PP
You may also be interested in looking at the \f(CW\*(C`Module::Build::Compat\*(C'\fR
module, which can automatically create various kinds of \fIMakefile.PL\fR
compatibility layers.
.SH "TO DO"
.IX Header "TO DO"
The current method of relying on time stamps to determine whether a
derived file is out of date isn't likely to scale well, since it
requires tracing all dependencies backward, it runs into problems on
\&\s-1NFS\s0, and it's just generally flimsy.  It would be better to use an \s-1MD5\s0
signature or the like, if available.  See \f(CW\*(C`cons\*(C'\fR for an example.
.PP
\&\- append to perllocal.pod
\&\- write .packlist in appropriate location (needed for un\-install)
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Williams, ken@mathforum.org
.PP
Development questions, bug reports, and patches should be sent to the
Module-Build mailing list at module\-build\-general@lists.sourceforge.net .
Bug reports are also welcome at
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Module\-Build .
.PP
An anonymous \s-1CVS\s0 repository containing the latest development version
is available; see http://sourceforge.net/cvs/?group_id=45731 for the
details of how to access it.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIExtUtils::MakeMaker\fR\|(3), \s-1\fIYAML\s0\fR\|(3)
.PP
http://www.dsmit.com/cons/
