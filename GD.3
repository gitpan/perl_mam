.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH GD 3 "perl 5.004, patch 55" "19/Nov/97" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
GD.pm \- Interface to Gd Graphics Library
.SH "SYNOPSIS"
.PP
.Vb 4
\&    use GD;
\&        
\&    # create a new image
\&    $im = new GD::Image(100,100);
.Ve
.Vb 5
\&    # allocate some colors
\&    $white = $im->colorAllocate(255,255,255);
\&    $black = $im->colorAllocate(0,0,0);       
\&    $red = $im->colorAllocate(255,0,0);      
\&    $blue = $im->colorAllocate(0,0,255);
.Ve
.Vb 3
\&    # make the background transparent and interlaced
\&    $im->transparent($white);
\&    $im->interlaced('true');
.Ve
.Vb 2
\&    # Put a black frame around the picture
\&    $im->rectangle(0,0,99,99,$black);
.Ve
.Vb 2
\&    # Draw a blue oval
\&    $im->arc(50,50,95,75,0,360,$blue);
.Ve
.Vb 2
\&    # And fill it with red
\&    $im->fill(50,50,$red);
.Ve
.Vb 2
\&    # Convert the image to GIF and print it on standard output
\&    print $im->gif;
.Ve
.SH "DESCRIPTION"
\fBGD.pm\fR is a port of Thomas Boutell's gd graphics library (see
below).  GD allows you to create color drawings using a large number of
graphics primitives, and emit the drawings as GIF files.
.PP
GD defines the following three classes:
.Ip "\f(CWGD::Image\fR" 5
An image class, which holds the image data and accepts graphic
primitive method calls.
.Ip "\f(CWGD::Font\fR" 5
A font class, which holds static font information and used for text
rendering.
.Ip "\f(CWGD::Polygon\fR" 5
A simple polygon object, used for storing lists of vertices prior to
rendering a polygon into an image.
.PP
A Simple Example:
.PP
.Vb 1
\&        #!/usr/local/bin/perl
.Ve
.Vb 4
\&        use GD;
\&        
\&        # create a new image
\&        $im = new GD::Image(100,100);
.Ve
.Vb 5
\&        # allocate some colors
\&        $white = $im->colorAllocate(255,255,255);
\&        $black = $im->colorAllocate(0,0,0);       
\&        $red = $im->colorAllocate(255,0,0);      
\&        $blue = $im->colorAllocate(0,0,255);
.Ve
.Vb 3
\&        # make the background transparent and interlaced
\&        $im->transparent($white);
\&        $im->interlaced('true');
.Ve
.Vb 2
\&        # Put a black frame around the picture
\&        $im->rectangle(0,0,99,99,$black);
.Ve
.Vb 2
\&        # Draw a blue oval
\&        $im->arc(50,50,95,75,0,360,$blue);
.Ve
.Vb 2
\&        # And fill it with red
\&        $im->fill(50,50,$red);
.Ve
.Vb 2
\&        # Convert the image to GIF and print it on standard output
\&        print $im->gif;
.Ve
Notes:
.Ip "1. To create a new, empty image, send a new() message to \s-1GD::\s0Image, passing it the width and height of the image you want to create.  An image object will be returned.  Other class methods allow you to initialize an image from a preexisting \s-1GIF\s0, \s-1GD\s0 or \s-1XBM\s0 file." 5
.Ip "2. Next you will ordinarily add colors to the image's color table. colors are added using a colorAllocate() method call.  The three parameters in each call are the red, green and blue (rgb) triples for the desired color.  The method returns the index of that color in the image's color table.  You should store these indexes for later use." 5
.Ip "3. Now you can do some drawing!  The various graphics primitives are described below.  In this example, we do some text drawing, create an oval, and create and draw a polygon." 5
.Ip "4. Polygons are created with a new() message to \s-1GD::\s0Polygon.  You can add points to the returned polygon one at a time using the addPt() method. The polygon can then be passed to an image for rendering." 5
.Ip "5. When you're done drawing, you can convert the image into \s-1GIF\s0 format by sending it a gif() message.  It will return a (potentially large) scalar value containing the binary data for the image.  Ordinarily you will print it out at this point or write it to a file." 5
.SH "Method Calls"
.Sh "Creating and Saving Images"
.Ip "\f(CWnew\fR" 5
\f(CWGD::Image::new(width,height)\fR \fIclass method\fR
.Sp
To create a new, blank image, send a \fInew()\fR message to the \s-1GD::\s0Image
class.  For example:
.Sp
.Vb 1
\&        $myImage = new GD::Image(100,100) || die;
.Ve
This will create an image that is 100 x 100 pixels wide.  If you don't
specify the dimensions, a default of 64 x 64 will be chosen. If
something goes wrong (e.g. insufficient memory), this call will
return undef.
.Ip "\f(CWnewFromGif\fR" 5
\f(CWGD::Image::newFromGif(FILEHANDLE)\fR \fIclass method\fR
.Sp
This will create an image from a \s-1GIF\s0 file read in through the provided
filehandle.  The filehandle must previously have been opened on a
valid \s-1GIF\s0 file or pipe.  If successful, this call will return an
initialized image which you can then manipulate as you please.  If it
fails, which usually happens if the thing at the other end of the
filehandle is not a valid \s-1GIF\s0 file, the call returns undef.  Notice
that the call doesn't automatically close the filehandle for you.
.Sp
To get information about the size and color usage of the information,
you can call the image query methods described below.
.Sp
.Vb 1
\&        Example usage:
.Ve
.Vb 3
\&        open (GIF,"barnswallow.gif") || die;
\&        $myImage = newFromGif GD::Image(GIF) || die;
\&        close GIF;
.Ve
.Ip "\f(CWnewFromXbm\fR" 5
\f(CWGD::Image::newFromXbm(FILEHANDLE)\fR \fIclass method\fR
.Sp
This works in exactly the same way as \f(CWnewFromGif\fR, but reads the
contents of an X Bitmap file:
.Sp
.Vb 3
\&        open (XBM,"coredump.xbm") || die;
\&        $myImage = newFromXbm GD::Image(XBM) || die;
\&        close XBM;
.Ve
.Ip "\f(CWnewFromGd\fR" 5
\f(CWGD::Image::newFromGd(FILEHANDLE)\fR \fIclass method\fR
.Sp
This works in exactly the same way as \f(CWnewFromGif\fR, but reads the
contents of a \s-1GD\s0 file.  \s-1GD\s0 is Tom Boutell's disk-based storage format,
intended for the rare case when you need to read and write the image
to disk quickly.  It's not intended for regular use, because, unlike
\s-1GIF\s0 or \s-1JPEG\s0, no image compression is performed and these files can
become \fB\s-1BIG\s0\fR.
.Sp
.Vb 3
\&        open (GDF,"godzilla.gd") || die;
\&        $myImage = newFromGd GD::Image(GDF) || die;
\&        close GDF;
.Ve
.Ip "\f(CWgif\fR" 5
\f(CWGD::Image::gif\fR \fIobject method\fR
.Sp
This returns the image data in \s-1GIF\s0 format.  You can then print it,
pipe it to a display program, or write it to a file.  Example:
.Sp
.Vb 4
\&        $gif_data = $myImage->gif;
\&        open (DISPLAY,"| display -") || die;
\&        print DISPLAY $gif_data;
\&        close DISPLAY;
.Ve
.Ip "\f(CWgd\fR" 5
\f(CWGD::Image::gd\fR \fIobject method\fR
.Sp
This returns the image data in \s-1GD\s0 format.  You can then print it,
pipe it to a display program, or write it to a file.  Example:
.Sp
.Vb 1
\&        print MYOUTFILE $myImage->gd;
.Ve
.Sh "Color Control"
.Ip "\f(CWcolorAllocate\fR" 5
\f(CWGD::Image::colorAllocate(red,green,blue)\fR \fIobject method\fR
.Sp
This allocates a color with the specified red, green and blue
components and returns its index in the color table, if specified.
The first color allocated in this way becomes the image's background
color.  (255,255,255) is white (all pixels on).  (0,0,0) is black (all
pixels off).  (255,0,0) is fully saturated red.  (127,127,127) is 50%
gray.  You can find plenty of examples in /usr/X11/lib/X11/rgb.txt.
.Sp
If no colors are allocated, then this function returns \-1.
.Sp
Example:
.Sp
.Vb 3
\&        $white = $myImage->colorAllocate(0,0,0); #background color
\&        $black = $myImage->colorAllocate(255,255,255);
\&        $peachpuff = $myImage->colorAllocate(255,218,185);
.Ve
.Ip "\f(CWcolorDeallocate\fR" 5
\f(CWGD::Image::colorDeallocate(colorIndex)\fR \fIobject method\fR 
.Sp
This marks the color at the specified index as being ripe for
reallocation.  The next time colorAllocate is used, this entry will be
replaced.  You can call this method several times to deallocate
multiple colors.  There's no function result from this call.
.Sp
Example:
.Sp
.Vb 2
\&        $myImage->colorDeallocate($peachpuff);
\&        $peachy = $myImage->colorAllocate(255,210,185);
.Ve
.Ip "\f(CWcolorClosest\fR" 5
\f(CWGD::Image::colorClosest(red,green,blue)\fR \fIobject method\fR
.Sp
This returns the index of the color closest in the color table to the
red green and blue components specified.  If no colors have yet been
allocated, then this call returns \-1.
.Sp
Example:
.Sp
.Vb 1
\&        $apricot = $myImage->colorClosest(255,200,180);
.Ve
.Ip "\f(CWcolorExact\fR" 5
\f(CWGD::Image::colorExact(red,green,blue)\fR \fIobject method\fR
.Sp
This returns the index of a color that exactly matches the specified
red green and blue components.  If such a color is not in the color
table, this call returns \-1.
.Sp
.Vb 2
\&        $rosey = $myImage->colorExact(255,100,80);
\&        warn "Everything's coming up roses.\en" if $rosey >= 0;
.Ve
.Ip "\f(CWcolorsTotal\fR" 5
\f(CWGD::Image::colorsTotal)\fR \fIobject method\fR
.Sp
This returns the total number of colors allocated in the object.
.Sp
.Vb 1
\&        $maxColors = $myImage->colorsTotal;
.Ve
.Ip "\f(CWgetPixel\fR" 5
\f(CWGD::Image::getPixel(x,y)\fR \fIobject method\fR
.Sp
This returns the color table index underneath the specified
point.  It can be combined with \fIrgb()\fR
to obtain the rgb color underneath the pixel.
.Sp
Example:
.Sp
.Vb 2
\&        $index = $myImage->getPixel(20,100);
\&        ($r,$g,$b) = $myImage->rgb($index);
.Ve
.Ip "\f(CWrgb\fR" 5
\f(CWGD::Image::rgb(colorIndex)\fR \fIobject method\fR
.Sp
This returns a list containing the red, green and blue components of
the specified color index.
.Sp
Example:
.Sp
.Vb 1
\&        @RGB = $myImage->rgb($peachy);
.Ve
.Ip "\f(CWtransparent\fR" 5
\f(CWGD::Image::transparent(colorIndex)\fR \fIobject method\fR
.Sp
This marks the color at the specified index as being transparent.
Portions of the image drawn in this color will be invisible.  This is
useful for creating paintbrushes of odd shapes, as well as for
making \s-1GIF\s0 backgrounds transparent for displaying on the Web.  Only
one color can be transparent at any time. To disable transparency, 
specify \-1 for the index.  
.Sp
If you call this method without any parameters, it will return the
current index of the transparent color, or \-1 if none.
.Sp
Example:
.Sp
.Vb 5
\&        open(GIF,"test.gif");
\&        $im = newFromGif GD::Image(GIF);
\&        $white = $im->colorClosest(255,255,255); # find white
\&        $im->transparent($white);
\&        print $im->gif;
.Ve
.Sh "Special Colors"
\s-1GD\s0 implements a number of special colors that can be used to achieve
special effects.  They are constants defined in the \s-1GD\s0::
namespace, but automatically exported into your namespace when the \s-1GD\s0
module is loaded.
.Ip "\f(CWsetBrush\fR" 5
.Ip "\f(CWgdBrushed\fR" 5
\f(CWGD::Image::setBrush( )\fR and \f(CWGD::gdBrushed\fR
.Sp
You can draw lines and shapes using a brush pattern.  Brushes are 
just images that you can create and manipulate in the usual way. When
you draw with them, their contents are used for the color and shape of
the lines.
.Sp
To make a brushed line, you must create or load the brush first, then
assign it to the image using \f(CWsetBrush\fR.  You can then draw in that
with that brush using the \f(CWgdBrushed\fR special color.  It's often 
useful to set the background of the brush to transparent so that 
the non-colored parts don't overwrite other parts of your image.
.Sp
Example:
.Sp
.Vb 6
\&        # Create a brush at an angle
\&        $diagonal_brush = new GD::Image(5,5);
\&        $white = $diagonal_brush->allocateColor(255,255,255);
\&        $black = $diagonal_brush->allocateColor(0,0,0);
\&        $diagonal_brush->transparent($white);
\&        $diagonal_brush->line(0,4,4,0,$black); # NE diagonal
.Ve
.Vb 5
\&        # Set the brush
\&        $myImage->setBrush($diagonal_brush);
\&        
\&        # Draw a circle using the brush
\&        $myImage->arc(50,50,25,25,0,360,gdBrushed);
.Ve
.Ip "\f(CWsetStyle\fR" 5
.Ip "\f(CWgdStyled\fR" 5
\f(CWGD::Image::setStyle(@colors)\fR and \f(CWGD::gdStyled\fR
.Sp
Styled lines consist of an arbitrary series of repeated colors and are
useful for generating dotted and dashed lines.  To create a styled
line, use \f(CWsetStyle\fR to specify a repeating series of colors.  It
accepts an array consisting of one or more color indexes.  Then
draw using the \f(CWgdStyled\fR special color.  Another special color,
\f(CWgdTransparent\fR can be used to introduce holes in the line, as the
example shows.
.Sp
Example:
.Sp
.Vb 6
\&        # Set a style consisting of 4 pixels of yellow,
\&        # 4 pixels of blue, and a 2 pixel gap
\&        $myImage->setStyle($yellow,$yellow,$yellow,$yellow,
\&                           $blue,$blue,$blue,$blue,
\&                           gdTransparent,gdTransparent);
\&        $myImage->arc(50,50,25,25,0,360,gdStyled);
.Ve
To combine the \f(CWgdStyled\fR and \f(CWgdBrushed\fR behaviors, you can specify
\f(CWgdStyledBrushed\fR.  In this case, a pixel from the current brush
pattern is rendered wherever the color specified in \fIsetStyle()\fR is
neither gdTransparent nor 0.
.Ip "\f(CWgdTiled\fR" 5
Draw filled shapes and flood fills using a pattern.  The pattern is
just another image.  The image will be tiled multiple times in order
to fill the required space, creating wallpaper effects.  You must call
\f(CWsetTile\fR in order to define the particular tile pattern you'll use
for drawing when you specify the gdTiled color.
details.
.Ip "\f(CWgdStyled\fR" 5
The gdStyled color is used for creating dashed and dotted lines.  A
styled line can contain any series of colors and is created using the
\f(CWsetStyled\fR command.
.Sh "Drawing Commands"
.Ip "\f(CWsetPixel\fR" 5
\f(CWGD::Image::setPixel(x,y,color)\fR \fIobject method\fR 
.Sp
This sets the pixel at (x,y) to the specified color index.  No value
is returned from this method.  The coordinate system starts at the
upper left at (0,0) and gets larger as you go down and to the right.
You can use a real color, or one of the special colors gdBrushed, 
gdStyled and gdStyledBrushed can be specified.
.Sp
Example:
.Sp
.Vb 2
\&        # This assumes $peach already allocated
\&        $myImage->setPixel(50,50,$peach);
.Ve
.Ip "\f(CWline\fR" 5
\f(CWGD::Image::line(x1,y1,x2,y2,color)\fR \fIobject method\fR
.Sp
This draws a line from (x1,y1) to (x2,y2) of the specified color.  You
can use a real color, or one of the special colors gdBrushed, 
gdStyled and gdStyledBrushed.
.Sp
Example:
.Sp
.Vb 3
\&        # Draw a diagonal line using the currently defind
\&        # paintbrush pattern.
\&        $myImage->line(0,0,150,150,gdBrushed);
.Ve
.Ip "\f(CWdashedLine\fR" 5
\f(CWGD::Image::dashedLine(x1,y1,x2,y2,color)\fR \fIobject method\fR
.Sp
This draws a dashed line from (x1,y1) to (x2,y2) in the specified
color.  A more powerful way to generate arbitrary dashed and dotted
lines is to use the \fIsetStyle()\fR method described below and to draw with
the special color gdStyled.
.Sp
Example:
.Sp
.Vb 1
\&        $myImage->dashedLine(0,0,150,150,$blue);
.Ve
.Ip "\f(CWrectangle\fR" 5
\f(CWGD::Image::rectangle(x1,y1,x2,y2,color)\fR \fIobject method\fR
.Sp
This draws a rectangle with the specified color.  (x1,y1) and (x2,y2)
are the upper left and lower right corners respectively.  Both real 
color indexes and the special colors gdBrushed, gdStyled and 
gdStyledBrushed are accepted.
.Sp
Example:
.Sp
.Vb 1
\&        $myImage->rectangle(10,10,100,100,$rose);
.Ve
.Ip "\f(CWfilledRectangle\fR" 5
\f(CWGD::Image::filledRectangle(x1,y1,x2,y2,color)\fR \fIobject method\fR
.Sp
This draws a rectangle filed with the specified color.  You can use a
real color, or the special fill color gdTiled to fill the polygon
with a pattern.
.Sp
Example:
.Sp
.Vb 4
\&        # read in a fill pattern and set it
\&        open(GIF,"happyface.gif") || die;
\&        $tile = newFromGif GD::Image(GIF);
\&        $myImage->setTile($tile); 
.Ve
.Vb 2
\&        # draw the rectangle, filling it with the pattern
\&        $myImage->filledRectangle(10,10,150,200,gdTiled);
.Ve
.Ip "\f(CWpolygon\fR" 5
\f(CWGD::Image::polygon(polygon,color)\fR \fIobject method\fR 
.Sp
This draws a polygon with the specified color.  The polygon must be
created first (see below).  The polygon must have at least three
vertices.  If the last vertex doesn't close the polygon, the method
will close it for you.  Both real color indexes and the special 
colors gdBrushed, gdStyled and gdStyledBrushed can be specified.
.Sp
Example:
.Sp
.Vb 5
\&        $poly = new GD::Polygon;
\&        $poly->addPt(50,0);
\&        $poly->addPt(99,99);
\&        $poly->addPt(0,99);
\&        $myImage->polygon($poly,$blue);
.Ve
.Ip "\f(CWfilledPolygon\fR" 5
\f(CWGD::Image::filledPolygon(poly,color)\fR \fIobject method\fR
.Sp
This draws a polygon filled with the specified color.  You can use a
real color, or the special fill color gdTiled to fill the polygon
with a pattern.
.Sp
Example:
.Sp
.Vb 5
\&        # make a polygon
\&        $poly = new GD::Polygon;
\&        $poly->addPt(50,0);
\&        $poly->addPt(99,99);
\&        $poly->addPt(0,99);
.Ve
.Vb 2
\&        # draw the polygon, filling it with a color
\&        $myImage->filledPolygon($poly,$peachpuff);
.Ve
.Ip "\f(CWarc\fR" 5
\f(CWGD::Image::arc(cx,cy,width,height,start,end,color)\fR \fIobject method\fR
.Sp
This draws arcs and ellipses.  (cx,cy) are the center of the arc, and
(width,height) specify the width and height, respectively.  The
portion of the ellipse covered by the arc are controlled by start and
end, both of which are given in degrees from 0 to 360.  Zero is at the
top of the ellipse, and angles increase clockwise.  To specify a
complete ellipse, use 0 and 360 as the starting and ending angles.  To
draw a circle, use the same value for width and height.
.Sp
You can specify a normal color or one of the special colors gdBrushed,
gdStyled, or gdStyledBrushed.
.Sp
Example:
.Sp
.Vb 2
\&        # draw a semicircle centered at 100,100
\&        $myImage->arc(100,100,50,50,0,180,$blue);
.Ve
.Ip "\f(CWfill\fR" 5
\f(CWGD::Image::fill(x,y,color)\fR \fIobject method\fR
.Sp
This method flood-fills regions with the specified color.  The color
will spread through the image, starting at point (x,y), until it is
stopped by a pixel of a different color from the starting pixel (this
is similar to the \*(L"paintbucket\*(R" in many popular drawing toys).  You
can specify a normal color, or the special color gdTiled, to flood-fill
with patterns.
.Sp
Example:
.Sp
.Vb 3
\&        # Draw a rectangle, and then make its interior blue
\&        $myImage->rectangle(10,10,100,100,$black);
\&        $myImage->fill(50,50,$blue);
.Ve
.Ip "\f(CWGD::Image::fillToBorder(x,y,bordercolor,color)\fR \fIobject method\fR" 5
Like \f(CWfill\fR, this method flood-fills regions with the specified color,
starting at position (x,y).
However, instead of stopping when it hits a pixel of a different color
than the starting pixel, flooding will only stop when it hits the
color specified by bordercolor.  You must specify a normal indexed
color for the bordercolor.  However, you are free to use the gdTiled
color for the fill.
.Sp
Example:
.Sp
.Vb 3
\&        # This has the same effect as the previous example
\&        $myImage->rectangle(10,10,100,100,$black);
\&        $myImage->fillToBorder(50,50,$black,$blue);
.Ve
.Sh "Image Copying Commands"
Two methods are provided for copying a rectangular region from one
image to another.  One method copies a region without resizing it.
The other allows you to stretch the region during the copy operation.
.PP
With either of these methods it is important to know that the routines
will attempt to flesh out the destination image's color table to match
the colors that are being copied from the source.  If the
destination's color table is already full, then the routines will
attempt to find the best match, with varying results.
.Ip "\f(CWcopy\fR" 5
\f(CWGD::Image::copy(sourceImage,dstX,dstY,srcX,srcY,width,height)\fR \fIobject method\fR
.Sp
This is the simpler of the two copy operations, copying the specified
region from the source image to the destination image (the one
performing the method call).  (srcX,srcY) specify the upper left
corner of a rectangle in the source image, and (width,height) give the
width and height of the region to copy.  (dstX,dstY) control where in
the destination image to stamp the copy.  You can use the same image
for both the source and the destination, but the source and
destination regions must not overlap or strange things will happen.
.Sp
Example:
.Sp
.Vb 7
\&        $myImage = new GD::Image(100,100);
\&        ... various drawing stuff ...
\&        $srcImage = new GD::Image(50,50);
\&        ... more drawing stuff ...
\&        # copy a 25x25 pixel region from $srcImage to
\&        # the rectangle starting at (10,10) in $myImage
\&        $myImage->copy($srcImage,10,10,0,0,25,25);
.Ve
.Ip "\f(CWcopyResized\fR" 5
\f(CWGD::Image::copyResized(sourceImage,dstX,dstY,srcX,srcY,destW,destH,srcW,srcH)\fR \fIobject method\fR
.Sp
This method is similar to \fIcopy()\fR but allows you to choose different
sizes for the source and destination rectangles.  The source and
destination rectangle's are specified independently by (srcW,srcH) and
(destW,destH) respectively.  \fIcopyResized()\fR will stretch or shrink the
image to accomodate the size requirements.
.Sp
Example:
.Sp
.Vb 7
\&        $myImage = new GD::Image(100,100);
\&        ... various drawing stuff ...
\&        $srcImage = new GD::Image(50,50);
\&        ... more drawing stuff ...
\&        # copy a 25x25 pixel region from $srcImage to
\&        # a larger rectangle starting at (10,10) in $myImage
\&        $myImage->copyResized($srcImage,10,10,0,0,50,50,25,25);
.Ve
.Sh "Character and String Drawing"
Gd allows you to draw characters and strings, either in normal
horizontal orientation or rotated 90 degrees.  These routines use a
\s-1GD::\s0Font object, described in more detail below.  There are four
built-in fonts, available in global variables gdLargeFont,
gdMediumBoldFont, gdSmallFont and gdTinyFont.  Currently there is no
way of dynamically creating your own fonts.
.Ip "\f(CWstring\fR" 5
\f(CWGD::Image::string(font,x,y,string,color)\fR \fIObject Method\fR
.Sp
This method draws a string startin at position (x,y) in the specified
font and color.  Your choices of fonts are gdSmallFont, gdMediumBoldFont,
gdTinyFont and gdLargeFont.
.Sp
Example:
.Sp
.Vb 1
\&        $myImage->string(gdSmallFont,2,10,"Peachy Keen",$peach);
.Ve
.Ip "\f(CWstringUp\fR" 5
\f(CWGD::Image::stringUp(font,x,y,string,color)\fR \fIObject Method\fR
.Sp
Just like the previous call, but draws the text rotated
counterclockwise 90 degrees.
.Ip "\f(CWchar\fR" 5
.Ip "\f(CWcharUp\fR" 5
\f(CWGD::Image::char(font,x,y,char,color)\fR \fIObject Method\fR
\f(CWGD::Image::charUp(font,x,y,char,color)\fR \fIObject Method\fR
.Sp
These methods draw single characters at position (x,y) in the
specified font and color.  They're carry-overs from the C interface,
where there is a distinction between characters and strings.  Perl is
insensible to such subtle distinctions.
.Sh "Miscellaneous Image Methods"
.Ip "\f(CWinterlaced\fR" 5
\f(CWGD::Image::interlaced( )\fR \f(CWGD::Image::interlaced(1)\fR \fIObject method\fR
.Sp
This method sets or queries the image's interlaced setting.  Interlace
produces a cool venetian blinds effect on certain viewers.  Provide a
true parameter to set the interlace attribute.  Provide undef to
disable it.  Call the method without parameters to find out the
current setting.
.Ip "c<getBounds>" 5
\f(CWGD::Image::getBounds( )\fR \fIObject method\fR
.Sp
This method will return a two-member list containing the width and
height of the image.  You query but not not change the size of the
image once it's created.
.Sh "Polygon Methods"
A few primitive polygon creation and manipulation methods are
provided.  They aren't part of the Gd library, but I thought they
might be handy to have around (they're borrowed from my qd.pl
Quickdraw library).
.Ip "c<new>" 5
\f(CWGD::Polygon::new\fR \fIclass method\fR
.Sp
Create an empty polygon with no vertices.
.Sp
.Vb 1
\&        $poly = new GD::Polygon;
.Ve
.Ip "\f(CWaddPt\fR" 5
\f(CWGD::Polygon::addPt(x,y)\fR \fIobject method\fR
.Sp
Add point (x,y) to the polygon.
.Sp
.Vb 4
\&        $poly->addPt(0,0);
\&        $poly->addPt(0,50);
\&        $poly->addPt(25,25);
\&        $myImage->fillPoly($poly,$blue);
.Ve
.Ip "\f(CWgetPt\fR" 5
\f(CWGD::Polygon::getPt(index)\fR \fIobject method\fR
.Sp
Retrieve the point at the specified vertex.
.Sp
.Vb 1
\&        ($x,$y) = $poly->getPt(2);
.Ve
.Ip "\f(CWsetPt\fR" 5
\f(CWGD::Polygon::setPt(index,x,y)\fR \fIobject method\fR
.Sp
Change the value of an already existing vertex.  It is an error to set
a vertex that isn't already defined.
.Sp
.Vb 1
\&        $poly->setPt(2,100,100);
.Ve
.Ip "\f(CWdeletePt\fR" 5
\f(CWGD::Polygon:deletePt(index)\fR \fIobject method\fR
.Sp
Delete the specified vertex, returning its value.
.Sp
.Vb 1
\&        ($x,$y) = $poly->deletePt(1); 
.Ve
.Ip "\f(CWtoPt\fR" 5
\f(CWGD::Polygon::toPt(dx,dy)\fR \fIobject method\fR
.Sp
Draw from current vertex to a new vertex, using relative 
(dx,dy) coordinates.  If this is the first point, act like
\fIaddPt()\fR.
.Sp
.Vb 4
\&        $poly->addPt(0,0);
\&        $poly->toPt(0,50);
\&        $poly->toPt(25,-25);
\&        $myImage->fillPoly($poly,$blue);
.Ve
.Ip "\f(CWlength\fR" 5
\f(CWGD::Polygon::length\fR \fIobject method\fR
.Sp
Return the number of vertices in the polygon.
.Sp
.Vb 1
\&        $points = $poly->length;
.Ve
.Ip "\f(CWvertices\fR" 5
\f(CWGD::Polygon::vertices\fR \fIobject method\fR
.Sp
Return a list of all the verticies in the polygon object.  Each
membver of the list is a reference to an (x,y) array.
.Sp
.Vb 4
\&        @vertices = $poly->vertices;
\&        foreach $v (@vertices)
\&           print join(",",@$v),"\en";
\&        }
.Ve
.Ip "\f(CWbounds\fR" 5
\f(CWGD::Polygon::bounds\fR \fIobject method\fR
.Sp
Return the smallest rectangle that completely encloses the polygon.
The return value is an array containing the (left,top,right,bottom) of
the rectangle.
.Sp
.Vb 1
\&        ($left,$top,$right,$bottom) = $poly->bounds;
.Ve
.Ip "\f(CWoffset\fR" 5
\f(CWGD::Polygon::offset(dx,dy)\fR \fIobject method\fR
.Sp
Offset all the vertices of the polygon by the specified horizontal
(dh) and vertical (dy) amounts.  Positive numbers move the polygon
down and to the right.
.Sp
.Vb 1
\&        $poly->offset(10,30);
.Ve
.Ip "\f(CWmap\fR" 5
\f(CWGD::Polygon::map(srcL,srcT,srcR,srcB,destL,dstT,dstR,dstB)\fR \fIobject method\fR
.Sp
Map the polygon from a source rectangle to an equivalent position in a
destination rectangle, moving it and resizing it as necessary.  See
polys.pl for an example of how this works.  Both the source and
destination rectangles are given in (left,top,right,bottom)
coordinates.  For convenience, you can use the polygon's own bounding
box as the source rectangle.
.Sp
.Vb 2
\&        # Make the polygon really tall
\&        $poly->map($poly->bounds,0,0,50,200);
.Ve
.Ip "\f(CWscale\fR" 5
\f(CWGD::Polygon::scale(sx,sy)\fR \fIobject method\fR
.Sp
Scale each vertex of the polygon by the X and Y factors indicated by
sx and sy.  For example \fIscale\fR\|(2,2) will make the polygon twice as
large.  For best results, move the center of the polygon to position
(0,0) before you scale, then move it back to its previous position.
.Ip "\f(CWtransform\fR" 5
\f(CWGD::Polygon::transform(sx,rx,sy,ry,tx,ty)\fR \fIobject method\fR
.Sp
Run each vertex of the polygon through a transformation matrix, where
sx and sy are the X and Y scaling factors, rx and ry are the X and Y
rotation factors, and tx and ty are X and Y offsets.  See the Adobe
PostScript Reference, page 154 for a full explanation, or experiment.
.Sh "Font Utilities"
Gd's support for fonts is minimal.  Basically you have access to
gdSmallFont and gdLargeFont for drawing, and not much else.  However,
for future compatibility, I've made the fonts into perl objects of
type \s-1GD::\s0Font that you can query and, perhaps someday manipulate.
.Ip "\f(CWgdSmallFont\fR" 5
\f(CWGD::Font::gdSmallFont\fR \fIconstant\fR
.Sp
This is the basic small font, \*(L"borrowed\*(R" from a well known public
domain 6x12 font.
.Ip "\f(CWgdLargeFont\fR" 5
\f(CWGD::Font::gdLargeFont\fR \fIconstant\fR
.Sp
This is the basic large font, \*(L"borrowed\*(R" from a well known public
domain 8x16 font.
.Ip "\f(CWgdMediumBoldFont\fR" 5
\f(CWGD::Font::gdMediumBoldFont\fR \fIconstant\fR
.Sp
This is a bold font intermediate in size between the small and large
fonts, borrowed from a public domain 7x13 font;
.Ip "\f(CWgdTinyFont\fR" 5
\f(CWGD::Font::gdTinyFont\fR \fIconstant\fR
.Sp
This is a tiny, almost unreadable font, 5x8 pixels wide.
.Ip "\f(CWnchars\fR" 5
\f(CWGD::Font::nchars\fR	\fIobject method\fR
.Sp
This returns the number of characters in the font.
.Sp
.Vb 1
\&        print "The large font contains ",gdLargeFont->nchars," characters\en";
.Ve
.Ip "\f(CWoffset\fR" 5
\f(CWGD::Font::offset\fR 	\fIobject method\fR
.Sp
This returns the \s-1ASCII\s0 value of the first character in the font
.Ip "\f(CWwidth\fR" 5
.Ip "\f(CWheight\fR" 5
\f(CWGD::Font::width\fR \f(CWGD::Font::height\fR	\fIobject methods\fR
.Sp
These return the width and height of the font.
.Sp
.Vb 1
\&        ($w,$h) = (gdLargeFont->width,gdLargeFont->height);
.Ve
.SH "Obtaining the C\-language version of gd"
libgd, the C\-language version of gd, can be obtained at URL
http://www.boutell.com/gd/gd.html.  Directions for installing and
using it can be found at that site.  Please do not contact me for help
with libgd.
.SH "Copyright Information"
The GD.pm interface is copyright 1995, Lincoln D. Stein.  You are free
to use it for any purpose, commercial or noncommercial, provided that
if you redistribute the source code this statement of copyright
remains attached. The gd library is covered separately under a 1994
copyright by Quest Protein Database Center, Cold Spring Harbor Labs
and Thomas Boutell.  For usage information see the gd documentation at
URL
.PP
.Vb 1
\&        http://www.boutell.com/gd/gd.html
.Ve
The latest versions of GD.pm are available at
.PP
.Vb 2
\&  http://www.genome.wi.mit.edu/ftp/pub/software/WWW/GD.html
\&  ftp://ftp-genome.wi.mit.edu/pub/software/WWW/GD.pm.tar.gz
.Ve

.rn }` ''
.IX Title "GD 3"
.IX Name "GD.pm - Interface to Gd Graphics Library"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "\f(CWGD::Image\fR"

.IX Item "\f(CWGD::Font\fR"

.IX Item "\f(CWGD::Polygon\fR"

.IX Item "1. To create a new, empty image, send a new() message to \s-1GD::\s0Image, passing it the width and height of the image you want to create.  An image object will be returned.  Other class methods allow you to initialize an image from a preexisting \s-1GIF\s0, \s-1GD\s0 or \s-1XBM\s0 file."

.IX Item "2. Next you will ordinarily add colors to the image's color table. colors are added using a colorAllocate() method call.  The three parameters in each call are the red, green and blue (rgb) triples for the desired color.  The method returns the index of that color in the image's color table.  You should store these indexes for later use."

.IX Item "3. Now you can do some drawing!  The various graphics primitives are described below.  In this example, we do some text drawing, create an oval, and create and draw a polygon."

.IX Item "4. Polygons are created with a new() message to \s-1GD::\s0Polygon.  You can add points to the returned polygon one at a time using the addPt() method. The polygon can then be passed to an image for rendering."

.IX Item "5. When you're done drawing, you can convert the image into \s-1GIF\s0 format by sending it a gif() message.  It will return a (potentially large) scalar value containing the binary data for the image.  Ordinarily you will print it out at this point or write it to a file."

.IX Header "Method Calls"

.IX Subsection "Creating and Saving Images"

.IX Item "\f(CWnew\fR"

.IX Item "\f(CWnewFromGif\fR"

.IX Item "\f(CWnewFromXbm\fR"

.IX Item "\f(CWnewFromGd\fR"

.IX Item "\f(CWgif\fR"

.IX Item "\f(CWgd\fR"

.IX Subsection "Color Control"

.IX Item "\f(CWcolorAllocate\fR"

.IX Item "\f(CWcolorDeallocate\fR"

.IX Item "\f(CWcolorClosest\fR"

.IX Item "\f(CWcolorExact\fR"

.IX Item "\f(CWcolorsTotal\fR"

.IX Item "\f(CWgetPixel\fR"

.IX Item "\f(CWrgb\fR"

.IX Item "\f(CWtransparent\fR"

.IX Subsection "Special Colors"

.IX Item "\f(CWsetBrush\fR"

.IX Item "\f(CWgdBrushed\fR"

.IX Item "\f(CWsetStyle\fR"

.IX Item "\f(CWgdStyled\fR"

.IX Item "\f(CWgdTiled\fR"

.IX Item "\f(CWgdStyled\fR"

.IX Subsection "Drawing Commands"

.IX Item "\f(CWsetPixel\fR"

.IX Item "\f(CWline\fR"

.IX Item "\f(CWdashedLine\fR"

.IX Item "\f(CWrectangle\fR"

.IX Item "\f(CWfilledRectangle\fR"

.IX Item "\f(CWpolygon\fR"

.IX Item "\f(CWfilledPolygon\fR"

.IX Item "\f(CWarc\fR"

.IX Item "\f(CWfill\fR"

.IX Item "\f(CWGD::Image::fillToBorder(x,y,bordercolor,color)\fR \fIobject method\fR"

.IX Subsection "Image Copying Commands"

.IX Item "\f(CWcopy\fR"

.IX Item "\f(CWcopyResized\fR"

.IX Subsection "Character and String Drawing"

.IX Item "\f(CWstring\fR"

.IX Item "\f(CWstringUp\fR"

.IX Item "\f(CWchar\fR"

.IX Item "\f(CWcharUp\fR"

.IX Subsection "Miscellaneous Image Methods"

.IX Item "\f(CWinterlaced\fR"

.IX Item "c<getBounds>"

.IX Subsection "Polygon Methods"

.IX Item "c<new>"

.IX Item "\f(CWaddPt\fR"

.IX Item "\f(CWgetPt\fR"

.IX Item "\f(CWsetPt\fR"

.IX Item "\f(CWdeletePt\fR"

.IX Item "\f(CWtoPt\fR"

.IX Item "\f(CWlength\fR"

.IX Item "\f(CWvertices\fR"

.IX Item "\f(CWbounds\fR"

.IX Item "\f(CWoffset\fR"

.IX Item "\f(CWmap\fR"

.IX Item "\f(CWscale\fR"

.IX Item "\f(CWtransform\fR"

.IX Subsection "Font Utilities"

.IX Item "\f(CWgdSmallFont\fR"

.IX Item "\f(CWgdLargeFont\fR"

.IX Item "\f(CWgdMediumBoldFont\fR"

.IX Item "\f(CWgdTinyFont\fR"

.IX Item "\f(CWnchars\fR"

.IX Item "\f(CWoffset\fR"

.IX Item "\f(CWwidth\fR"

.IX Item "\f(CWheight\fR"

.IX Header "Obtaining the C\-language version of gd"

.IX Header "Copyright Information"

