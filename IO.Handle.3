.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH IO::Handle 3 "perl 5.004, patch 01" "9/Apr/97" "Perl Programmers Reference Guide"
.IX Title "IO::Handle 3"
.UC
.IX Name "IO::Handle - supply object methods for I/O handles"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
IO::Handle \- supply object methods for I/O handles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 1
\&    use IO::Handle;
.Ve
.Vb 5
\&    $fh = new IO::Handle;
\&    if ($fh->fdopen(fileno(STDIN),"r")) {
\&        print $fh->getline;
\&        $fh->close;
\&    }
.Ve
.Vb 4
\&    $fh = new IO::Handle;
\&    if ($fh->fdopen(fileno(STDOUT),"w")) {
\&        $fh->print("Some text\en");
\&    }
.Ve
.Vb 1
\&    $fh->setvbuf($buffer_var, _IOLBF, 1024);
.Ve
.Vb 1
\&    undef $fh;       # automatically closes the file if it's open
.Ve
.Vb 1
\&    autoflush STDOUT 1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\f(CWIO::Handle\fR is the base class for all other IO handle classes. It is
not intended that objects of \f(CWIO::Handle\fR would be created directly,
but instead \f(CWIO::Handle\fR is inherited from by several other classes
in the IO hierarchy.
.PP
If you are reading this documentation, looking for a replacement for
the \f(CWFileHandle\fR package, then I suggest you read the documentation
for \f(CWIO::File\fR
.PP
A \f(CWIO::Handle\fR object is a reference to a symbol (see the \f(CWSymbol\fR package)
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.Ip "new ()" 4
.IX Item "new ()"
Creates a new \f(CWIO::Handle\fR object.
.Ip "new_from_fd ( \s-1FD\s0, \s-1MODE\s0 )" 4
.IX Item "new_from_fd ( \s-1FD\s0, \s-1MODE\s0 )"
Creates a \f(CWIO::Handle\fR like \f(CWnew\fR does.
It requires two parameters, which are passed to the method \f(CWfdopen\fR;
if the fdopen fails, the object is destroyed. Otherwise, it is returned
to the caller.
.SH "METHODS"
.IX Header "METHODS"
See the \fIperlfunc\fR manpage for complete descriptions of each of the following
supported \f(CWIO::Handle\fR methods, which are just front ends for the
corresponding built-in functions:
.PP
.Vb 11
\&    close
\&    fileno
\&    getc
\&    eof
\&    read
\&    truncate
\&    stat
\&    print
\&    printf
\&    sysread
\&    syswrite
.Ve
See the \fIperlvar\fR manpage for complete descriptions of each of the following
supported \f(CWIO::Handle\fR methods:
.PP
.Vb 13
\&    autoflush
\&    output_field_separator
\&    output_record_separator
\&    input_record_separator
\&    input_line_number
\&    format_page_number
\&    format_lines_per_page
\&    format_lines_left
\&    format_name
\&    format_top_name
\&    format_line_break_characters
\&    format_formfeed
\&    format_write
.Ve
Furthermore, for doing normal I/O you might need these:
.Ip "$fh->fdopen ( \s-1FD\s0, \s-1MODE\s0 )" 5
.IX Item "$fh->fdopen ( \s-1FD\s0, \s-1MODE\s0 )"
\f(CWfdopen\fR is like an ordinary \f(CWopen\fR except that its first parameter
is not a filename but rather a file handle name, a \s-1IO::\s0Handle object,
or a file descriptor number.
.Ip "$fh->opened" 5
.IX Item "$fh->opened"
Returns true if the object is currently a valid file descriptor.
.Ip "$fh->getline" 5
.IX Item "$fh->getline"
This works like <$fh> described in the section on \fII/O Operators\fR in the \fIperlop\fR manpage
except that it's more readable and can be safely called in an
array context but still returns just one line.
.Ip "$fh->getlines" 5
.IX Item "$fh->getlines"
This works like <$fh> when called in an array context to
read all the remaining lines in a file, except that it's more readable.
It will also \fIcroak()\fR if accidentally called in a scalar context.
.Ip "$fh->ungetc ( \s-1ORD\s0 )" 5
.IX Item "$fh->ungetc ( \s-1ORD\s0 )"
Pushes a character with the given ordinal value back onto the given
handle's input stream.
.Ip "$fh->write ( \s-1BUF\s0, \s-1LEN\s0 [, \s-1OFFSET\s0 }\e] )" 5
.IX Item "$fh->write ( \s-1BUF\s0, \s-1LEN\s0 [, \s-1OFFSET\s0 }\e] )"
This \f(CWwrite\fR is like \f(CWwrite\fR found in C, that is it is the
opposite of read. The wrapper for the perl \f(CWwrite\fR function is
called \f(CWformat_write\fR.
.Ip "$fh->flush" 5
.IX Item "$fh->flush"
Flush the given handle's buffer.
.Ip "$fh->error" 5
.IX Item "$fh->error"
Returns a true value if the given handle has experienced any errors
since it was opened or since the last call to \f(CWclearerr\fR.
.Ip "$fh->clearerr" 5
.IX Item "$fh->clearerr"
Clear the given handle's error indicator.
.PP
If the C functions \fIsetbuf()\fR and/or \fIsetvbuf()\fR are available, then
\f(CWIO::Handle::setbuf\fR and \f(CWIO::Handle::setvbuf\fR set the buffering
policy for an \s-1IO::\s0Handle.  The calling sequences for the Perl functions
are the same as their C counterparts\*(--including the constants \f(CW_IOFBF\fR,
\f(CW_IOLBF\fR, and \f(CW_IONBF\fR for \fIsetvbuf()\fR--except that the buffer parameter
specifies a scalar variable to use as a buffer.  \s-1WARNING\s0: A variable
used as a buffer by \f(CWsetbuf\fR or \f(CWsetvbuf\fR must not be modified in any
way until the \s-1IO::\s0Handle is closed or \f(CWsetbuf\fR or \f(CWsetvbuf\fR is called
again, or memory corruption may result!
.PP
Lastly, there is a special method for working under \fB\-T\fR and setuid/gid
scripts:
.Ip "$fh->untaint" 5
.IX Item "$fh->untaint"
Marks the object as taint-clean, and as such data read from it will also
be considered taint-clean. Note that this is a very trusting action to
take, and appropriate consideration for the data source and potential
vulnerability should be kept in mind.
.SH "NOTE"
.IX Header "NOTE"
A \f(CWIO::Handle\fR object is a GLOB reference. Some modules that
inherit from \f(CWIO::Handle\fR may want to keep object related variables
in the hash table part of the GLOB. In an attempt to prevent modules
trampling on each other I propose the that any such module should prefix
its variables with its own name separated by _'s. For example the IO::Socket
module keeps a \f(CWtimeout\fR variable in \*(L'io_socket_timeout\*(R'.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the \fIperlfunc\fR manpage, 
the section on \fII/O Operators\fR in the \fIperlop\fR manpage,
the \fIIO::File\fR manpage
.SH "BUGS"
.IX Header "BUGS"
Due to backwards compatibility, all filehandles resemble objects
of class \f(CWIO::Handle\fR, or actually classes derived from that class.
They actually aren't.  Which means you can't derive your own 
class from \f(CWIO::Handle\fR and inherit those methods.
.SH "HISTORY"
.IX Header "HISTORY"
Derived from FileHandle.pm by Graham Barr <\fIbodg@tiuk.ti.com\fR>

.rn }` ''
