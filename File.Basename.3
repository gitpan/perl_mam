.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH File/Basename 3 "perl 5.003, patch 05" "16/Aug/96" "Perl Programmers Reference Guide"
.IX Title "File/Basename 3"
.UC
.IX Name "Basename - parse file specifications"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
Basename \- parse file specifications
.PP
fileparse \- split a pathname into pieces
.PP
basename \- extract just the filename from a path
.PP
dirname \- extract just the directory from a path
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 1
\&    use File::Basename;
.Ve
.Vb 4
\&    ($name,$path,$suffix) = fileparse($fullname,@suffixlist)
\&    fileparse_set_fstype($os_string);
\&    $basename = basename($fullname,@suffixlist);
\&    $dirname = dirname($fullname);
.Ve
.Vb 4
\&    ($name,$path,$suffix) = fileparse("lib/File/Basename.pm","\e.pm");
\&    fileparse_set_fstype("VMS");
\&    $basename = basename("lib/File/Basename.pm",".pm");
\&    $dirname = dirname("lib/File/Basename.pm");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These routines allow you to parse file specifications into useful
pieces using the syntax of different operating systems.
.Ip "fileparse_set_fstype" 4
.IX Item "fileparse_set_fstype"
You select the syntax via the routine \fIfileparse_set_fstype()\fR.
If the argument passed to it contains one of the substrings
\*(L"\s-1VMS\s0\*(R", \*(L"\s-1MSDOS\s0\*(R", or \*(L"MacOS\*(R", the file specification syntax of that
operating system is used in future calls to \fIfileparse()\fR,
\fIbasename()\fR, and \fIdirname()\fR.  If it contains none of these
substrings, \s-1UNIX\s0 syntax is used.  This pattern matching is
case-insensitive.  If you've selected \s-1VMS\s0 syntax, and the file
specification you pass to one of these routines contains a \*(L"/\*(R",
they assume you are using \s-1UNIX\s0 emulation and apply the \s-1UNIX\s0 syntax
rules instead, for that function call only.
.Sp
If you haven't called \fIfileparse_set_fstype()\fR, the syntax is chosen
by examining the builtin variable \f(CW$^O\fR according to these rules.
.Ip "fileparse" 4
.IX Item "fileparse"
The \fIfileparse()\fR routine divides a file specification into three
parts: a leading \fBpath\fR, a file \fBname\fR, and a \fBsuffix\fR.  The
\fBpath\fR contains everything up to and including the last directory
separator in the input file specification.  The remainder of the input
file specification is then divided into \fBname\fR and \fBsuffix\fR based on
the optional patterns you specify in \f(CW@suffixlist\fR.  Each element of
this list is interpreted as a regular expression, and is matched
against the end of \fBname\fR.  If this succeeds, the matching portion of
\fBname\fR is removed and prepended to \fBsuffix\fR.  By proper use of
\f(CW@suffixlist\fR, you can remove file types or versions for examination.
.Sp
You are guaranteed that if you concatenate \fBpath\fR, \fBname\fR, and
\fBsuffix\fR together in that order, the result will denote the same
file as the input file specification.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Using UNIX file syntax:
.PP
.Vb 2
\&    ($base,$path,$type) = fileparse('/virgil/aeneid/draft.book7',
\&                                    '\e.book\ed+');
.Ve
would yield
.PP
.Vb 3
\&    $base eq 'draft'
\&    $path eq '/virgil/aeneid/',
\&    $tail eq '.book7'
.Ve
Similarly, using VMS syntax:
.PP
.Vb 2
\&    ($name,$dir,$type) = fileparse('Doc_Root:[Help]Rhetoric.Rnh',
\&                                   '\e..*');
.Ve
would yield
.PP
.Vb 3
\&    $name eq 'Rhetoric'
\&    $dir  eq 'Doc_Root:[Help]'
\&    $type eq '.Rnh'
.Ve
.Ip "\f(CWbasename\fR" 0
.IX Item "\f(CWbasename\fR"
The \fIbasename()\fR routine returns the first element of the list produced
by calling \fIfileparse()\fR with the same arguments.  It is provided for
compatibility with the \s-1UNIX\s0 shell command \fIbasename\fR\|(1).
.Ip "\f(CWdirname\fR" 0
.IX Item "\f(CWdirname\fR"
The \fIdirname()\fR routine returns the directory portion of the input file
specification.  When using \s-1VMS\s0 or MacOS syntax, this is identical to the
second element of the list produced by calling \fIfileparse()\fR with the same
input file specification.  (Under \s-1VMS\s0, if there is no directory information
in the input file specification, then the current default device and
directory are returned.)  When using \s-1UNIX\s0 or \s-1MSDOS\s0 syntax, the return
value conforms to the behavior of the \s-1UNIX\s0 shell command \fIdirname\fR\|(1).  This
is usually the same as the behavior of \fIfileparse()\fR, but differs in some
cases.  For example, for the input file specification \fIlib/\fR, \fIfileparse()\fR
considers the directory name to be \fIlib/\fR, while \fIdirname()\fR considers the
directory name to be \fI.\fR).

.rn }` ''
