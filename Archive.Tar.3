.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Tar 3 "perl 5.005, patch 52" "29/Jul/98" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Tar \- module for manipulation of tar archives.
.SH "SYNOPSIS"
.PP
.Vb 1
\&  use Archive::Tar;
.Ve
.Vb 5
\&  $tar = Archive::Tar->new();
\&  $tar->read("origin.tar.gz",1);
\&  $tar->add_files("file/foo.c", "file/bar.c");
\&  $tar->add_data("file/baz.c","This is the file contents");
\&  $tar->write("files.tar");
.Ve
.SH "DESCRIPTION"
This is a module for the handling of tar archives. 
.PP
At the moment these methods are implemented:
.Ip "\f(CWnew()\fR" 4
Returns a new Tar object. If given a filename as an argument, it will
try to load that as a tar file. If given a true value as a second
argument, will assume that the tar file is compressed, and will
attempt to read it using the \fICompress::Zlib\fR manpage.
.Ip "\f(CWadd_files(@filenamelist)\fR" 4
Takes a list of filenames and adds them to the in-memory archive.  On
MacOS, the path to the file is automatically converted to a Unix like
equivalent for use in the archive, and the file's modification time is
converted from the MacOS to the Unix zero of time.  So tar archives
created on MacOS with \fBArchive::Tar\fR can be read both with \fItar\fR on
Unix and applications like \fIsuntar\fR or \fIStuffit Expander\fR on MacOS.
Also be aware that the file's type/creator and resource fork will be
lost, which is usually what you want in cross-platform archives.
.Ip "\f(CWadd_data($filename,$data,$opthashref)\fR" 4
Takes a filename, a scalar full of data and optionally a reference to
a hash with specific options. Will add a file to the in-memory
archive, with name \f(CW$filename\fR and content \f(CW$data\fR. Specific options
can be set using \f(CW$opthashref\fR, which will be documented later.  (On
MacOS, the file's path and modification times are converted to Unix
equivalents.)
.Ip "\f(CWremove(@filenamelist)\fR" 4
Removes any entries with names matching any of the given filenames
from the in-memory archive. String comparisons are done with \f(CWeq\fR.
.Ip "\f(CWread('\fIfile.tar\fR',$compressed)\fR" 4
Try to read the given tarfile into memory. If the second argument is a
true value, the tarfile is assumed to be compressed. Will \fIreplace\fR
any previous content in \f(CW$tar\fR!
.Ip "\f(CWwrite('\fIfile.tar\fR',$compressed)\fR" 4
Will write the in-memory archive to disk. If no filename is given,
returns the entire formatted archive as a string, which should be
useful if you'd like to stuff the archive into a socket or a pipe to
gzip or something. If the second argument is true, the module will try
to write the file compressed.
.Ip "\f(CWdata()\fR" 4
Returns the in-memory archive. This is a list of references to hashes,
the internals of which is not currently documented.
.Ip "\f(CWextract(@filenames)\fR" 4
Write files whose names are equivalent to any of the names in
\f(CW@filenames\fR to disk, creating subdirectories as neccesary. This
might not work too well under \s-1VMS\s0.  Under MacPerl, the file's
modification time will be converted to the MacOS zero of time, and
appropriate conversions will be done to the path.  However, the length
of each element of the path is not inspected to see whether it's
longer than MacOS currently allows (32 characters).
.Ip "\f(CWlist_files()\fR" 4
Returns a list with the names of all files in the in-memory archive.
.Ip "\f(CWget_content($file)\fR" 4
Return the content of the named file.
.Ip "\f(CWreplace_content($file,$content)\fR" 4
Make the string \f(CW$content\fR be the content for the file named \f(CW$file\fR.
.SH "CHANGES"
.Ip "Version 0.08" 4
New developer/maintainer.  Calle has carpal-tunnel syndrome and cannot
type a great deal. Get better as soon as you can, Calle.
.Sp
Added proper support for MacOS.
Thanks to Paul J. Schinder <schinder@leprss.gsfc.nasa.gov>.
.Ip "Version 0.071" 4
Minor release.
.Sp
Arrange to \fIchmod()\fR at the very end in case it makes the file readonly.
Win32 is actually picky about that.
.Sp
SunOS 4.x tar makes tarfiles that contain directory entries
that don't have typeflag set properly.  We use the trailing
slash to recognize directories in such tarfiles.
.Ip "Version 0.07" 4
Fixed (hopefully) broken portability to MacOS, reported by Paul J.
Schinder at Goddard Space Flight Center.
.Sp
Fixed two bugs with symlink handling, reported in excellent detail by
an admin at teleport.com called Chris.
.Sp
Primive tar program (called ptar) included with distribution. Useage
should be pretty obvious if you've used a normal tar program.
.Sp
Added methods get_content and replace_content.
.Sp
Added support for paths longer than 100 characters, according to
\s-1POSIX\s0. This is compatible with just about everything except \s-1GNU\s0 tar.
Way to go, \s-1GNU\s0 tar (use a better tar, or \s-1GNU\s0 cpio). 
.Sp
\s-1NOTE\s0: When adding files to an archive, files with basenames longer
      than 100 characters will be silently ignored. If the prefix part
      of a path is longer than 155 characters, only the last 155
      characters will be stored.
.Ip "Version 0.06" 4
Added \fIlist_files()\fR method, as requested by Michael Wiedman.
.Sp
Fixed a couple of dysfunctions when run under Windows \s-1NT\s0. Michael
Wiedmann reported the bugs.
.Sp
Changed the documentation to reflect reality a bit better.
.Sp
Fixed bug in format_tar_entry. Bug reported by Michael Schilli.
.Ip "Version 0.05" 4
Quoted lots of barewords to make \f(CWuse strict;\fR stop complaining under
perl version 5.003.
.Sp
Ties to the \fICompress::Zlib\fR manpage put in. Will warn if it isn't available.
.Sp
$tar->\fIwrite()\fR with no argument now returns the formatted archive.
.Ip "Version 0.04" 4
Made changes to write_tar so that Solaris tar likes the resulting
archives better.
.Sp
Protected the calls to \fIreadlink()\fR and \fIsymlink()\fR. \s-1AFAIK\s0 this module
should now run just fine on Windows \s-1NT\s0.
.Sp
Add method to write a single entry to disk (extract)
.Sp
Added method to add entries entirely from scratch (add_data)
.Sp
Changed name of \fIadd()\fR to \fIadd_file()\fR
.Sp
All calls to \fIcroak()\fR removed and replaced with returning undef and
setting Tar::error.
.Sp
Better handling of tarfiles with garbage at the end.

.rn }` ''
.IX Title "Tar 3"
.IX Name "Tar - module for manipulation of tar archives."

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "\f(CWnew()\fR"

.IX Item "\f(CWadd_files(@filenamelist)\fR"

.IX Item "\f(CWadd_data($filename,$data,$opthashref)\fR"

.IX Item "\f(CWremove(@filenamelist)\fR"

.IX Item "\f(CWread('\fIfile.tar\fR',$compressed)\fR"

.IX Item "\f(CWwrite('\fIfile.tar\fR',$compressed)\fR"

.IX Item "\f(CWdata()\fR"

.IX Item "\f(CWextract(@filenames)\fR"

.IX Item "\f(CWlist_files()\fR"

.IX Item "\f(CWget_content($file)\fR"

.IX Item "\f(CWreplace_content($file,$content)\fR"

.IX Header "CHANGES"

.IX Item "Version 0.08"

.IX Item "Version 0.071"

.IX Item "Version 0.07"

.IX Item "Version 0.06"

.IX Item "Version 0.05"

.IX Item "Version 0.04"

