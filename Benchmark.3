.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Benchmark 3 "perl 5.004, patch 01" "3/Apr/97" "Perl Programmers Reference Guide"
.IX Title "Benchmark 3"
.UC
.IX Name "Benchmark - benchmark running times of code"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
Benchmark \- benchmark running times of code
.PP
timethis \- run a chunk of code several times
.PP
timethese \- run several chunks of code several times
.PP
timeit \- run a chunk of code and see how long it goes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 1
\&    timethis ($count, "code");
.Ve
.Vb 5
\&    # Use Perl code in strings...
\&    timethese($count, {
\&        'Name1' => '...code1...',
\&        'Name2' => '...code2...',
\&    });
.Ve
.Vb 5
\&    # ... or use subroutine references.
\&    timethese($count, {
\&        'Name1' => sub { ...code1... },
\&        'Name2' => sub { ...code2... },
\&    });
.Ve
.Vb 2
\&    $t = timeit($count, '...other code...')
\&    print "$count loops of other code took:",timestr($t),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Benchmark module encapsulates a number of routines to help you
figure out how long it takes to execute some code.
.Sh "Methods"
.IX Subsection "Methods"
.Ip "new" 10
.IX Item "new"
Returns the current time.   Example:
.Sp
.Vb 6
\&    use Benchmark;
\&    $t0 = new Benchmark;
\&    # ... your code here ...
\&    $t1 = new Benchmark;
\&    $td = timediff($t1, $t0);
\&    print "the code took:",timestr($td),"\en";
.Ve
.Ip "debug" 10
.IX Item "debug"
Enables or disable debugging by setting the \f(CW$Benchmark::Debug\fR flag:
.Sp
.Vb 3
\&    debug Benchmark 1;
\&    $t = timeit(10, ' 5 ** $Global ');
\&    debug Benchmark 0;
.Ve
.Sh "Standard Exports"
.IX Subsection "Standard Exports"
The following routines will be exported into your namespace
if you use the Benchmark module:
.Ip "timeit(\s-1COUNT\s0, \s-1CODE\s0)" 10
.IX Item "timeit(\s-1COUNT\s0, \s-1CODE\s0)"
Arguments: \s-1COUNT\s0 is the number of times to run the loop, and \s-1CODE\s0 is
the code to run.  \s-1CODE\s0 may be either a code reference or a string to
be eval'd; either way it will be run in the caller's package.
.Sp
Returns: a Benchmark object.
.Ip "timethis ( \s-1COUNT\s0, \s-1CODE\s0, [ \s-1TITLE\s0, [ \s-1STYLE\s0 ]] )" 10
.IX Item "timethis ( \s-1COUNT\s0, \s-1CODE\s0, [ \s-1TITLE\s0, [ \s-1STYLE\s0 ]] )"
Time \s-1COUNT\s0 iterations of \s-1CODE\s0. \s-1CODE\s0 may be a string to eval or a
code reference; either way the \s-1CODE\s0 will run in the caller's package.
Results will be printed to \s-1STDOUT\s0 as \s-1TITLE\s0 followed by the times.
\s-1TITLE\s0 defaults to \*(L"timethis \s-1COUNT\s0\*(R" if none is provided. \s-1STYLE\s0
determines the format of the output, as described for \fItimestr()\fR below.
.Ip "timethese ( \s-1COUNT\s0, \s-1CODEHASHREF\s0, [ \s-1STYLE\s0 ] )" 10
.IX Item "timethese ( \s-1COUNT\s0, \s-1CODEHASHREF\s0, [ \s-1STYLE\s0 ] )"
The \s-1CODEHASHREF\s0 is a reference to a hash containing names as keys
and either a string to eval or a code reference for each value.
For each (\s-1KEY\s0, \s-1VALUE\s0) pair in the \s-1CODEHASHREF\s0, this routine will
call
.Sp
.Vb 1
\&        timethis(COUNT, VALUE, KEY, STYLE)
.Ve
.Ip "timediff ( T1, T2 )" 10
.IX Item "timediff ( T1, T2 )"
Returns the difference between two Benchmark times as a Benchmark
object suitable for passing to \fItimestr()\fR.
.Ip "timestr ( \s-1TIMEDIFF\s0, [ \s-1STYLE\s0, [ \s-1FORMAT\s0 ]] )" 10
.IX Item "timestr ( \s-1TIMEDIFF\s0, [ \s-1STYLE\s0, [ \s-1FORMAT\s0 ]] )"
Returns a string that formats the times in the \s-1TIMEDIFF\s0 object in
the requested \s-1STYLE\s0. \s-1TIMEDIFF\s0 is expected to be a Benchmark object
similar to that returned by \fItimediff()\fR.
.Sp
\s-1STYLE\s0 can be any of \*(L'all\*(R', \*(L'noc\*(R', \*(L'nop\*(R' or \*(L'auto\*(R'. \*(L'all\*(R' shows each
of the 5 times available ('wallclock\*(R' time, user time, system time,
user time of children, and system time of children). \*(L'noc\*(R' shows all
except the two children times. \*(L'nop\*(R' shows only wallclock and the
two children times. \*(L'auto\*(R' (the default) will act as \*(L'all\*(R' unless
the children times are both zero, in which case it acts as \*(L'noc\*(R'.
.Sp
\s-1FORMAT\s0 is the the \fIprintf(3)\fR manpage-style format specifier (without the
leading \*(L'%') to use to print the times. It defaults to \*(L'5.2f\*(R'.
.Sh "Optional Exports"
.IX Subsection "Optional Exports"
The following routines will be exported into your namespace
if you specifically ask that they be imported:
.Ip "clearcache ( \s-1COUNT\s0 )" 10
.IX Item "clearcache ( \s-1COUNT\s0 )"
Clear the cached time for \s-1COUNT\s0 rounds of the null loop.
.Ip "clearallcache ( )" 10
.IX Item "clearallcache ( )"
Clear all cached times.
.Ip "disablecache ( )" 10
.IX Item "disablecache ( )"
Disable caching of timings for the null loop. This will force Benchmark
to recalculate these timings for each new piece of code timed.
.Ip "enablecache ( )" 10
.IX Item "enablecache ( )"
Enable caching of timings for the null loop. The time taken for \s-1COUNT\s0
rounds of the null loop will be calculated only once for each
different \s-1COUNT\s0 used.
.SH "NOTES"
.IX Header "NOTES"
The data is stored as a list of values from the time and times
functions:
.PP
.Vb 1
\&      ($real, $user, $system, $children_user, $children_system)
.Ve
in seconds for the whole loop (not divided by the number of rounds).
.PP
The timing is done using \fItime\fR\|(3) and \fItimes\fR\|(3).
.PP
Code is executed in the caller's package.
.PP
The time of the null loop (a loop with the same
number of rounds but empty loop body) is subtracted
from the time of the real loop.
.PP
The null loop times are cached, the key being the
number of rounds. The caching can be controlled using
calls like these:
.PP
.Vb 2
\&    clearcache($key);
\&    clearallcache();
.Ve
.Vb 2
\&    disablecache();
\&    enablecache();
.Ve
.SH "INHERITANCE"
.IX Header "INHERITANCE"
Benchmark inherits from no other class, except of course
for Exporter.
.SH "CAVEATS"
.IX Header "CAVEATS"
Comparing eval'd strings with code references will give you
inaccurate results: a code reference will show a slower
execution time than the equivalent eval'd string.
.PP
The real time timing is done using \fItime\fR\|(2) and
the granularity is therefore only one second.
.PP
Short tests may produce negative figures because perl
can appear to take longer to execute the empty loop
than a short test; try:
.PP
.Vb 1
\&    timethis(100,'1');
.Ve
The system time of the null loop might be slightly
more than the system time of the loop with the actual
code and therefore the difference might end up being < 0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <\fIjhi@iki.fi\fR>, Tim Bunce <\fITim.Bunce@ig.co.uk\fR>
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
September 8th, 1994; by Tim Bunce.
.PP
March 28th, 1997; by Hugo van der Sanden: added support for code
references and the already documented \*(L'debug\*(R' method; revamped
documentation.

.rn }` ''
