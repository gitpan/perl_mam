.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Math::Trig 3 "perl 5.005, patch 53" "7/Jul/98" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Math::Trig \- trigonometric functions
.SH "SYNOPSIS"
.PP
.Vb 7
\&        use Math::Trig;
\&        
\&        $x = tan(0.9);
\&        $y = acos(3.7);
\&        $z = asin(2.4);
\&        
\&        $halfpi = pi/2;
.Ve
.Vb 1
\&        $rad = deg2rad(120);
.Ve
.SH "DESCRIPTION"
\f(CWMath::Trig\fR defines many trigonometric functions not defined by the
core Perl which defines only the \f(CWsin()\fR and \f(CWcos()\fR.  The constant
\fBpi\fR is also defined as are a few convenience functions for angle
conversions.
.SH "TRIGONOMETRIC FUNCTIONS"
The tangent
.Ip "\fBtan\fR" 4
.PP
The cofunctions of the sine, cosine, and tangent (cosec/csc and cotan/cot
are aliases)
.PP
\fBcsc\fR, \fBcosec\fR, \fBsec\fR, \fBsec\fR, \fBcot\fR, \fBcotan\fR
.PP
The arcus (also known as the inverse) functions of the sine, cosine,
and tangent
.PP
\fBasin\fR, \fBacos\fR, \fBatan\fR
.PP
The principal value of the arc tangent of y/x
.PP
\fBatan2\fR(y, x)
.PP
The arcus cofunctions of the sine, cosine, and tangent (acosec/acsc
and acotan/acot are aliases)
.PP
\fBacsc\fR, \fBacosec\fR, \fBasec\fR, \fBacot\fR, \fBacotan\fR
.PP
The hyperbolic sine, cosine, and tangent
.PP
\fBsinh\fR, \fBcosh\fR, \fBtanh\fR
.PP
The cofunctions of the hyperbolic sine, cosine, and tangent (cosech/csch
and cotanh/coth are aliases)
.PP
\fBcsch\fR, \fBcosech\fR, \fBsech\fR, \fBcoth\fR, \fBcotanh\fR
.PP
The arcus (also known as the inverse) functions of the hyperbolic
sine, cosine, and tangent
.PP
\fBasinh\fR, \fBacosh\fR, \fBatanh\fR
.PP
The arcus cofunctions of the hyperbolic sine, cosine, and tangent
(acsch/acosech and acoth/acotanh are aliases)
.PP
\fBacsch\fR, \fBacosech\fR, \fBasech\fR, \fBacoth\fR, \fBacotanh\fR
.PP
The trigonometric constant \fBpi\fR is also defined.
.PP
$pi2 = 2 * \fBpi\fR;
.Sh "\s-1ERRORS\s0 \s-1DUE\s0 \s-1TO\s0 \s-1DIVISION\s0 \s-1BY\s0 \s-1ZERO\s0"
The following functions
.PP
.Vb 14
\&        acoth
\&        acsc
\&        acsch
\&        asec
\&        asech
\&        atanh
\&        cot
\&        coth
\&        csc
\&        csch
\&        sec
\&        sech
\&        tan
\&        tanh
.Ve
cannot be computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause fatal
runtime errors looking like this
.PP
.Vb 3
\&        cot(0): Division by zero.
\&        (Because in the definition of cot(0), the divisor sin(0) is 0)
\&        Died at ...
.Ve
or
.PP
.Vb 2
\&        atanh(-1): Logarithm of zero.
\&        Died at...
.Ve
For the \f(CWcsc\fR, \f(CWcot\fR, \f(CWasec\fR, \f(CWacsc\fR, \f(CWacot\fR, \f(CWcsch\fR, \f(CWcoth\fR,
\f(CWasech\fR, \f(CWacsch\fR, the argument cannot be \f(CW0\fR (zero).  For the
\f(CWatanh\fR, \f(CWacoth\fR, the argument cannot be \f(CW1\fR (one).  For the
\f(CWatanh\fR, \f(CWacoth\fR, the argument cannot be \f(CW-1\fR (minus one).  For the
\f(CWtan\fR, \f(CWsec\fR, \f(CWtanh\fR, \f(CWsech\fR, the argument cannot be \fIpi/2 + k *
pi\fR, where \fIk\fR is any integer.
.Sh "\s-1SIMPLE\s0 (\s-1REAL\s0) \s-1ARGUMENTS\s0, \s-1COMPLEX\s0 \s-1RESULTS\s0"
Please note that some of the trigonometric functions can break out
from the \fBreal axis\fR into the \fBcomplex plane\fR. For example
\f(CWasin(2)\fR has no definition for plain real numbers but it has
definition for complex numbers.
.PP
In Perl terms this means that supplying the usual Perl numbers (also
known as scalars, please see the \fIperldata\fR manpage) as input for the
trigonometric functions might produce as output results that no more
are simple real numbers: instead they are complex numbers.
.PP
The \f(CWMath::Trig\fR handles this by using the \f(CWMath::Complex\fR package
which knows how to handle complex numbers, please see the \fIMath::Complex\fR manpage
for more information. In practice you need not to worry about getting
complex numbers as results because the \f(CWMath::Complex\fR takes care of
details like for example how to display complex numbers. For example:
.PP
.Vb 3
\&        print asin(2), "\en";
\&    
\&should produce something like this (take or leave few last decimals):
.Ve
.Vb 1
\&        1.5707963267949-1.31695789692482i
.Ve
That is, a complex number with the real part of approximately \f(CW1.571\fR
and the imaginary part of approximately \f(CW-1.317\fR.
.SH "PLANE ANGLE CONVERSIONS"
(Plane, 2-dimensional) angles may be converted with the following functions.
.PP
.Vb 8
\&        $radians  = deg2rad($degrees);
\&        $radians  = grad2rad($gradians);
\&        
\&        $degrees  = rad2deg($radians);
\&        $degrees  = grad2deg($gradians);
\&        
\&        $gradians = deg2grad($degrees);
\&        $gradians = rad2grad($radians);
.Ve
The full circle is 2 \fIpi\fR radians or \fI360\fR degrees or \fI400\fR gradians.
.SH "RADIAL COORDINATE CONVERSIONS"
\fBRadial coordinate systems\fR are the \fBspherical\fR and the \fBcylindrical\fR
systems, explained shortly in more detail.
.PP
You can import radial coordinate conversion functions by using the
\f(CW:radial\fR tag:
.PP
.Vb 1
\&    use Math::Trig ':radial';
.Ve
.Vb 6
\&    ($rho, $theta, $z)     = cartesian_to_cylindrical($x, $y, $z);
\&    ($rho, $theta, $phi)   = cartesian_to_spherical($x, $y, $z);
\&    ($x, $y, $z)           = cylindrical_to_cartesian($rho, $theta, $z);
\&    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
\&    ($x, $y, $z)           = spherical_to_cartesian($rho, $theta, $phi);
\&    ($rho_c, $theta, $z)   = spherical_to_cylindrical($rho_s, $theta, $phi);
.Ve
\fBAll angles are in radians\fR.
.Sh "\s-1COORDINATE\s0 \s-1SYSTEMS\s0"
\fBCartesian\fR coordinates are the usual rectangular \fI(x, y,
z)\fR\-coordinates.
.PP
Spherical coordinates, \fI(rho, theta, pi)\fR, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a sphere surface.  The radius of the sphere is \fBrho\fR, also
known as the \fIradial\fR coordinate.  The angle in the \fIxy\fR\-plane
(around the \fIz\fR\-axis) is \fBtheta\fR, also known as the \fIazimuthal\fR
coordinate.  The angle from the \fIz\fR\-axis is \fBphi\fR, also known as the
\fIpolar\fR coordinate.  The `North Pole\*(R' is therefore \fI0, 0, rho\fR, and
the `Bay of Guinea\*(R' (think of the missing big chunk of Africa) \fI0,
pi/2, rho\fR.
.PP
\fBBeware\fR: some texts define \fItheta\fR and \fIphi\fR the other way round,
some texts define the \fIphi\fR to start from the horizontal plane, some
texts use \fIr\fR in place of \fIrho\fR.
.PP
Cylindrical coordinates, \fI(rho, theta, z)\fR, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a cylinder surface.  The radius of the cylinder is \fBrho\fR,
also known as the \fIradial\fR coordinate.  The angle in the \fIxy\fR\-plane
(around the \fIz\fR\-axis) is \fBtheta\fR, also known as the \fIazimuthal\fR
coordinate.  The third coordinate is the \fIz\fR, pointing up from the
\fBtheta\fR\-plane.
.Sh "3-D \s-1ANGLE\s0 \s-1CONVERSIONS\s0"
Conversions to and from spherical and cylindrical coordinates are
available.  Please notice that the conversions are not necessarily
reversible because of the equalities like \fIpi\fR angles being equal to
\fI\-pi\fR angles.
.Ip "cartesian_to_cylindrical" 4
.Sp
.Vb 1
\&        ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);
.Ve
.Ip "cartesian_to_spherical" 4
.Sp
.Vb 1
\&        ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);
.Ve
.Ip "cylindrical_to_cartesian" 4
.Sp
.Vb 1
\&        ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);
.Ve
.Ip "cylindrical_to_spherical" 4
.Sp
.Vb 1
\&        ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
.Ve
Notice that when \f(CW$z\fR is not 0 \f(CW$rho_s\fR is not equal to \f(CW$rho_c\fR.
.Ip "spherical_to_cartesian" 4
.Sp
.Vb 1
\&        ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);
.Ve
.Ip "spherical_to_cylindrical" 4
.Sp
.Vb 1
\&        ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);
.Ve
Notice that when \f(CW$z\fR is not 0 \f(CW$rho_c\fR is not equal to \f(CW$rho_s\fR.
.SH "GREAT CIRCLE DISTANCES"
You can compute spherical distances, called \fBgreat circle distances\fR,
by importing the \f(CWgreat_circle_distance\fR function:
.PP
.Vb 1
\&        use Math::Trig 'great_circle_distance'
.Ve
.Vb 1
\&    $distance = great_circle_distance($theta0, $phi0, $theta1, $phi, [, $rho]);
.Ve
The \fIgreat circle distance\fR is the shortest distance between two
points on a sphere.  The distance is in \f(CW$rho\fR units.  The \f(CW$rho\fR is
optional, it defaults to 1 (the unit sphere), therefore the distance
defaults to radians.
.SH "EXAMPLES"
To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N
139.8E) in kilometers:
.PP
.Vb 1
\&        use Math::Trig qw(great_circle_distance deg2rad);
.Ve
.Vb 3
\&        # Notice the 90 - latitude: phi zero is at the North Pole.
\&        @L = (deg2rad(-0.5), deg2rad(90 - 51.3));
\&        @T = (deg2rad(139.8),deg2rad(90 - 35.7));
.Ve
.Vb 1
\&        $km = great_circle_distance(@L, @T, 6378);
.Ve
The answer may be off by up to 0.3% because of the irregular (slightly
aspherical) form of the Earth.
.SH "BUGS"
Saying \f(CWuse Math::Trig;\fR exports many mathematical routines in the
caller environment and even overrides some (\f(CWsin\fR, \f(CWcos\fR).  This is
construed as a feature by the Authors, actually... ;\-)
.PP
The code is not optimized for speed, especially because we use
\f(CWMath::Complex\fR and thus go quite near complex numbers while doing
the computations even when the arguments are not. This, however,
cannot be completely avoided if we want things like \f(CWasin(2)\fR to give
an answer instead of giving a fatal runtime error.
.SH "AUTHORS"
Jarkko Hietaniemi <\fIjhi@iki.fi\fR> and 
Raphael Manfredi <\fIRaphael_Manfredi@grenoble.hp.com\fR>.

.rn }` ''
.IX Title "Math::Trig 3"
.IX Name "Math::Trig - trigonometric functions"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "TRIGONOMETRIC FUNCTIONS"

.IX Item "\fBtan\fR"

.IX Subsection "\s-1ERRORS\s0 \s-1DUE\s0 \s-1TO\s0 \s-1DIVISION\s0 \s-1BY\s0 \s-1ZERO\s0"

.IX Subsection "\s-1SIMPLE\s0 (\s-1REAL\s0) \s-1ARGUMENTS\s0, \s-1COMPLEX\s0 \s-1RESULTS\s0"

.IX Header "PLANE ANGLE CONVERSIONS"

.IX Header "RADIAL COORDINATE CONVERSIONS"

.IX Subsection "\s-1COORDINATE\s0 \s-1SYSTEMS\s0"

.IX Subsection "3-D \s-1ANGLE\s0 \s-1CONVERSIONS\s0"

.IX Item "cartesian_to_cylindrical"

.IX Item "cartesian_to_spherical"

.IX Item "cylindrical_to_cartesian"

.IX Item "cylindrical_to_spherical"

.IX Item "spherical_to_cartesian"

.IX Item "spherical_to_cylindrical"

.IX Header "GREAT CIRCLE DISTANCES"

.IX Header "EXAMPLES"

.IX Header "BUGS"

.IX Header "AUTHORS"

