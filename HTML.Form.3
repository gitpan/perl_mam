.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::HTML::Form 3 "libwww-perl-5.64" "1/Aug/101" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
HTML::Form \- Class that represents HTML forms
.SH "SYNOPSIS"
.PP
.Vb 3
\& use HTML::Form;
\& $form = HTML::Form->parse($html, $base_uri);
\& $form->value(query => "Perl");
.Ve
.Vb 2
\& use LWP;
\& LWP::UserAgent->new->request($form->click);
.Ve
.SH "DESCRIPTION"
Objects of the \f(CWHTML::Form\fR class represents a single HTML <form>
\&... </form> instance.  A form consist of a sequence of inputs that
usually have names, and which can take on various values.
.PP
The following methods are available:
.Ip "$form = \s-1HTML::\s0Form->new($method, $action_uri, [[$enctype], $input,...])" 4
The constructor takes a \f(CW$method\fR and a \f(CW$uri\fR as argument.  The \f(CW$enctype\fR
and and initial inputs are optional.  You will normally use
\s-1HTML::\s0Form->\fIparse()\fR to create new \s-1HTML::\s0Form objects.
.Ip "@forms = \s-1HTML::\s0Form->parse($html_document, $base_uri)" 4
The \fIparse()\fR class method will parse an \s-1HTML\s0 document and build up
\f(CWHTML::Form\fR objects for each <form> found.  If called in scalar
context only returns the first <form>.  Returns an empty list if there
are no forms to be found.
.Sp
The \f(CW$base_uri\fR is (usually) the \s-1URI\s0 used to access the \f(CW$html_document\fR.
It is needed to resolve relative action URIs.  For \s-1LWP\s0 this parameter
is obtained from the \f(CW$response\fR\->\fIbase()\fR method.
.Ip "$form->push_input($type, \e%attr)" 4
Adds a new input to the form.
.Ip "$form->method( [$new] )" 4
.Ip "$form->action( [$new] )" 4
.Ip "$form->enctype( [$new] )" 4
These method can be used to get/set the corresponding attribute of the
form.
.Ip "$form->inputs" 4
This method returns the list of inputs in the form.
.Ip "$form->find_input($name, $type, $no)" 4
This method is used to locate some specific input within the form.  At
least one of the arguments must be defined.  If no matching input is
found, \f(CWundef\fR is returned.
.Sp
If \f(CW$name\fR is specified, then the input must have the indicated name.
If \f(CW$type\fR is specified then the input must have the specified type.  In
addition to the types possible for <input> \s-1HTML\s0 tags, we also have
\*(L"textarea\*(R" and \*(L"option\*(R".  The \f(CW$no\fR is the sequence number of the input
with the indicated \f(CW$name\fR and/or \f(CW$type\fR (where 1 is the first).
.Ip "$form->value($name, [$value])" 4
The \fIvalue()\fR method can be used to get/set the value of some input.  If
no input have the indicated name, then this method will croak.
.Ip "$form->try_others(\e&callback)" 4
This method will iterate over all permutations of unvisited enumerated
values (<select>, <radio>, <checkbox>) and invoke the callback for
each.  The callback is passed the \f(CW$form\fR as argument.
.Ip "$form->make_request" 4
Will return a \s-1HTTP::\s0Request object that reflects the current setting
of the form.  You might want to use the click method instead.
.Ip "$form->click([$name], [$x, $y])" 4
Will click on the first clickable input (\f(CWinput/submit\fR or
\f(CWinput/image\fR), with the indicated \f(CW$name\fR, if specified.  You can
optinally specify a coordinate clicked, which only makes a difference
if you clicked on an image.  The default coordinate is (1,1).
.Ip "$form->form" 4
Returns the current setting as a sequence of key/value pairs.
.Ip "$form->dump" 4
Returns a textual representation of the form.  Mainly useful for
debugging.  If called in void context, then the dump is printed on
\s-1STDERR\s0.
.SH "INPUTS"
An \f(CWHTML::Form\fR contains a sequence of inputs.  References to the
inputs can be obtained with the \f(CW$form\fR\->inputs or \f(CW$form\fR\->find_input
methods.  Once you have such a reference, then one of the following
methods can be used on it:
.Ip "$input->type" 4
Returns the type of this input.  Types are stuff like \*(L"text\*(R",
\*(L"password\*(R", \*(L"hidden\*(R", \*(L"textarea\*(R", \*(L"image\*(R", \*(L"submit\*(R", \*(L"radio\*(R",
\*(L"checkbox\*(R", \*(L"option\*(R"...
.Ip "$input->name([$new])" 4
.Ip "$input->value([$new])" 4
These methods can be used to set/get the current name or value of an
input.  If the input only can take an enumerated list of values, then
it is an error to try to set it to something else and the method will
croak if you try.
.Ip "$input->possible_values" 4
Returns a list of all values that and input can take.  For inputs that
does not have discrete values this returns an empty list.
.Ip "$input->other_possible_values" 4
Returns a list of all values not tried yet.
.Ip "$input->form_name_value" 4
Returns a (possible empty) list of key/value pairs that should be
incorporated in the form value from this input.
.Ip "$input->click($form, $x, $y)" 4
Some input types (currently \*(L"sumbit\*(R" buttons and \*(L"images") can be
clicked to submit the form.  The \fIclick()\fR method returns the
corrsponding \f(CWHTTP::Request\fR object.
.SH "SEE ALSO"
the \fILWP\fR manpage, the \fIHTML::Parser\fR manpage, the \fIwebchatpp\fR manpage
.SH "COPYRIGHT"
Copyright 1998-2000 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

.rn }` ''
.IX Title "lib::HTML::Form 3"
.IX Name "HTML::Form - Class that represents HTML forms"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "$form = \s-1HTML::\s0Form->new($method, $action_uri, [[$enctype], $input,...])"

.IX Item "@forms = \s-1HTML::\s0Form->parse($html_document, $base_uri)"

.IX Item "$form->push_input($type, \e%attr)"

.IX Item "$form->method( [$new] )"

.IX Item "$form->action( [$new] )"

.IX Item "$form->enctype( [$new] )"

.IX Item "$form->inputs"

.IX Item "$form->find_input($name, $type, $no)"

.IX Item "$form->value($name, [$value])"

.IX Item "$form->try_others(\e&callback)"

.IX Item "$form->make_request"

.IX Item "$form->click([$name], [$x, $y])"

.IX Item "$form->form"

.IX Item "$form->dump"

.IX Header "INPUTS"

.IX Item "$input->type"

.IX Item "$input->name([$new])"

.IX Item "$input->value([$new])"

.IX Item "$input->possible_values"

.IX Item "$input->other_possible_values"

.IX Item "$input->form_name_value"

.IX Item "$input->click($form, $x, $y)"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

