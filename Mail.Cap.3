.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Mail::Cap 3 "perl 5.007, patch 00" "8/Feb/102" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Mail::Cap \- Parse mailcap files
.SH "SYNOPSIS"
.PP
.Vb 1
\&    my $mc = new Mail::Cap;
.Ve
.Vb 1
\&    $desc = $mc->description('image/gif');
.Ve
.Vb 1
\&    print "GIF desc: $desc\en";
.Ve
.Vb 1
\&    $cmd = $mc->viewCmd('text/plain; charset=iso-8859-1', 'file.txt');
.Ve
.SH "DESCRIPTION"
Parse mailcap files as specified in RFC 1524 \- \fIA User Agent
Configuration Mechanism For Multimedia Mail Format Information\fR.  In
the description below \f(CW$type\fR refers to the MIME type as specified in
the \fIContent-Type\fR header of mail or HTTP messages.  Examples of
types are:
.PP
.Vb 3
\&  image/gif
\&  text/html
\&  text/plain; charset=iso-8859-1
.Ve
.SH "METHODS"
.Sh "\fInew()\fR"
.PP
.Vb 2
\&  $mcap = new Mail::Cap;
\&  $mcap = new Mail::Cap "/mydir/mailcap";
.Ve
Create and initialize a new Mail::Cap object.  If you give it an
argument it will try to parse the specified file.  Without any
arguments it will search for the mailcap file using the standard
mailcap path, or the \s-1MAILCAPS\s0 environment variable if it is defined.
.Sh "\fIview\fR\|($type, \f(CW$file\fR)"
.Sh "\fIcompose\fR\|($type, \f(CW$file\fR)"
.Sh "\fIedit\fR\|($type, \f(CW$file\fR)"
.Sh "\fIprint\fR\|($type, \f(CW$file\fR)"
These methods invoke a suitable progam presenting or manipulating the
media object in the specified file.  They all return \f(CW1\fR if a command
was found, and \f(CW0\fR otherwise.  You might test \f(CW$?\fR for the outcome
of the command.
.Sh "\fIviewCmd\fR\|($type, \f(CW$file\fR)"
.Sh "\fIcomposeCmd\fR\|($type, \f(CW$file\fR)"
.Sh "\fIeditCmd\fR\|($type, \f(CW$file\fR)"
.Sh "\fIprintCmd\fR\|($type, \f(CW$file\fR)"
These methods return a string that is suitable for feeding to \fIsystem()\fR
in order to invoke a suitable progam presenting or manipulating the
media object in the specified file.  It will return \f(CWundef\fR if no
suitable specification exists.
.Sh "\fIfield\fR\|($type, \f(CW$field\fR)"
Returns the specified field for the type.  Returns undef if no
specification exsists.
.Sh "\fIdescription\fR\|($type)"
.Sh "\fItextualnewlines\fR\|($type)"
.Sh "\fIx11_bitmap\fR\|($type)"
.Sh "\fInametemplate\fR\|($type)"
These methods return the corresponding mailcap field for the type.
These methods should be more convenient to use than the \fIfield()\fR method
for the same fields.
.SH "COPYRIGHT"
Copyright (c) 1995 Gisle Aas. All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
Gisle Aas <aas@oslonett.no> 
.PP
Modified by Graham Barr <gbarr@pobox.com>
.PP
Maintained by Mark Overmeer <mailtools@overmeer.net>

.rn }` ''
.IX Title "Mail::Cap 3"
.IX Name "Mail::Cap - Parse mailcap files"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "METHODS"

.IX Subsection "\fInew()\fR"

.IX Subsection "\fIview\fR\|($type, \f(CW$file\fR)"

.IX Subsection "\fIcompose\fR\|($type, \f(CW$file\fR)"

.IX Subsection "\fIedit\fR\|($type, \f(CW$file\fR)"

.IX Subsection "\fIprint\fR\|($type, \f(CW$file\fR)"

.IX Subsection "\fIviewCmd\fR\|($type, \f(CW$file\fR)"

.IX Subsection "\fIcomposeCmd\fR\|($type, \f(CW$file\fR)"

.IX Subsection "\fIeditCmd\fR\|($type, \f(CW$file\fR)"

.IX Subsection "\fIprintCmd\fR\|($type, \f(CW$file\fR)"

.IX Subsection "\fIfield\fR\|($type, \f(CW$field\fR)"

.IX Subsection "\fIdescription\fR\|($type)"

.IX Subsection "\fItextualnewlines\fR\|($type)"

.IX Subsection "\fIx11_bitmap\fR\|($type)"

.IX Subsection "\fInametemplate\fR\|($type)"

.IX Header "COPYRIGHT"

.IX Header "AUTHOR"

